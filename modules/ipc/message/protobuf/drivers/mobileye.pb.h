// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/ipc/message/protobuf/drivers/mobileye.proto

#ifndef PROTOBUF_modules_2fipc_2fmessage_2fprotobuf_2fdrivers_2fmobileye_2eproto__INCLUDED
#define PROTOBUF_modules_2fipc_2fmessage_2fprotobuf_2fdrivers_2fmobileye_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include "modules/ipc/message/protobuf/common/header.pb.h"
#include "modules/ipc/message/protobuf/common/reserved.pb.h"
// @@protoc_insertion_point(includes)
namespace atd {
namespace common {
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Reserved;
class ReservedDefaultTypeInternal;
extern ReservedDefaultTypeInternal _Reserved_default_instance_;
}  // namespace common
namespace drivers {
class MOBILEYE_LANE_LINE;
class MOBILEYE_LANE_LINEDefaultTypeInternal;
extern MOBILEYE_LANE_LINEDefaultTypeInternal _MOBILEYE_LANE_LINE_default_instance_;
class MOBI_LANES;
class MOBI_LANESDefaultTypeInternal;
extern MOBI_LANESDefaultTypeInternal _MOBI_LANES_default_instance_;
}  // namespace drivers
}  // namespace atd

namespace atd {
namespace drivers {

namespace protobuf_modules_2fipc_2fmessage_2fprotobuf_2fdrivers_2fmobileye_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_modules_2fipc_2fmessage_2fprotobuf_2fdrivers_2fmobileye_2eproto

// ===================================================================

class MOBILEYE_LANE_LINE : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.drivers.MOBILEYE_LANE_LINE) */ {
 public:
  MOBILEYE_LANE_LINE();
  virtual ~MOBILEYE_LANE_LINE();

  MOBILEYE_LANE_LINE(const MOBILEYE_LANE_LINE& from);

  inline MOBILEYE_LANE_LINE& operator=(const MOBILEYE_LANE_LINE& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const MOBILEYE_LANE_LINE& default_instance();

  static inline const MOBILEYE_LANE_LINE* internal_default_instance() {
    return reinterpret_cast<const MOBILEYE_LANE_LINE*>(
               &_MOBILEYE_LANE_LINE_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(MOBILEYE_LANE_LINE* other);

  // implements Message ----------------------------------------------

  inline MOBILEYE_LANE_LINE* New() const PROTOBUF_FINAL { return New(NULL); }

  MOBILEYE_LANE_LINE* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const MOBILEYE_LANE_LINE& from);
  void MergeFrom(const MOBILEYE_LANE_LINE& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MOBILEYE_LANE_LINE* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 nLineType = 1;
  bool has_nlinetype() const;
  void clear_nlinetype();
  static const int kNLineTypeFieldNumber = 1;
  ::google::protobuf::int32 nlinetype() const;
  void set_nlinetype(::google::protobuf::int32 value);

  // optional int32 nQuality = 2;
  bool has_nquality() const;
  void clear_nquality();
  static const int kNQualityFieldNumber = 2;
  ::google::protobuf::int32 nquality() const;
  void set_nquality(::google::protobuf::int32 value);

  // optional float fWidth = 3;
  bool has_fwidth() const;
  void clear_fwidth();
  static const int kFWidthFieldNumber = 3;
  float fwidth() const;
  void set_fwidth(float value);

  // optional int32 bLineCrossing = 4;
  bool has_blinecrossing() const;
  void clear_blinecrossing();
  static const int kBLineCrossingFieldNumber = 4;
  ::google::protobuf::int32 blinecrossing() const;
  void set_blinecrossing(::google::protobuf::int32 value);

  // optional int32 nLineColor = 5;
  bool has_nlinecolor() const;
  void clear_nlinecolor();
  static const int kNLineColorFieldNumber = 5;
  ::google::protobuf::int32 nlinecolor() const;
  void set_nlinecolor(::google::protobuf::int32 value);

  // optional float fTLC = 6;
  bool has_ftlc() const;
  void clear_ftlc();
  static const int kFTLCFieldNumber = 6;
  float ftlc() const;
  void set_ftlc(float value);

  // optional float a = 7;
  bool has_a() const;
  void clear_a();
  static const int kAFieldNumber = 7;
  float a() const;
  void set_a(float value);

  // optional float b = 8;
  bool has_b() const;
  void clear_b();
  static const int kBFieldNumber = 8;
  float b() const;
  void set_b(float value);

  // optional float c = 9;
  bool has_c() const;
  void clear_c();
  static const int kCFieldNumber = 9;
  float c() const;
  void set_c(float value);

  // optional float d = 10;
  bool has_d() const;
  void clear_d();
  static const int kDFieldNumber = 10;
  float d() const;
  void set_d(float value);

  // optional float x0 = 11;
  bool has_x0() const;
  void clear_x0();
  static const int kX0FieldNumber = 11;
  float x0() const;
  void set_x0(float value);

  // optional float x1 = 12;
  bool has_x1() const;
  void clear_x1();
  static const int kX1FieldNumber = 12;
  float x1() const;
  void set_x1(float value);

  // @@protoc_insertion_point(class_scope:atd.drivers.MOBILEYE_LANE_LINE)
 private:
  void set_has_nlinetype();
  void clear_has_nlinetype();
  void set_has_nquality();
  void clear_has_nquality();
  void set_has_fwidth();
  void clear_has_fwidth();
  void set_has_blinecrossing();
  void clear_has_blinecrossing();
  void set_has_nlinecolor();
  void clear_has_nlinecolor();
  void set_has_ftlc();
  void clear_has_ftlc();
  void set_has_a();
  void clear_has_a();
  void set_has_b();
  void clear_has_b();
  void set_has_c();
  void clear_has_c();
  void set_has_d();
  void clear_has_d();
  void set_has_x0();
  void clear_has_x0();
  void set_has_x1();
  void clear_has_x1();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 nlinetype_;
  ::google::protobuf::int32 nquality_;
  float fwidth_;
  ::google::protobuf::int32 blinecrossing_;
  ::google::protobuf::int32 nlinecolor_;
  float ftlc_;
  float a_;
  float b_;
  float c_;
  float d_;
  float x0_;
  float x1_;
  friend struct protobuf_modules_2fipc_2fmessage_2fprotobuf_2fdrivers_2fmobileye_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MOBI_LANES : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.drivers.MOBI_LANES) */ {
 public:
  MOBI_LANES();
  virtual ~MOBI_LANES();

  MOBI_LANES(const MOBI_LANES& from);

  inline MOBI_LANES& operator=(const MOBI_LANES& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const MOBI_LANES& default_instance();

  static inline const MOBI_LANES* internal_default_instance() {
    return reinterpret_cast<const MOBI_LANES*>(
               &_MOBI_LANES_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(MOBI_LANES* other);

  // implements Message ----------------------------------------------

  inline MOBI_LANES* New() const PROTOBUF_FINAL { return New(NULL); }

  MOBI_LANES* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const MOBI_LANES& from);
  void MergeFrom(const MOBI_LANES& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MOBI_LANES* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .atd.common.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::atd::common::Header& header() const;
  ::atd::common::Header* mutable_header();
  ::atd::common::Header* release_header();
  void set_allocated_header(::atd::common::Header* header);

  // optional .atd.drivers.MOBILEYE_LANE_LINE stLeftLine = 10;
  bool has_stleftline() const;
  void clear_stleftline();
  static const int kStLeftLineFieldNumber = 10;
  const ::atd::drivers::MOBILEYE_LANE_LINE& stleftline() const;
  ::atd::drivers::MOBILEYE_LANE_LINE* mutable_stleftline();
  ::atd::drivers::MOBILEYE_LANE_LINE* release_stleftline();
  void set_allocated_stleftline(::atd::drivers::MOBILEYE_LANE_LINE* stleftline);

  // optional .atd.drivers.MOBILEYE_LANE_LINE stRightLine = 11;
  bool has_strightline() const;
  void clear_strightline();
  static const int kStRightLineFieldNumber = 11;
  const ::atd::drivers::MOBILEYE_LANE_LINE& strightline() const;
  ::atd::drivers::MOBILEYE_LANE_LINE* mutable_strightline();
  ::atd::drivers::MOBILEYE_LANE_LINE* release_strightline();
  void set_allocated_strightline(::atd::drivers::MOBILEYE_LANE_LINE* strightline);

  // optional .atd.drivers.MOBILEYE_LANE_LINE stNextLeftLine = 12;
  bool has_stnextleftline() const;
  void clear_stnextleftline();
  static const int kStNextLeftLineFieldNumber = 12;
  const ::atd::drivers::MOBILEYE_LANE_LINE& stnextleftline() const;
  ::atd::drivers::MOBILEYE_LANE_LINE* mutable_stnextleftline();
  ::atd::drivers::MOBILEYE_LANE_LINE* release_stnextleftline();
  void set_allocated_stnextleftline(::atd::drivers::MOBILEYE_LANE_LINE* stnextleftline);

  // optional .atd.drivers.MOBILEYE_LANE_LINE stNextRightLine = 13;
  bool has_stnextrightline() const;
  void clear_stnextrightline();
  static const int kStNextRightLineFieldNumber = 13;
  const ::atd::drivers::MOBILEYE_LANE_LINE& stnextrightline() const;
  ::atd::drivers::MOBILEYE_LANE_LINE* mutable_stnextrightline();
  ::atd::drivers::MOBILEYE_LANE_LINE* release_stnextrightline();
  void set_allocated_stnextrightline(::atd::drivers::MOBILEYE_LANE_LINE* stnextrightline);

  // optional .atd.common.Reserved reservedmsg = 14;
  bool has_reservedmsg() const;
  void clear_reservedmsg();
  static const int kReservedmsgFieldNumber = 14;
  const ::atd::common::Reserved& reservedmsg() const;
  ::atd::common::Reserved* mutable_reservedmsg();
  ::atd::common::Reserved* release_reservedmsg();
  void set_allocated_reservedmsg(::atd::common::Reserved* reservedmsg);

  // optional int32 nConstructionFlag = 2;
  bool has_nconstructionflag() const;
  void clear_nconstructionflag();
  static const int kNConstructionFlagFieldNumber = 2;
  ::google::protobuf::int32 nconstructionflag() const;
  void set_nconstructionflag(::google::protobuf::int32 value);

  // optional int32 nRoadType = 3;
  bool has_nroadtype() const;
  void clear_nroadtype();
  static const int kNRoadTypeFieldNumber = 3;
  ::google::protobuf::int32 nroadtype() const;
  void set_nroadtype(::google::protobuf::int32 value);

  // optional int32 bHighwayExitRight = 4;
  bool has_bhighwayexitright() const;
  void clear_bhighwayexitright();
  static const int kBHighwayExitRightFieldNumber = 4;
  ::google::protobuf::int32 bhighwayexitright() const;
  void set_bhighwayexitright(::google::protobuf::int32 value);

  // optional int32 bHighwayExitLeft = 5;
  bool has_bhighwayexitleft() const;
  void clear_bhighwayexitleft();
  static const int kBHighwayExitLeftFieldNumber = 5;
  ::google::protobuf::int32 bhighwayexitleft() const;
  void set_bhighwayexitleft(::google::protobuf::int32 value);

  // optional float fLeftLaneDrivingSpeed = 6;
  bool has_fleftlanedrivingspeed() const;
  void clear_fleftlanedrivingspeed();
  static const int kFLeftLaneDrivingSpeedFieldNumber = 6;
  float fleftlanedrivingspeed() const;
  void set_fleftlanedrivingspeed(float value);

  // optional float fRightLaneDrivingSpeed = 7;
  bool has_frightlanedrivingspeed() const;
  void clear_frightlanedrivingspeed();
  static const int kFRightLaneDrivingSpeedFieldNumber = 7;
  float frightlanedrivingspeed() const;
  void set_frightlanedrivingspeed(float value);

  // optional float fLeftLaneProbability = 8;
  bool has_fleftlaneprobability() const;
  void clear_fleftlaneprobability();
  static const int kFLeftLaneProbabilityFieldNumber = 8;
  float fleftlaneprobability() const;
  void set_fleftlaneprobability(float value);

  // optional float fRightLaneProbability = 9;
  bool has_frightlaneprobability() const;
  void clear_frightlaneprobability();
  static const int kFRightLaneProbabilityFieldNumber = 9;
  float frightlaneprobability() const;
  void set_frightlaneprobability(float value);

  // @@protoc_insertion_point(class_scope:atd.drivers.MOBI_LANES)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_nconstructionflag();
  void clear_has_nconstructionflag();
  void set_has_nroadtype();
  void clear_has_nroadtype();
  void set_has_bhighwayexitright();
  void clear_has_bhighwayexitright();
  void set_has_bhighwayexitleft();
  void clear_has_bhighwayexitleft();
  void set_has_fleftlanedrivingspeed();
  void clear_has_fleftlanedrivingspeed();
  void set_has_frightlanedrivingspeed();
  void clear_has_frightlanedrivingspeed();
  void set_has_fleftlaneprobability();
  void clear_has_fleftlaneprobability();
  void set_has_frightlaneprobability();
  void clear_has_frightlaneprobability();
  void set_has_stleftline();
  void clear_has_stleftline();
  void set_has_strightline();
  void clear_has_strightline();
  void set_has_stnextleftline();
  void clear_has_stnextleftline();
  void set_has_stnextrightline();
  void clear_has_stnextrightline();
  void set_has_reservedmsg();
  void clear_has_reservedmsg();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::atd::common::Header* header_;
  ::atd::drivers::MOBILEYE_LANE_LINE* stleftline_;
  ::atd::drivers::MOBILEYE_LANE_LINE* strightline_;
  ::atd::drivers::MOBILEYE_LANE_LINE* stnextleftline_;
  ::atd::drivers::MOBILEYE_LANE_LINE* stnextrightline_;
  ::atd::common::Reserved* reservedmsg_;
  ::google::protobuf::int32 nconstructionflag_;
  ::google::protobuf::int32 nroadtype_;
  ::google::protobuf::int32 bhighwayexitright_;
  ::google::protobuf::int32 bhighwayexitleft_;
  float fleftlanedrivingspeed_;
  float frightlanedrivingspeed_;
  float fleftlaneprobability_;
  float frightlaneprobability_;
  friend struct protobuf_modules_2fipc_2fmessage_2fprotobuf_2fdrivers_2fmobileye_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// MOBILEYE_LANE_LINE

// optional int32 nLineType = 1;
inline bool MOBILEYE_LANE_LINE::has_nlinetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MOBILEYE_LANE_LINE::set_has_nlinetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MOBILEYE_LANE_LINE::clear_has_nlinetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MOBILEYE_LANE_LINE::clear_nlinetype() {
  nlinetype_ = 0;
  clear_has_nlinetype();
}
inline ::google::protobuf::int32 MOBILEYE_LANE_LINE::nlinetype() const {
  // @@protoc_insertion_point(field_get:atd.drivers.MOBILEYE_LANE_LINE.nLineType)
  return nlinetype_;
}
inline void MOBILEYE_LANE_LINE::set_nlinetype(::google::protobuf::int32 value) {
  set_has_nlinetype();
  nlinetype_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.MOBILEYE_LANE_LINE.nLineType)
}

// optional int32 nQuality = 2;
inline bool MOBILEYE_LANE_LINE::has_nquality() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MOBILEYE_LANE_LINE::set_has_nquality() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MOBILEYE_LANE_LINE::clear_has_nquality() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MOBILEYE_LANE_LINE::clear_nquality() {
  nquality_ = 0;
  clear_has_nquality();
}
inline ::google::protobuf::int32 MOBILEYE_LANE_LINE::nquality() const {
  // @@protoc_insertion_point(field_get:atd.drivers.MOBILEYE_LANE_LINE.nQuality)
  return nquality_;
}
inline void MOBILEYE_LANE_LINE::set_nquality(::google::protobuf::int32 value) {
  set_has_nquality();
  nquality_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.MOBILEYE_LANE_LINE.nQuality)
}

// optional float fWidth = 3;
inline bool MOBILEYE_LANE_LINE::has_fwidth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MOBILEYE_LANE_LINE::set_has_fwidth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MOBILEYE_LANE_LINE::clear_has_fwidth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MOBILEYE_LANE_LINE::clear_fwidth() {
  fwidth_ = 0;
  clear_has_fwidth();
}
inline float MOBILEYE_LANE_LINE::fwidth() const {
  // @@protoc_insertion_point(field_get:atd.drivers.MOBILEYE_LANE_LINE.fWidth)
  return fwidth_;
}
inline void MOBILEYE_LANE_LINE::set_fwidth(float value) {
  set_has_fwidth();
  fwidth_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.MOBILEYE_LANE_LINE.fWidth)
}

// optional int32 bLineCrossing = 4;
inline bool MOBILEYE_LANE_LINE::has_blinecrossing() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MOBILEYE_LANE_LINE::set_has_blinecrossing() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MOBILEYE_LANE_LINE::clear_has_blinecrossing() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MOBILEYE_LANE_LINE::clear_blinecrossing() {
  blinecrossing_ = 0;
  clear_has_blinecrossing();
}
inline ::google::protobuf::int32 MOBILEYE_LANE_LINE::blinecrossing() const {
  // @@protoc_insertion_point(field_get:atd.drivers.MOBILEYE_LANE_LINE.bLineCrossing)
  return blinecrossing_;
}
inline void MOBILEYE_LANE_LINE::set_blinecrossing(::google::protobuf::int32 value) {
  set_has_blinecrossing();
  blinecrossing_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.MOBILEYE_LANE_LINE.bLineCrossing)
}

// optional int32 nLineColor = 5;
inline bool MOBILEYE_LANE_LINE::has_nlinecolor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MOBILEYE_LANE_LINE::set_has_nlinecolor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MOBILEYE_LANE_LINE::clear_has_nlinecolor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MOBILEYE_LANE_LINE::clear_nlinecolor() {
  nlinecolor_ = 0;
  clear_has_nlinecolor();
}
inline ::google::protobuf::int32 MOBILEYE_LANE_LINE::nlinecolor() const {
  // @@protoc_insertion_point(field_get:atd.drivers.MOBILEYE_LANE_LINE.nLineColor)
  return nlinecolor_;
}
inline void MOBILEYE_LANE_LINE::set_nlinecolor(::google::protobuf::int32 value) {
  set_has_nlinecolor();
  nlinecolor_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.MOBILEYE_LANE_LINE.nLineColor)
}

// optional float fTLC = 6;
inline bool MOBILEYE_LANE_LINE::has_ftlc() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MOBILEYE_LANE_LINE::set_has_ftlc() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MOBILEYE_LANE_LINE::clear_has_ftlc() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MOBILEYE_LANE_LINE::clear_ftlc() {
  ftlc_ = 0;
  clear_has_ftlc();
}
inline float MOBILEYE_LANE_LINE::ftlc() const {
  // @@protoc_insertion_point(field_get:atd.drivers.MOBILEYE_LANE_LINE.fTLC)
  return ftlc_;
}
inline void MOBILEYE_LANE_LINE::set_ftlc(float value) {
  set_has_ftlc();
  ftlc_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.MOBILEYE_LANE_LINE.fTLC)
}

// optional float a = 7;
inline bool MOBILEYE_LANE_LINE::has_a() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MOBILEYE_LANE_LINE::set_has_a() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MOBILEYE_LANE_LINE::clear_has_a() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MOBILEYE_LANE_LINE::clear_a() {
  a_ = 0;
  clear_has_a();
}
inline float MOBILEYE_LANE_LINE::a() const {
  // @@protoc_insertion_point(field_get:atd.drivers.MOBILEYE_LANE_LINE.a)
  return a_;
}
inline void MOBILEYE_LANE_LINE::set_a(float value) {
  set_has_a();
  a_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.MOBILEYE_LANE_LINE.a)
}

// optional float b = 8;
inline bool MOBILEYE_LANE_LINE::has_b() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MOBILEYE_LANE_LINE::set_has_b() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MOBILEYE_LANE_LINE::clear_has_b() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MOBILEYE_LANE_LINE::clear_b() {
  b_ = 0;
  clear_has_b();
}
inline float MOBILEYE_LANE_LINE::b() const {
  // @@protoc_insertion_point(field_get:atd.drivers.MOBILEYE_LANE_LINE.b)
  return b_;
}
inline void MOBILEYE_LANE_LINE::set_b(float value) {
  set_has_b();
  b_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.MOBILEYE_LANE_LINE.b)
}

// optional float c = 9;
inline bool MOBILEYE_LANE_LINE::has_c() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MOBILEYE_LANE_LINE::set_has_c() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MOBILEYE_LANE_LINE::clear_has_c() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MOBILEYE_LANE_LINE::clear_c() {
  c_ = 0;
  clear_has_c();
}
inline float MOBILEYE_LANE_LINE::c() const {
  // @@protoc_insertion_point(field_get:atd.drivers.MOBILEYE_LANE_LINE.c)
  return c_;
}
inline void MOBILEYE_LANE_LINE::set_c(float value) {
  set_has_c();
  c_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.MOBILEYE_LANE_LINE.c)
}

// optional float d = 10;
inline bool MOBILEYE_LANE_LINE::has_d() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MOBILEYE_LANE_LINE::set_has_d() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MOBILEYE_LANE_LINE::clear_has_d() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MOBILEYE_LANE_LINE::clear_d() {
  d_ = 0;
  clear_has_d();
}
inline float MOBILEYE_LANE_LINE::d() const {
  // @@protoc_insertion_point(field_get:atd.drivers.MOBILEYE_LANE_LINE.d)
  return d_;
}
inline void MOBILEYE_LANE_LINE::set_d(float value) {
  set_has_d();
  d_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.MOBILEYE_LANE_LINE.d)
}

// optional float x0 = 11;
inline bool MOBILEYE_LANE_LINE::has_x0() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MOBILEYE_LANE_LINE::set_has_x0() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MOBILEYE_LANE_LINE::clear_has_x0() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MOBILEYE_LANE_LINE::clear_x0() {
  x0_ = 0;
  clear_has_x0();
}
inline float MOBILEYE_LANE_LINE::x0() const {
  // @@protoc_insertion_point(field_get:atd.drivers.MOBILEYE_LANE_LINE.x0)
  return x0_;
}
inline void MOBILEYE_LANE_LINE::set_x0(float value) {
  set_has_x0();
  x0_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.MOBILEYE_LANE_LINE.x0)
}

// optional float x1 = 12;
inline bool MOBILEYE_LANE_LINE::has_x1() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MOBILEYE_LANE_LINE::set_has_x1() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MOBILEYE_LANE_LINE::clear_has_x1() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MOBILEYE_LANE_LINE::clear_x1() {
  x1_ = 0;
  clear_has_x1();
}
inline float MOBILEYE_LANE_LINE::x1() const {
  // @@protoc_insertion_point(field_get:atd.drivers.MOBILEYE_LANE_LINE.x1)
  return x1_;
}
inline void MOBILEYE_LANE_LINE::set_x1(float value) {
  set_has_x1();
  x1_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.MOBILEYE_LANE_LINE.x1)
}

// -------------------------------------------------------------------

// MOBI_LANES

// optional .atd.common.Header header = 1;
inline bool MOBI_LANES::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MOBI_LANES::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MOBI_LANES::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MOBI_LANES::clear_header() {
  if (header_ != NULL) header_->::atd::common::Header::Clear();
  clear_has_header();
}
inline const ::atd::common::Header& MOBI_LANES::header() const {
  // @@protoc_insertion_point(field_get:atd.drivers.MOBI_LANES.header)
  return header_ != NULL ? *header_
                         : *::atd::common::Header::internal_default_instance();
}
inline ::atd::common::Header* MOBI_LANES::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::atd::common::Header;
  }
  // @@protoc_insertion_point(field_mutable:atd.drivers.MOBI_LANES.header)
  return header_;
}
inline ::atd::common::Header* MOBI_LANES::release_header() {
  // @@protoc_insertion_point(field_release:atd.drivers.MOBI_LANES.header)
  clear_has_header();
  ::atd::common::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void MOBI_LANES::set_allocated_header(::atd::common::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.drivers.MOBI_LANES.header)
}

// optional int32 nConstructionFlag = 2;
inline bool MOBI_LANES::has_nconstructionflag() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MOBI_LANES::set_has_nconstructionflag() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MOBI_LANES::clear_has_nconstructionflag() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MOBI_LANES::clear_nconstructionflag() {
  nconstructionflag_ = 0;
  clear_has_nconstructionflag();
}
inline ::google::protobuf::int32 MOBI_LANES::nconstructionflag() const {
  // @@protoc_insertion_point(field_get:atd.drivers.MOBI_LANES.nConstructionFlag)
  return nconstructionflag_;
}
inline void MOBI_LANES::set_nconstructionflag(::google::protobuf::int32 value) {
  set_has_nconstructionflag();
  nconstructionflag_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.MOBI_LANES.nConstructionFlag)
}

// optional int32 nRoadType = 3;
inline bool MOBI_LANES::has_nroadtype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MOBI_LANES::set_has_nroadtype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MOBI_LANES::clear_has_nroadtype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MOBI_LANES::clear_nroadtype() {
  nroadtype_ = 0;
  clear_has_nroadtype();
}
inline ::google::protobuf::int32 MOBI_LANES::nroadtype() const {
  // @@protoc_insertion_point(field_get:atd.drivers.MOBI_LANES.nRoadType)
  return nroadtype_;
}
inline void MOBI_LANES::set_nroadtype(::google::protobuf::int32 value) {
  set_has_nroadtype();
  nroadtype_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.MOBI_LANES.nRoadType)
}

// optional int32 bHighwayExitRight = 4;
inline bool MOBI_LANES::has_bhighwayexitright() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MOBI_LANES::set_has_bhighwayexitright() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MOBI_LANES::clear_has_bhighwayexitright() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MOBI_LANES::clear_bhighwayexitright() {
  bhighwayexitright_ = 0;
  clear_has_bhighwayexitright();
}
inline ::google::protobuf::int32 MOBI_LANES::bhighwayexitright() const {
  // @@protoc_insertion_point(field_get:atd.drivers.MOBI_LANES.bHighwayExitRight)
  return bhighwayexitright_;
}
inline void MOBI_LANES::set_bhighwayexitright(::google::protobuf::int32 value) {
  set_has_bhighwayexitright();
  bhighwayexitright_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.MOBI_LANES.bHighwayExitRight)
}

// optional int32 bHighwayExitLeft = 5;
inline bool MOBI_LANES::has_bhighwayexitleft() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MOBI_LANES::set_has_bhighwayexitleft() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MOBI_LANES::clear_has_bhighwayexitleft() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MOBI_LANES::clear_bhighwayexitleft() {
  bhighwayexitleft_ = 0;
  clear_has_bhighwayexitleft();
}
inline ::google::protobuf::int32 MOBI_LANES::bhighwayexitleft() const {
  // @@protoc_insertion_point(field_get:atd.drivers.MOBI_LANES.bHighwayExitLeft)
  return bhighwayexitleft_;
}
inline void MOBI_LANES::set_bhighwayexitleft(::google::protobuf::int32 value) {
  set_has_bhighwayexitleft();
  bhighwayexitleft_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.MOBI_LANES.bHighwayExitLeft)
}

// optional float fLeftLaneDrivingSpeed = 6;
inline bool MOBI_LANES::has_fleftlanedrivingspeed() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MOBI_LANES::set_has_fleftlanedrivingspeed() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MOBI_LANES::clear_has_fleftlanedrivingspeed() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MOBI_LANES::clear_fleftlanedrivingspeed() {
  fleftlanedrivingspeed_ = 0;
  clear_has_fleftlanedrivingspeed();
}
inline float MOBI_LANES::fleftlanedrivingspeed() const {
  // @@protoc_insertion_point(field_get:atd.drivers.MOBI_LANES.fLeftLaneDrivingSpeed)
  return fleftlanedrivingspeed_;
}
inline void MOBI_LANES::set_fleftlanedrivingspeed(float value) {
  set_has_fleftlanedrivingspeed();
  fleftlanedrivingspeed_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.MOBI_LANES.fLeftLaneDrivingSpeed)
}

// optional float fRightLaneDrivingSpeed = 7;
inline bool MOBI_LANES::has_frightlanedrivingspeed() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MOBI_LANES::set_has_frightlanedrivingspeed() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MOBI_LANES::clear_has_frightlanedrivingspeed() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MOBI_LANES::clear_frightlanedrivingspeed() {
  frightlanedrivingspeed_ = 0;
  clear_has_frightlanedrivingspeed();
}
inline float MOBI_LANES::frightlanedrivingspeed() const {
  // @@protoc_insertion_point(field_get:atd.drivers.MOBI_LANES.fRightLaneDrivingSpeed)
  return frightlanedrivingspeed_;
}
inline void MOBI_LANES::set_frightlanedrivingspeed(float value) {
  set_has_frightlanedrivingspeed();
  frightlanedrivingspeed_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.MOBI_LANES.fRightLaneDrivingSpeed)
}

// optional float fLeftLaneProbability = 8;
inline bool MOBI_LANES::has_fleftlaneprobability() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MOBI_LANES::set_has_fleftlaneprobability() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MOBI_LANES::clear_has_fleftlaneprobability() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MOBI_LANES::clear_fleftlaneprobability() {
  fleftlaneprobability_ = 0;
  clear_has_fleftlaneprobability();
}
inline float MOBI_LANES::fleftlaneprobability() const {
  // @@protoc_insertion_point(field_get:atd.drivers.MOBI_LANES.fLeftLaneProbability)
  return fleftlaneprobability_;
}
inline void MOBI_LANES::set_fleftlaneprobability(float value) {
  set_has_fleftlaneprobability();
  fleftlaneprobability_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.MOBI_LANES.fLeftLaneProbability)
}

// optional float fRightLaneProbability = 9;
inline bool MOBI_LANES::has_frightlaneprobability() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MOBI_LANES::set_has_frightlaneprobability() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MOBI_LANES::clear_has_frightlaneprobability() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MOBI_LANES::clear_frightlaneprobability() {
  frightlaneprobability_ = 0;
  clear_has_frightlaneprobability();
}
inline float MOBI_LANES::frightlaneprobability() const {
  // @@protoc_insertion_point(field_get:atd.drivers.MOBI_LANES.fRightLaneProbability)
  return frightlaneprobability_;
}
inline void MOBI_LANES::set_frightlaneprobability(float value) {
  set_has_frightlaneprobability();
  frightlaneprobability_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.MOBI_LANES.fRightLaneProbability)
}

// optional .atd.drivers.MOBILEYE_LANE_LINE stLeftLine = 10;
inline bool MOBI_LANES::has_stleftline() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MOBI_LANES::set_has_stleftline() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MOBI_LANES::clear_has_stleftline() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MOBI_LANES::clear_stleftline() {
  if (stleftline_ != NULL) stleftline_->::atd::drivers::MOBILEYE_LANE_LINE::Clear();
  clear_has_stleftline();
}
inline const ::atd::drivers::MOBILEYE_LANE_LINE& MOBI_LANES::stleftline() const {
  // @@protoc_insertion_point(field_get:atd.drivers.MOBI_LANES.stLeftLine)
  return stleftline_ != NULL ? *stleftline_
                         : *::atd::drivers::MOBILEYE_LANE_LINE::internal_default_instance();
}
inline ::atd::drivers::MOBILEYE_LANE_LINE* MOBI_LANES::mutable_stleftline() {
  set_has_stleftline();
  if (stleftline_ == NULL) {
    stleftline_ = new ::atd::drivers::MOBILEYE_LANE_LINE;
  }
  // @@protoc_insertion_point(field_mutable:atd.drivers.MOBI_LANES.stLeftLine)
  return stleftline_;
}
inline ::atd::drivers::MOBILEYE_LANE_LINE* MOBI_LANES::release_stleftline() {
  // @@protoc_insertion_point(field_release:atd.drivers.MOBI_LANES.stLeftLine)
  clear_has_stleftline();
  ::atd::drivers::MOBILEYE_LANE_LINE* temp = stleftline_;
  stleftline_ = NULL;
  return temp;
}
inline void MOBI_LANES::set_allocated_stleftline(::atd::drivers::MOBILEYE_LANE_LINE* stleftline) {
  delete stleftline_;
  stleftline_ = stleftline;
  if (stleftline) {
    set_has_stleftline();
  } else {
    clear_has_stleftline();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.drivers.MOBI_LANES.stLeftLine)
}

// optional .atd.drivers.MOBILEYE_LANE_LINE stRightLine = 11;
inline bool MOBI_LANES::has_strightline() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MOBI_LANES::set_has_strightline() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MOBI_LANES::clear_has_strightline() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MOBI_LANES::clear_strightline() {
  if (strightline_ != NULL) strightline_->::atd::drivers::MOBILEYE_LANE_LINE::Clear();
  clear_has_strightline();
}
inline const ::atd::drivers::MOBILEYE_LANE_LINE& MOBI_LANES::strightline() const {
  // @@protoc_insertion_point(field_get:atd.drivers.MOBI_LANES.stRightLine)
  return strightline_ != NULL ? *strightline_
                         : *::atd::drivers::MOBILEYE_LANE_LINE::internal_default_instance();
}
inline ::atd::drivers::MOBILEYE_LANE_LINE* MOBI_LANES::mutable_strightline() {
  set_has_strightline();
  if (strightline_ == NULL) {
    strightline_ = new ::atd::drivers::MOBILEYE_LANE_LINE;
  }
  // @@protoc_insertion_point(field_mutable:atd.drivers.MOBI_LANES.stRightLine)
  return strightline_;
}
inline ::atd::drivers::MOBILEYE_LANE_LINE* MOBI_LANES::release_strightline() {
  // @@protoc_insertion_point(field_release:atd.drivers.MOBI_LANES.stRightLine)
  clear_has_strightline();
  ::atd::drivers::MOBILEYE_LANE_LINE* temp = strightline_;
  strightline_ = NULL;
  return temp;
}
inline void MOBI_LANES::set_allocated_strightline(::atd::drivers::MOBILEYE_LANE_LINE* strightline) {
  delete strightline_;
  strightline_ = strightline;
  if (strightline) {
    set_has_strightline();
  } else {
    clear_has_strightline();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.drivers.MOBI_LANES.stRightLine)
}

// optional .atd.drivers.MOBILEYE_LANE_LINE stNextLeftLine = 12;
inline bool MOBI_LANES::has_stnextleftline() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MOBI_LANES::set_has_stnextleftline() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MOBI_LANES::clear_has_stnextleftline() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MOBI_LANES::clear_stnextleftline() {
  if (stnextleftline_ != NULL) stnextleftline_->::atd::drivers::MOBILEYE_LANE_LINE::Clear();
  clear_has_stnextleftline();
}
inline const ::atd::drivers::MOBILEYE_LANE_LINE& MOBI_LANES::stnextleftline() const {
  // @@protoc_insertion_point(field_get:atd.drivers.MOBI_LANES.stNextLeftLine)
  return stnextleftline_ != NULL ? *stnextleftline_
                         : *::atd::drivers::MOBILEYE_LANE_LINE::internal_default_instance();
}
inline ::atd::drivers::MOBILEYE_LANE_LINE* MOBI_LANES::mutable_stnextleftline() {
  set_has_stnextleftline();
  if (stnextleftline_ == NULL) {
    stnextleftline_ = new ::atd::drivers::MOBILEYE_LANE_LINE;
  }
  // @@protoc_insertion_point(field_mutable:atd.drivers.MOBI_LANES.stNextLeftLine)
  return stnextleftline_;
}
inline ::atd::drivers::MOBILEYE_LANE_LINE* MOBI_LANES::release_stnextleftline() {
  // @@protoc_insertion_point(field_release:atd.drivers.MOBI_LANES.stNextLeftLine)
  clear_has_stnextleftline();
  ::atd::drivers::MOBILEYE_LANE_LINE* temp = stnextleftline_;
  stnextleftline_ = NULL;
  return temp;
}
inline void MOBI_LANES::set_allocated_stnextleftline(::atd::drivers::MOBILEYE_LANE_LINE* stnextleftline) {
  delete stnextleftline_;
  stnextleftline_ = stnextleftline;
  if (stnextleftline) {
    set_has_stnextleftline();
  } else {
    clear_has_stnextleftline();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.drivers.MOBI_LANES.stNextLeftLine)
}

// optional .atd.drivers.MOBILEYE_LANE_LINE stNextRightLine = 13;
inline bool MOBI_LANES::has_stnextrightline() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MOBI_LANES::set_has_stnextrightline() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MOBI_LANES::clear_has_stnextrightline() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MOBI_LANES::clear_stnextrightline() {
  if (stnextrightline_ != NULL) stnextrightline_->::atd::drivers::MOBILEYE_LANE_LINE::Clear();
  clear_has_stnextrightline();
}
inline const ::atd::drivers::MOBILEYE_LANE_LINE& MOBI_LANES::stnextrightline() const {
  // @@protoc_insertion_point(field_get:atd.drivers.MOBI_LANES.stNextRightLine)
  return stnextrightline_ != NULL ? *stnextrightline_
                         : *::atd::drivers::MOBILEYE_LANE_LINE::internal_default_instance();
}
inline ::atd::drivers::MOBILEYE_LANE_LINE* MOBI_LANES::mutable_stnextrightline() {
  set_has_stnextrightline();
  if (stnextrightline_ == NULL) {
    stnextrightline_ = new ::atd::drivers::MOBILEYE_LANE_LINE;
  }
  // @@protoc_insertion_point(field_mutable:atd.drivers.MOBI_LANES.stNextRightLine)
  return stnextrightline_;
}
inline ::atd::drivers::MOBILEYE_LANE_LINE* MOBI_LANES::release_stnextrightline() {
  // @@protoc_insertion_point(field_release:atd.drivers.MOBI_LANES.stNextRightLine)
  clear_has_stnextrightline();
  ::atd::drivers::MOBILEYE_LANE_LINE* temp = stnextrightline_;
  stnextrightline_ = NULL;
  return temp;
}
inline void MOBI_LANES::set_allocated_stnextrightline(::atd::drivers::MOBILEYE_LANE_LINE* stnextrightline) {
  delete stnextrightline_;
  stnextrightline_ = stnextrightline;
  if (stnextrightline) {
    set_has_stnextrightline();
  } else {
    clear_has_stnextrightline();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.drivers.MOBI_LANES.stNextRightLine)
}

// optional .atd.common.Reserved reservedmsg = 14;
inline bool MOBI_LANES::has_reservedmsg() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MOBI_LANES::set_has_reservedmsg() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MOBI_LANES::clear_has_reservedmsg() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MOBI_LANES::clear_reservedmsg() {
  if (reservedmsg_ != NULL) reservedmsg_->::atd::common::Reserved::Clear();
  clear_has_reservedmsg();
}
inline const ::atd::common::Reserved& MOBI_LANES::reservedmsg() const {
  // @@protoc_insertion_point(field_get:atd.drivers.MOBI_LANES.reservedmsg)
  return reservedmsg_ != NULL ? *reservedmsg_
                         : *::atd::common::Reserved::internal_default_instance();
}
inline ::atd::common::Reserved* MOBI_LANES::mutable_reservedmsg() {
  set_has_reservedmsg();
  if (reservedmsg_ == NULL) {
    reservedmsg_ = new ::atd::common::Reserved;
  }
  // @@protoc_insertion_point(field_mutable:atd.drivers.MOBI_LANES.reservedmsg)
  return reservedmsg_;
}
inline ::atd::common::Reserved* MOBI_LANES::release_reservedmsg() {
  // @@protoc_insertion_point(field_release:atd.drivers.MOBI_LANES.reservedmsg)
  clear_has_reservedmsg();
  ::atd::common::Reserved* temp = reservedmsg_;
  reservedmsg_ = NULL;
  return temp;
}
inline void MOBI_LANES::set_allocated_reservedmsg(::atd::common::Reserved* reservedmsg) {
  delete reservedmsg_;
  reservedmsg_ = reservedmsg;
  if (reservedmsg) {
    set_has_reservedmsg();
  } else {
    clear_has_reservedmsg();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.drivers.MOBI_LANES.reservedmsg)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace drivers
}  // namespace atd

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_modules_2fipc_2fmessage_2fprotobuf_2fdrivers_2fmobileye_2eproto__INCLUDED
