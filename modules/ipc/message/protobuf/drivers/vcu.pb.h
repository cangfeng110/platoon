// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/ipc/message/protobuf/drivers/vcu.proto

#ifndef PROTOBUF_modules_2fipc_2fmessage_2fprotobuf_2fdrivers_2fvcu_2eproto__INCLUDED
#define PROTOBUF_modules_2fipc_2fmessage_2fprotobuf_2fdrivers_2fvcu_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include "modules/ipc/message/protobuf/common/header.pb.h"
#include "modules/ipc/message/protobuf/common/reserved.pb.h"
// @@protoc_insertion_point(includes)
namespace atd {
namespace common {
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Reserved;
class ReservedDefaultTypeInternal;
extern ReservedDefaultTypeInternal _Reserved_default_instance_;
}  // namespace common
namespace drivers {
class Vcu;
class VcuDefaultTypeInternal;
extern VcuDefaultTypeInternal _Vcu_default_instance_;
}  // namespace drivers
}  // namespace atd

namespace atd {
namespace drivers {

namespace protobuf_modules_2fipc_2fmessage_2fprotobuf_2fdrivers_2fvcu_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_modules_2fipc_2fmessage_2fprotobuf_2fdrivers_2fvcu_2eproto

// ===================================================================

class Vcu : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.drivers.Vcu) */ {
 public:
  Vcu();
  virtual ~Vcu();

  Vcu(const Vcu& from);

  inline Vcu& operator=(const Vcu& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Vcu& default_instance();

  static inline const Vcu* internal_default_instance() {
    return reinterpret_cast<const Vcu*>(
               &_Vcu_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Vcu* other);

  // implements Message ----------------------------------------------

  inline Vcu* New() const PROTOBUF_FINAL { return New(NULL); }

  Vcu* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Vcu& from);
  void MergeFrom(const Vcu& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Vcu* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .atd.common.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::atd::common::Header& header() const;
  ::atd::common::Header* mutable_header();
  ::atd::common::Header* release_header();
  void set_allocated_header(::atd::common::Header* header);

  // optional .atd.common.Reserved reservedmsg = 2;
  bool has_reservedmsg() const;
  void clear_reservedmsg();
  static const int kReservedmsgFieldNumber = 2;
  const ::atd::common::Reserved& reservedmsg() const;
  ::atd::common::Reserved* mutable_reservedmsg();
  ::atd::common::Reserved* release_reservedmsg();
  void set_allocated_reservedmsg(::atd::common::Reserved* reservedmsg);

  // optional float fSteeringAngle = 3;
  bool has_fsteeringangle() const;
  void clear_fsteeringangle();
  static const int kFSteeringAngleFieldNumber = 3;
  float fsteeringangle() const;
  void set_fsteeringangle(float value);

  // optional float fSpeed = 4;
  bool has_fspeed() const;
  void clear_fspeed();
  static const int kFSpeedFieldNumber = 4;
  float fspeed() const;
  void set_fspeed(float value);

  // optional float fYawRate = 5;
  bool has_fyawrate() const;
  void clear_fyawrate();
  static const int kFYawRateFieldNumber = 5;
  float fyawrate() const;
  void set_fyawrate(float value);

  // optional float fFrontLeftWheelSpeed = 6;
  bool has_ffrontleftwheelspeed() const;
  void clear_ffrontleftwheelspeed();
  static const int kFFrontLeftWheelSpeedFieldNumber = 6;
  float ffrontleftwheelspeed() const;
  void set_ffrontleftwheelspeed(float value);

  // optional float fFrontRightWheelSpeed = 7;
  bool has_ffrontrightwheelspeed() const;
  void clear_ffrontrightwheelspeed();
  static const int kFFrontRightWheelSpeedFieldNumber = 7;
  float ffrontrightwheelspeed() const;
  void set_ffrontrightwheelspeed(float value);

  // optional float fRearLeftWheelSpeed = 8;
  bool has_frearleftwheelspeed() const;
  void clear_frearleftwheelspeed();
  static const int kFRearLeftWheelSpeedFieldNumber = 8;
  float frearleftwheelspeed() const;
  void set_frearleftwheelspeed(float value);

  // optional float fRearRightWheelSpeed = 9;
  bool has_frearrightwheelspeed() const;
  void clear_frearrightwheelspeed();
  static const int kFRearRightWheelSpeedFieldNumber = 9;
  float frearrightwheelspeed() const;
  void set_frearrightwheelspeed(float value);

  // optional int32 nShifterPosition = 10;
  bool has_nshifterposition() const;
  void clear_nshifterposition();
  static const int kNShifterPositionFieldNumber = 10;
  ::google::protobuf::int32 nshifterposition() const;
  void set_nshifterposition(::google::protobuf::int32 value);

  // optional int32 nLeftDirectionLamp = 11;
  bool has_nleftdirectionlamp() const;
  void clear_nleftdirectionlamp();
  static const int kNLeftDirectionLampFieldNumber = 11;
  ::google::protobuf::int32 nleftdirectionlamp() const;
  void set_nleftdirectionlamp(::google::protobuf::int32 value);

  // optional int32 nRightDirectionLamp = 12;
  bool has_nrightdirectionlamp() const;
  void clear_nrightdirectionlamp();
  static const int kNRightDirectionLampFieldNumber = 12;
  ::google::protobuf::int32 nrightdirectionlamp() const;
  void set_nrightdirectionlamp(::google::protobuf::int32 value);

  // optional int32 nMainBeamLamp = 13;
  bool has_nmainbeamlamp() const;
  void clear_nmainbeamlamp();
  static const int kNMainBeamLampFieldNumber = 13;
  ::google::protobuf::int32 nmainbeamlamp() const;
  void set_nmainbeamlamp(::google::protobuf::int32 value);

  // optional int32 nDippedBeamLamp = 14;
  bool has_ndippedbeamlamp() const;
  void clear_ndippedbeamlamp();
  static const int kNDippedBeamLampFieldNumber = 14;
  ::google::protobuf::int32 ndippedbeamlamp() const;
  void set_ndippedbeamlamp(::google::protobuf::int32 value);

  // optional int32 nWiperState = 15;
  bool has_nwiperstate() const;
  void clear_nwiperstate();
  static const int kNWiperStateFieldNumber = 15;
  ::google::protobuf::int32 nwiperstate() const;
  void set_nwiperstate(::google::protobuf::int32 value);

  // optional float fLateralAccel = 16;
  bool has_flateralaccel() const;
  void clear_flateralaccel();
  static const int kFLateralAccelFieldNumber = 16;
  float flateralaccel() const;
  void set_flateralaccel(float value);

  // optional float fLongituAccel = 17;
  bool has_flongituaccel() const;
  void clear_flongituaccel();
  static const int kFLongituAccelFieldNumber = 17;
  float flongituaccel() const;
  void set_flongituaccel(float value);

  // optional int32 nLeftDrivenWheelPulseCounters = 18;
  bool has_nleftdrivenwheelpulsecounters() const;
  void clear_nleftdrivenwheelpulsecounters();
  static const int kNLeftDrivenWheelPulseCountersFieldNumber = 18;
  ::google::protobuf::int32 nleftdrivenwheelpulsecounters() const;
  void set_nleftdrivenwheelpulsecounters(::google::protobuf::int32 value);

  // optional int32 nRightDrivenWheelPulseCounters = 19;
  bool has_nrightdrivenwheelpulsecounters() const;
  void clear_nrightdrivenwheelpulsecounters();
  static const int kNRightDrivenWheelPulseCountersFieldNumber = 19;
  ::google::protobuf::int32 nrightdrivenwheelpulsecounters() const;
  void set_nrightdrivenwheelpulsecounters(::google::protobuf::int32 value);

  // optional int32 nLeftNonDrivenWheelPulseCounters = 20;
  bool has_nleftnondrivenwheelpulsecounters() const;
  void clear_nleftnondrivenwheelpulsecounters();
  static const int kNLeftNonDrivenWheelPulseCountersFieldNumber = 20;
  ::google::protobuf::int32 nleftnondrivenwheelpulsecounters() const;
  void set_nleftnondrivenwheelpulsecounters(::google::protobuf::int32 value);

  // optional int32 nRightNonDrivenWheelPulseCounters = 21;
  bool has_nrightnondrivenwheelpulsecounters() const;
  void clear_nrightnondrivenwheelpulsecounters();
  static const int kNRightNonDrivenWheelPulseCountersFieldNumber = 21;
  ::google::protobuf::int32 nrightnondrivenwheelpulsecounters() const;
  void set_nrightnondrivenwheelpulsecounters(::google::protobuf::int32 value);

  // optional int32 nDriveMode = 22;
  bool has_ndrivemode() const;
  void clear_ndrivemode();
  static const int kNDriveModeFieldNumber = 22;
  ::google::protobuf::int32 ndrivemode() const;
  void set_ndrivemode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:atd.drivers.Vcu)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_reservedmsg();
  void clear_has_reservedmsg();
  void set_has_fsteeringangle();
  void clear_has_fsteeringangle();
  void set_has_fspeed();
  void clear_has_fspeed();
  void set_has_fyawrate();
  void clear_has_fyawrate();
  void set_has_ffrontleftwheelspeed();
  void clear_has_ffrontleftwheelspeed();
  void set_has_ffrontrightwheelspeed();
  void clear_has_ffrontrightwheelspeed();
  void set_has_frearleftwheelspeed();
  void clear_has_frearleftwheelspeed();
  void set_has_frearrightwheelspeed();
  void clear_has_frearrightwheelspeed();
  void set_has_nshifterposition();
  void clear_has_nshifterposition();
  void set_has_nleftdirectionlamp();
  void clear_has_nleftdirectionlamp();
  void set_has_nrightdirectionlamp();
  void clear_has_nrightdirectionlamp();
  void set_has_nmainbeamlamp();
  void clear_has_nmainbeamlamp();
  void set_has_ndippedbeamlamp();
  void clear_has_ndippedbeamlamp();
  void set_has_nwiperstate();
  void clear_has_nwiperstate();
  void set_has_flateralaccel();
  void clear_has_flateralaccel();
  void set_has_flongituaccel();
  void clear_has_flongituaccel();
  void set_has_nleftdrivenwheelpulsecounters();
  void clear_has_nleftdrivenwheelpulsecounters();
  void set_has_nrightdrivenwheelpulsecounters();
  void clear_has_nrightdrivenwheelpulsecounters();
  void set_has_nleftnondrivenwheelpulsecounters();
  void clear_has_nleftnondrivenwheelpulsecounters();
  void set_has_nrightnondrivenwheelpulsecounters();
  void clear_has_nrightnondrivenwheelpulsecounters();
  void set_has_ndrivemode();
  void clear_has_ndrivemode();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::atd::common::Header* header_;
  ::atd::common::Reserved* reservedmsg_;
  float fsteeringangle_;
  float fspeed_;
  float fyawrate_;
  float ffrontleftwheelspeed_;
  float ffrontrightwheelspeed_;
  float frearleftwheelspeed_;
  float frearrightwheelspeed_;
  ::google::protobuf::int32 nshifterposition_;
  ::google::protobuf::int32 nleftdirectionlamp_;
  ::google::protobuf::int32 nrightdirectionlamp_;
  ::google::protobuf::int32 nmainbeamlamp_;
  ::google::protobuf::int32 ndippedbeamlamp_;
  ::google::protobuf::int32 nwiperstate_;
  float flateralaccel_;
  float flongituaccel_;
  ::google::protobuf::int32 nleftdrivenwheelpulsecounters_;
  ::google::protobuf::int32 nrightdrivenwheelpulsecounters_;
  ::google::protobuf::int32 nleftnondrivenwheelpulsecounters_;
  ::google::protobuf::int32 nrightnondrivenwheelpulsecounters_;
  ::google::protobuf::int32 ndrivemode_;
  friend struct protobuf_modules_2fipc_2fmessage_2fprotobuf_2fdrivers_2fvcu_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Vcu

// optional .atd.common.Header header = 1;
inline bool Vcu::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vcu::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vcu::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vcu::clear_header() {
  if (header_ != NULL) header_->::atd::common::Header::Clear();
  clear_has_header();
}
inline const ::atd::common::Header& Vcu::header() const {
  // @@protoc_insertion_point(field_get:atd.drivers.Vcu.header)
  return header_ != NULL ? *header_
                         : *::atd::common::Header::internal_default_instance();
}
inline ::atd::common::Header* Vcu::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::atd::common::Header;
  }
  // @@protoc_insertion_point(field_mutable:atd.drivers.Vcu.header)
  return header_;
}
inline ::atd::common::Header* Vcu::release_header() {
  // @@protoc_insertion_point(field_release:atd.drivers.Vcu.header)
  clear_has_header();
  ::atd::common::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void Vcu::set_allocated_header(::atd::common::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.drivers.Vcu.header)
}

// optional .atd.common.Reserved reservedmsg = 2;
inline bool Vcu::has_reservedmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vcu::set_has_reservedmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vcu::clear_has_reservedmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vcu::clear_reservedmsg() {
  if (reservedmsg_ != NULL) reservedmsg_->::atd::common::Reserved::Clear();
  clear_has_reservedmsg();
}
inline const ::atd::common::Reserved& Vcu::reservedmsg() const {
  // @@protoc_insertion_point(field_get:atd.drivers.Vcu.reservedmsg)
  return reservedmsg_ != NULL ? *reservedmsg_
                         : *::atd::common::Reserved::internal_default_instance();
}
inline ::atd::common::Reserved* Vcu::mutable_reservedmsg() {
  set_has_reservedmsg();
  if (reservedmsg_ == NULL) {
    reservedmsg_ = new ::atd::common::Reserved;
  }
  // @@protoc_insertion_point(field_mutable:atd.drivers.Vcu.reservedmsg)
  return reservedmsg_;
}
inline ::atd::common::Reserved* Vcu::release_reservedmsg() {
  // @@protoc_insertion_point(field_release:atd.drivers.Vcu.reservedmsg)
  clear_has_reservedmsg();
  ::atd::common::Reserved* temp = reservedmsg_;
  reservedmsg_ = NULL;
  return temp;
}
inline void Vcu::set_allocated_reservedmsg(::atd::common::Reserved* reservedmsg) {
  delete reservedmsg_;
  reservedmsg_ = reservedmsg;
  if (reservedmsg) {
    set_has_reservedmsg();
  } else {
    clear_has_reservedmsg();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.drivers.Vcu.reservedmsg)
}

// optional float fSteeringAngle = 3;
inline bool Vcu::has_fsteeringangle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vcu::set_has_fsteeringangle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vcu::clear_has_fsteeringangle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vcu::clear_fsteeringangle() {
  fsteeringangle_ = 0;
  clear_has_fsteeringangle();
}
inline float Vcu::fsteeringangle() const {
  // @@protoc_insertion_point(field_get:atd.drivers.Vcu.fSteeringAngle)
  return fsteeringangle_;
}
inline void Vcu::set_fsteeringangle(float value) {
  set_has_fsteeringangle();
  fsteeringangle_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.Vcu.fSteeringAngle)
}

// optional float fSpeed = 4;
inline bool Vcu::has_fspeed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Vcu::set_has_fspeed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Vcu::clear_has_fspeed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Vcu::clear_fspeed() {
  fspeed_ = 0;
  clear_has_fspeed();
}
inline float Vcu::fspeed() const {
  // @@protoc_insertion_point(field_get:atd.drivers.Vcu.fSpeed)
  return fspeed_;
}
inline void Vcu::set_fspeed(float value) {
  set_has_fspeed();
  fspeed_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.Vcu.fSpeed)
}

// optional float fYawRate = 5;
inline bool Vcu::has_fyawrate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Vcu::set_has_fyawrate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Vcu::clear_has_fyawrate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Vcu::clear_fyawrate() {
  fyawrate_ = 0;
  clear_has_fyawrate();
}
inline float Vcu::fyawrate() const {
  // @@protoc_insertion_point(field_get:atd.drivers.Vcu.fYawRate)
  return fyawrate_;
}
inline void Vcu::set_fyawrate(float value) {
  set_has_fyawrate();
  fyawrate_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.Vcu.fYawRate)
}

// optional float fFrontLeftWheelSpeed = 6;
inline bool Vcu::has_ffrontleftwheelspeed() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Vcu::set_has_ffrontleftwheelspeed() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Vcu::clear_has_ffrontleftwheelspeed() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Vcu::clear_ffrontleftwheelspeed() {
  ffrontleftwheelspeed_ = 0;
  clear_has_ffrontleftwheelspeed();
}
inline float Vcu::ffrontleftwheelspeed() const {
  // @@protoc_insertion_point(field_get:atd.drivers.Vcu.fFrontLeftWheelSpeed)
  return ffrontleftwheelspeed_;
}
inline void Vcu::set_ffrontleftwheelspeed(float value) {
  set_has_ffrontleftwheelspeed();
  ffrontleftwheelspeed_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.Vcu.fFrontLeftWheelSpeed)
}

// optional float fFrontRightWheelSpeed = 7;
inline bool Vcu::has_ffrontrightwheelspeed() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Vcu::set_has_ffrontrightwheelspeed() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Vcu::clear_has_ffrontrightwheelspeed() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Vcu::clear_ffrontrightwheelspeed() {
  ffrontrightwheelspeed_ = 0;
  clear_has_ffrontrightwheelspeed();
}
inline float Vcu::ffrontrightwheelspeed() const {
  // @@protoc_insertion_point(field_get:atd.drivers.Vcu.fFrontRightWheelSpeed)
  return ffrontrightwheelspeed_;
}
inline void Vcu::set_ffrontrightwheelspeed(float value) {
  set_has_ffrontrightwheelspeed();
  ffrontrightwheelspeed_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.Vcu.fFrontRightWheelSpeed)
}

// optional float fRearLeftWheelSpeed = 8;
inline bool Vcu::has_frearleftwheelspeed() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Vcu::set_has_frearleftwheelspeed() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Vcu::clear_has_frearleftwheelspeed() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Vcu::clear_frearleftwheelspeed() {
  frearleftwheelspeed_ = 0;
  clear_has_frearleftwheelspeed();
}
inline float Vcu::frearleftwheelspeed() const {
  // @@protoc_insertion_point(field_get:atd.drivers.Vcu.fRearLeftWheelSpeed)
  return frearleftwheelspeed_;
}
inline void Vcu::set_frearleftwheelspeed(float value) {
  set_has_frearleftwheelspeed();
  frearleftwheelspeed_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.Vcu.fRearLeftWheelSpeed)
}

// optional float fRearRightWheelSpeed = 9;
inline bool Vcu::has_frearrightwheelspeed() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Vcu::set_has_frearrightwheelspeed() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Vcu::clear_has_frearrightwheelspeed() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Vcu::clear_frearrightwheelspeed() {
  frearrightwheelspeed_ = 0;
  clear_has_frearrightwheelspeed();
}
inline float Vcu::frearrightwheelspeed() const {
  // @@protoc_insertion_point(field_get:atd.drivers.Vcu.fRearRightWheelSpeed)
  return frearrightwheelspeed_;
}
inline void Vcu::set_frearrightwheelspeed(float value) {
  set_has_frearrightwheelspeed();
  frearrightwheelspeed_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.Vcu.fRearRightWheelSpeed)
}

// optional int32 nShifterPosition = 10;
inline bool Vcu::has_nshifterposition() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Vcu::set_has_nshifterposition() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Vcu::clear_has_nshifterposition() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Vcu::clear_nshifterposition() {
  nshifterposition_ = 0;
  clear_has_nshifterposition();
}
inline ::google::protobuf::int32 Vcu::nshifterposition() const {
  // @@protoc_insertion_point(field_get:atd.drivers.Vcu.nShifterPosition)
  return nshifterposition_;
}
inline void Vcu::set_nshifterposition(::google::protobuf::int32 value) {
  set_has_nshifterposition();
  nshifterposition_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.Vcu.nShifterPosition)
}

// optional int32 nLeftDirectionLamp = 11;
inline bool Vcu::has_nleftdirectionlamp() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Vcu::set_has_nleftdirectionlamp() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Vcu::clear_has_nleftdirectionlamp() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Vcu::clear_nleftdirectionlamp() {
  nleftdirectionlamp_ = 0;
  clear_has_nleftdirectionlamp();
}
inline ::google::protobuf::int32 Vcu::nleftdirectionlamp() const {
  // @@protoc_insertion_point(field_get:atd.drivers.Vcu.nLeftDirectionLamp)
  return nleftdirectionlamp_;
}
inline void Vcu::set_nleftdirectionlamp(::google::protobuf::int32 value) {
  set_has_nleftdirectionlamp();
  nleftdirectionlamp_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.Vcu.nLeftDirectionLamp)
}

// optional int32 nRightDirectionLamp = 12;
inline bool Vcu::has_nrightdirectionlamp() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Vcu::set_has_nrightdirectionlamp() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Vcu::clear_has_nrightdirectionlamp() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Vcu::clear_nrightdirectionlamp() {
  nrightdirectionlamp_ = 0;
  clear_has_nrightdirectionlamp();
}
inline ::google::protobuf::int32 Vcu::nrightdirectionlamp() const {
  // @@protoc_insertion_point(field_get:atd.drivers.Vcu.nRightDirectionLamp)
  return nrightdirectionlamp_;
}
inline void Vcu::set_nrightdirectionlamp(::google::protobuf::int32 value) {
  set_has_nrightdirectionlamp();
  nrightdirectionlamp_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.Vcu.nRightDirectionLamp)
}

// optional int32 nMainBeamLamp = 13;
inline bool Vcu::has_nmainbeamlamp() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Vcu::set_has_nmainbeamlamp() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Vcu::clear_has_nmainbeamlamp() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Vcu::clear_nmainbeamlamp() {
  nmainbeamlamp_ = 0;
  clear_has_nmainbeamlamp();
}
inline ::google::protobuf::int32 Vcu::nmainbeamlamp() const {
  // @@protoc_insertion_point(field_get:atd.drivers.Vcu.nMainBeamLamp)
  return nmainbeamlamp_;
}
inline void Vcu::set_nmainbeamlamp(::google::protobuf::int32 value) {
  set_has_nmainbeamlamp();
  nmainbeamlamp_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.Vcu.nMainBeamLamp)
}

// optional int32 nDippedBeamLamp = 14;
inline bool Vcu::has_ndippedbeamlamp() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Vcu::set_has_ndippedbeamlamp() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Vcu::clear_has_ndippedbeamlamp() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Vcu::clear_ndippedbeamlamp() {
  ndippedbeamlamp_ = 0;
  clear_has_ndippedbeamlamp();
}
inline ::google::protobuf::int32 Vcu::ndippedbeamlamp() const {
  // @@protoc_insertion_point(field_get:atd.drivers.Vcu.nDippedBeamLamp)
  return ndippedbeamlamp_;
}
inline void Vcu::set_ndippedbeamlamp(::google::protobuf::int32 value) {
  set_has_ndippedbeamlamp();
  ndippedbeamlamp_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.Vcu.nDippedBeamLamp)
}

// optional int32 nWiperState = 15;
inline bool Vcu::has_nwiperstate() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Vcu::set_has_nwiperstate() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Vcu::clear_has_nwiperstate() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Vcu::clear_nwiperstate() {
  nwiperstate_ = 0;
  clear_has_nwiperstate();
}
inline ::google::protobuf::int32 Vcu::nwiperstate() const {
  // @@protoc_insertion_point(field_get:atd.drivers.Vcu.nWiperState)
  return nwiperstate_;
}
inline void Vcu::set_nwiperstate(::google::protobuf::int32 value) {
  set_has_nwiperstate();
  nwiperstate_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.Vcu.nWiperState)
}

// optional float fLateralAccel = 16;
inline bool Vcu::has_flateralaccel() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Vcu::set_has_flateralaccel() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Vcu::clear_has_flateralaccel() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Vcu::clear_flateralaccel() {
  flateralaccel_ = 0;
  clear_has_flateralaccel();
}
inline float Vcu::flateralaccel() const {
  // @@protoc_insertion_point(field_get:atd.drivers.Vcu.fLateralAccel)
  return flateralaccel_;
}
inline void Vcu::set_flateralaccel(float value) {
  set_has_flateralaccel();
  flateralaccel_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.Vcu.fLateralAccel)
}

// optional float fLongituAccel = 17;
inline bool Vcu::has_flongituaccel() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Vcu::set_has_flongituaccel() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Vcu::clear_has_flongituaccel() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Vcu::clear_flongituaccel() {
  flongituaccel_ = 0;
  clear_has_flongituaccel();
}
inline float Vcu::flongituaccel() const {
  // @@protoc_insertion_point(field_get:atd.drivers.Vcu.fLongituAccel)
  return flongituaccel_;
}
inline void Vcu::set_flongituaccel(float value) {
  set_has_flongituaccel();
  flongituaccel_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.Vcu.fLongituAccel)
}

// optional int32 nLeftDrivenWheelPulseCounters = 18;
inline bool Vcu::has_nleftdrivenwheelpulsecounters() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Vcu::set_has_nleftdrivenwheelpulsecounters() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Vcu::clear_has_nleftdrivenwheelpulsecounters() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Vcu::clear_nleftdrivenwheelpulsecounters() {
  nleftdrivenwheelpulsecounters_ = 0;
  clear_has_nleftdrivenwheelpulsecounters();
}
inline ::google::protobuf::int32 Vcu::nleftdrivenwheelpulsecounters() const {
  // @@protoc_insertion_point(field_get:atd.drivers.Vcu.nLeftDrivenWheelPulseCounters)
  return nleftdrivenwheelpulsecounters_;
}
inline void Vcu::set_nleftdrivenwheelpulsecounters(::google::protobuf::int32 value) {
  set_has_nleftdrivenwheelpulsecounters();
  nleftdrivenwheelpulsecounters_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.Vcu.nLeftDrivenWheelPulseCounters)
}

// optional int32 nRightDrivenWheelPulseCounters = 19;
inline bool Vcu::has_nrightdrivenwheelpulsecounters() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Vcu::set_has_nrightdrivenwheelpulsecounters() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Vcu::clear_has_nrightdrivenwheelpulsecounters() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Vcu::clear_nrightdrivenwheelpulsecounters() {
  nrightdrivenwheelpulsecounters_ = 0;
  clear_has_nrightdrivenwheelpulsecounters();
}
inline ::google::protobuf::int32 Vcu::nrightdrivenwheelpulsecounters() const {
  // @@protoc_insertion_point(field_get:atd.drivers.Vcu.nRightDrivenWheelPulseCounters)
  return nrightdrivenwheelpulsecounters_;
}
inline void Vcu::set_nrightdrivenwheelpulsecounters(::google::protobuf::int32 value) {
  set_has_nrightdrivenwheelpulsecounters();
  nrightdrivenwheelpulsecounters_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.Vcu.nRightDrivenWheelPulseCounters)
}

// optional int32 nLeftNonDrivenWheelPulseCounters = 20;
inline bool Vcu::has_nleftnondrivenwheelpulsecounters() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Vcu::set_has_nleftnondrivenwheelpulsecounters() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Vcu::clear_has_nleftnondrivenwheelpulsecounters() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Vcu::clear_nleftnondrivenwheelpulsecounters() {
  nleftnondrivenwheelpulsecounters_ = 0;
  clear_has_nleftnondrivenwheelpulsecounters();
}
inline ::google::protobuf::int32 Vcu::nleftnondrivenwheelpulsecounters() const {
  // @@protoc_insertion_point(field_get:atd.drivers.Vcu.nLeftNonDrivenWheelPulseCounters)
  return nleftnondrivenwheelpulsecounters_;
}
inline void Vcu::set_nleftnondrivenwheelpulsecounters(::google::protobuf::int32 value) {
  set_has_nleftnondrivenwheelpulsecounters();
  nleftnondrivenwheelpulsecounters_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.Vcu.nLeftNonDrivenWheelPulseCounters)
}

// optional int32 nRightNonDrivenWheelPulseCounters = 21;
inline bool Vcu::has_nrightnondrivenwheelpulsecounters() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Vcu::set_has_nrightnondrivenwheelpulsecounters() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Vcu::clear_has_nrightnondrivenwheelpulsecounters() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Vcu::clear_nrightnondrivenwheelpulsecounters() {
  nrightnondrivenwheelpulsecounters_ = 0;
  clear_has_nrightnondrivenwheelpulsecounters();
}
inline ::google::protobuf::int32 Vcu::nrightnondrivenwheelpulsecounters() const {
  // @@protoc_insertion_point(field_get:atd.drivers.Vcu.nRightNonDrivenWheelPulseCounters)
  return nrightnondrivenwheelpulsecounters_;
}
inline void Vcu::set_nrightnondrivenwheelpulsecounters(::google::protobuf::int32 value) {
  set_has_nrightnondrivenwheelpulsecounters();
  nrightnondrivenwheelpulsecounters_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.Vcu.nRightNonDrivenWheelPulseCounters)
}

// optional int32 nDriveMode = 22;
inline bool Vcu::has_ndrivemode() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Vcu::set_has_ndrivemode() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Vcu::clear_has_ndrivemode() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Vcu::clear_ndrivemode() {
  ndrivemode_ = 0;
  clear_has_ndrivemode();
}
inline ::google::protobuf::int32 Vcu::ndrivemode() const {
  // @@protoc_insertion_point(field_get:atd.drivers.Vcu.nDriveMode)
  return ndrivemode_;
}
inline void Vcu::set_ndrivemode(::google::protobuf::int32 value) {
  set_has_ndrivemode();
  ndrivemode_ = value;
  // @@protoc_insertion_point(field_set:atd.drivers.Vcu.nDriveMode)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)


}  // namespace drivers
}  // namespace atd

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_modules_2fipc_2fmessage_2fprotobuf_2fdrivers_2fvcu_2eproto__INCLUDED
