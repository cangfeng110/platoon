// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/ipc/message/protobuf/perception/gridlist.proto

#ifndef PROTOBUF_modules_2fipc_2fmessage_2fprotobuf_2fperception_2fgridlist_2eproto__INCLUDED
#define PROTOBUF_modules_2fipc_2fmessage_2fprotobuf_2fperception_2fgridlist_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include "modules/ipc/message/protobuf/common/header.pb.h"
#include "modules/ipc/message/protobuf/common/reserved.pb.h"
// @@protoc_insertion_point(includes)
namespace atd {
namespace common {
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Reserved;
class ReservedDefaultTypeInternal;
extern ReservedDefaultTypeInternal _Reserved_default_instance_;
}  // namespace common
namespace perception {
class Grid;
class GridDefaultTypeInternal;
extern GridDefaultTypeInternal _Grid_default_instance_;
class GridDisplay;
class GridDisplayDefaultTypeInternal;
extern GridDisplayDefaultTypeInternal _GridDisplay_default_instance_;
class GridList;
class GridListDefaultTypeInternal;
extern GridListDefaultTypeInternal _GridList_default_instance_;
class MatchDisplay;
class MatchDisplayDefaultTypeInternal;
extern MatchDisplayDefaultTypeInternal _MatchDisplay_default_instance_;
class OneMatch;
class OneMatchDefaultTypeInternal;
extern OneMatchDefaultTypeInternal _OneMatch_default_instance_;
}  // namespace perception
}  // namespace atd

namespace atd {
namespace perception {

namespace protobuf_modules_2fipc_2fmessage_2fprotobuf_2fperception_2fgridlist_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_modules_2fipc_2fmessage_2fprotobuf_2fperception_2fgridlist_2eproto

// ===================================================================

class Grid : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.perception.Grid) */ {
 public:
  Grid();
  virtual ~Grid();

  Grid(const Grid& from);

  inline Grid& operator=(const Grid& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Grid& default_instance();

  static inline const Grid* internal_default_instance() {
    return reinterpret_cast<const Grid*>(
               &_Grid_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Grid* other);

  // implements Message ----------------------------------------------

  inline Grid* New() const PROTOBUF_FINAL { return New(NULL); }

  Grid* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Grid& from);
  void MergeFrom(const Grid& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Grid* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float bf_local = 1;
  bool has_bf_local() const;
  void clear_bf_local();
  static const int kBfLocalFieldNumber = 1;
  float bf_local() const;
  void set_bf_local(float value);

  // optional float bf_move = 2;
  bool has_bf_move() const;
  void clear_bf_move();
  static const int kBfMoveFieldNumber = 2;
  float bf_move() const;
  void set_bf_move(float value);

  // optional float bf_free = 3;
  bool has_bf_free() const;
  void clear_bf_free();
  static const int kBfFreeFieldNumber = 3;
  float bf_free() const;
  void set_bf_free(float value);

  // optional float bf_occupy = 4;
  bool has_bf_occupy() const;
  void clear_bf_occupy();
  static const int kBfOccupyFieldNumber = 4;
  float bf_occupy() const;
  void set_bf_occupy(float value);

  // optional float bf_free_lane = 5;
  bool has_bf_free_lane() const;
  void clear_bf_free_lane();
  static const int kBfFreeLaneFieldNumber = 5;
  float bf_free_lane() const;
  void set_bf_free_lane(float value);

  // optional float bf_free_lane_solid = 6;
  bool has_bf_free_lane_solid() const;
  void clear_bf_free_lane_solid();
  static const int kBfFreeLaneSolidFieldNumber = 6;
  float bf_free_lane_solid() const;
  void set_bf_free_lane_solid(float value);

  // optional float bf_free_lane_dash = 7;
  bool has_bf_free_lane_dash() const;
  void clear_bf_free_lane_dash();
  static const int kBfFreeLaneDashFieldNumber = 7;
  float bf_free_lane_dash() const;
  void set_bf_free_lane_dash(float value);

  // optional float bf_free_lane_dsolid = 8;
  bool has_bf_free_lane_dsolid() const;
  void clear_bf_free_lane_dsolid();
  static const int kBfFreeLaneDsolidFieldNumber = 8;
  float bf_free_lane_dsolid() const;
  void set_bf_free_lane_dsolid(float value);

  // optional float bf_free_lane_edge = 9;
  bool has_bf_free_lane_edge() const;
  void clear_bf_free_lane_edge();
  static const int kBfFreeLaneEdgeFieldNumber = 9;
  float bf_free_lane_edge() const;
  void set_bf_free_lane_edge(float value);

  // optional float bf_free_lane_barrier = 10;
  bool has_bf_free_lane_barrier() const;
  void clear_bf_free_lane_barrier();
  static const int kBfFreeLaneBarrierFieldNumber = 10;
  float bf_free_lane_barrier() const;
  void set_bf_free_lane_barrier(float value);

  // required int32 rowindex = 101;
  bool has_rowindex() const;
  void clear_rowindex();
  static const int kRowindexFieldNumber = 101;
  ::google::protobuf::int32 rowindex() const;
  void set_rowindex(::google::protobuf::int32 value);

  // required int32 columnindex = 102;
  bool has_columnindex() const;
  void clear_columnindex();
  static const int kColumnindexFieldNumber = 102;
  ::google::protobuf::int32 columnindex() const;
  void set_columnindex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:atd.perception.Grid)
 private:
  void set_has_rowindex();
  void clear_has_rowindex();
  void set_has_columnindex();
  void clear_has_columnindex();
  void set_has_bf_local();
  void clear_has_bf_local();
  void set_has_bf_move();
  void clear_has_bf_move();
  void set_has_bf_free();
  void clear_has_bf_free();
  void set_has_bf_occupy();
  void clear_has_bf_occupy();
  void set_has_bf_free_lane();
  void clear_has_bf_free_lane();
  void set_has_bf_free_lane_solid();
  void clear_has_bf_free_lane_solid();
  void set_has_bf_free_lane_dash();
  void clear_has_bf_free_lane_dash();
  void set_has_bf_free_lane_dsolid();
  void clear_has_bf_free_lane_dsolid();
  void set_has_bf_free_lane_edge();
  void clear_has_bf_free_lane_edge();
  void set_has_bf_free_lane_barrier();
  void clear_has_bf_free_lane_barrier();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float bf_local_;
  float bf_move_;
  float bf_free_;
  float bf_occupy_;
  float bf_free_lane_;
  float bf_free_lane_solid_;
  float bf_free_lane_dash_;
  float bf_free_lane_dsolid_;
  float bf_free_lane_edge_;
  float bf_free_lane_barrier_;
  ::google::protobuf::int32 rowindex_;
  ::google::protobuf::int32 columnindex_;
  friend struct protobuf_modules_2fipc_2fmessage_2fprotobuf_2fperception_2fgridlist_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GridList : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.perception.GridList) */ {
 public:
  GridList();
  virtual ~GridList();

  GridList(const GridList& from);

  inline GridList& operator=(const GridList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GridList& default_instance();

  static inline const GridList* internal_default_instance() {
    return reinterpret_cast<const GridList*>(
               &_GridList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(GridList* other);

  // implements Message ----------------------------------------------

  inline GridList* New() const PROTOBUF_FINAL { return New(NULL); }

  GridList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const GridList& from);
  void MergeFrom(const GridList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GridList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .atd.perception.Grid onegrid = 3;
  int onegrid_size() const;
  void clear_onegrid();
  static const int kOnegridFieldNumber = 3;
  const ::atd::perception::Grid& onegrid(int index) const;
  ::atd::perception::Grid* mutable_onegrid(int index);
  ::atd::perception::Grid* add_onegrid();
  ::google::protobuf::RepeatedPtrField< ::atd::perception::Grid >*
      mutable_onegrid();
  const ::google::protobuf::RepeatedPtrField< ::atd::perception::Grid >&
      onegrid() const;

  // optional .atd.common.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::atd::common::Header& header() const;
  ::atd::common::Header* mutable_header();
  ::atd::common::Header* release_header();
  void set_allocated_header(::atd::common::Header* header);

  // optional .atd.common.Reserved reservedmsg = 2;
  bool has_reservedmsg() const;
  void clear_reservedmsg();
  static const int kReservedmsgFieldNumber = 2;
  const ::atd::common::Reserved& reservedmsg() const;
  ::atd::common::Reserved* mutable_reservedmsg();
  ::atd::common::Reserved* release_reservedmsg();
  void set_allocated_reservedmsg(::atd::common::Reserved* reservedmsg);

  // @@protoc_insertion_point(class_scope:atd.perception.GridList)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_reservedmsg();
  void clear_has_reservedmsg();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::atd::perception::Grid > onegrid_;
  ::atd::common::Header* header_;
  ::atd::common::Reserved* reservedmsg_;
  friend struct protobuf_modules_2fipc_2fmessage_2fprotobuf_2fperception_2fgridlist_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GridDisplay : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.perception.GridDisplay) */ {
 public:
  GridDisplay();
  virtual ~GridDisplay();

  GridDisplay(const GridDisplay& from);

  inline GridDisplay& operator=(const GridDisplay& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GridDisplay& default_instance();

  static inline const GridDisplay* internal_default_instance() {
    return reinterpret_cast<const GridDisplay*>(
               &_GridDisplay_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(GridDisplay* other);

  // implements Message ----------------------------------------------

  inline GridDisplay* New() const PROTOBUF_FINAL { return New(NULL); }

  GridDisplay* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const GridDisplay& from);
  void MergeFrom(const GridDisplay& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GridDisplay* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 columnindex = 102;
  bool has_columnindex() const;
  void clear_columnindex();
  static const int kColumnindexFieldNumber = 102;
  ::google::protobuf::int32 columnindex() const;
  void set_columnindex(::google::protobuf::int32 value);

  // optional int32 matchtype = 1;
  bool has_matchtype() const;
  void clear_matchtype();
  static const int kMatchtypeFieldNumber = 1;
  ::google::protobuf::int32 matchtype() const;
  void set_matchtype(::google::protobuf::int32 value);

  // required int32 rowindex = 101;
  bool has_rowindex() const;
  void clear_rowindex();
  static const int kRowindexFieldNumber = 101;
  ::google::protobuf::int32 rowindex() const;
  void set_rowindex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:atd.perception.GridDisplay)
 private:
  void set_has_rowindex();
  void clear_has_rowindex();
  void set_has_columnindex();
  void clear_has_columnindex();
  void set_has_matchtype();
  void clear_has_matchtype();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 columnindex_;
  ::google::protobuf::int32 matchtype_;
  ::google::protobuf::int32 rowindex_;
  friend struct protobuf_modules_2fipc_2fmessage_2fprotobuf_2fperception_2fgridlist_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OneMatch : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.perception.OneMatch) */ {
 public:
  OneMatch();
  virtual ~OneMatch();

  OneMatch(const OneMatch& from);

  inline OneMatch& operator=(const OneMatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const OneMatch& default_instance();

  static inline const OneMatch* internal_default_instance() {
    return reinterpret_cast<const OneMatch*>(
               &_OneMatch_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(OneMatch* other);

  // implements Message ----------------------------------------------

  inline OneMatch* New() const PROTOBUF_FINAL { return New(NULL); }

  OneMatch* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const OneMatch& from);
  void MergeFrom(const OneMatch& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OneMatch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .atd.perception.GridDisplay onegrid = 5;
  int onegrid_size() const;
  void clear_onegrid();
  static const int kOnegridFieldNumber = 5;
  const ::atd::perception::GridDisplay& onegrid(int index) const;
  ::atd::perception::GridDisplay* mutable_onegrid(int index);
  ::atd::perception::GridDisplay* add_onegrid();
  ::google::protobuf::RepeatedPtrField< ::atd::perception::GridDisplay >*
      mutable_onegrid();
  const ::google::protobuf::RepeatedPtrField< ::atd::perception::GridDisplay >&
      onegrid() const;

  // optional float delta_x = 1;
  bool has_delta_x() const;
  void clear_delta_x();
  static const int kDeltaXFieldNumber = 1;
  float delta_x() const;
  void set_delta_x(float value);

  // optional float delta_y = 2;
  bool has_delta_y() const;
  void clear_delta_y();
  static const int kDeltaYFieldNumber = 2;
  float delta_y() const;
  void set_delta_y(float value);

  // optional float delta_yaw = 3;
  bool has_delta_yaw() const;
  void clear_delta_yaw();
  static const int kDeltaYawFieldNumber = 3;
  float delta_yaw() const;
  void set_delta_yaw(float value);

  // optional float score = 4;
  bool has_score() const;
  void clear_score();
  static const int kScoreFieldNumber = 4;
  float score() const;
  void set_score(float value);

  // @@protoc_insertion_point(class_scope:atd.perception.OneMatch)
 private:
  void set_has_delta_x();
  void clear_has_delta_x();
  void set_has_delta_y();
  void clear_has_delta_y();
  void set_has_delta_yaw();
  void clear_has_delta_yaw();
  void set_has_score();
  void clear_has_score();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::atd::perception::GridDisplay > onegrid_;
  float delta_x_;
  float delta_y_;
  float delta_yaw_;
  float score_;
  friend struct protobuf_modules_2fipc_2fmessage_2fprotobuf_2fperception_2fgridlist_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MatchDisplay : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.perception.MatchDisplay) */ {
 public:
  MatchDisplay();
  virtual ~MatchDisplay();

  MatchDisplay(const MatchDisplay& from);

  inline MatchDisplay& operator=(const MatchDisplay& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const MatchDisplay& default_instance();

  static inline const MatchDisplay* internal_default_instance() {
    return reinterpret_cast<const MatchDisplay*>(
               &_MatchDisplay_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(MatchDisplay* other);

  // implements Message ----------------------------------------------

  inline MatchDisplay* New() const PROTOBUF_FINAL { return New(NULL); }

  MatchDisplay* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const MatchDisplay& from);
  void MergeFrom(const MatchDisplay& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MatchDisplay* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .atd.perception.OneMatch onematch = 3;
  int onematch_size() const;
  void clear_onematch();
  static const int kOnematchFieldNumber = 3;
  const ::atd::perception::OneMatch& onematch(int index) const;
  ::atd::perception::OneMatch* mutable_onematch(int index);
  ::atd::perception::OneMatch* add_onematch();
  ::google::protobuf::RepeatedPtrField< ::atd::perception::OneMatch >*
      mutable_onematch();
  const ::google::protobuf::RepeatedPtrField< ::atd::perception::OneMatch >&
      onematch() const;

  // optional .atd.common.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::atd::common::Header& header() const;
  ::atd::common::Header* mutable_header();
  ::atd::common::Header* release_header();
  void set_allocated_header(::atd::common::Header* header);

  // optional .atd.common.Reserved reservedmsg = 2;
  bool has_reservedmsg() const;
  void clear_reservedmsg();
  static const int kReservedmsgFieldNumber = 2;
  const ::atd::common::Reserved& reservedmsg() const;
  ::atd::common::Reserved* mutable_reservedmsg();
  ::atd::common::Reserved* release_reservedmsg();
  void set_allocated_reservedmsg(::atd::common::Reserved* reservedmsg);

  // @@protoc_insertion_point(class_scope:atd.perception.MatchDisplay)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_reservedmsg();
  void clear_has_reservedmsg();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::atd::perception::OneMatch > onematch_;
  ::atd::common::Header* header_;
  ::atd::common::Reserved* reservedmsg_;
  friend struct protobuf_modules_2fipc_2fmessage_2fprotobuf_2fperception_2fgridlist_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Grid

// required int32 rowindex = 101;
inline bool Grid::has_rowindex() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Grid::set_has_rowindex() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Grid::clear_has_rowindex() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Grid::clear_rowindex() {
  rowindex_ = 0;
  clear_has_rowindex();
}
inline ::google::protobuf::int32 Grid::rowindex() const {
  // @@protoc_insertion_point(field_get:atd.perception.Grid.rowindex)
  return rowindex_;
}
inline void Grid::set_rowindex(::google::protobuf::int32 value) {
  set_has_rowindex();
  rowindex_ = value;
  // @@protoc_insertion_point(field_set:atd.perception.Grid.rowindex)
}

// required int32 columnindex = 102;
inline bool Grid::has_columnindex() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Grid::set_has_columnindex() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Grid::clear_has_columnindex() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Grid::clear_columnindex() {
  columnindex_ = 0;
  clear_has_columnindex();
}
inline ::google::protobuf::int32 Grid::columnindex() const {
  // @@protoc_insertion_point(field_get:atd.perception.Grid.columnindex)
  return columnindex_;
}
inline void Grid::set_columnindex(::google::protobuf::int32 value) {
  set_has_columnindex();
  columnindex_ = value;
  // @@protoc_insertion_point(field_set:atd.perception.Grid.columnindex)
}

// optional float bf_local = 1;
inline bool Grid::has_bf_local() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Grid::set_has_bf_local() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Grid::clear_has_bf_local() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Grid::clear_bf_local() {
  bf_local_ = 0;
  clear_has_bf_local();
}
inline float Grid::bf_local() const {
  // @@protoc_insertion_point(field_get:atd.perception.Grid.bf_local)
  return bf_local_;
}
inline void Grid::set_bf_local(float value) {
  set_has_bf_local();
  bf_local_ = value;
  // @@protoc_insertion_point(field_set:atd.perception.Grid.bf_local)
}

// optional float bf_move = 2;
inline bool Grid::has_bf_move() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Grid::set_has_bf_move() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Grid::clear_has_bf_move() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Grid::clear_bf_move() {
  bf_move_ = 0;
  clear_has_bf_move();
}
inline float Grid::bf_move() const {
  // @@protoc_insertion_point(field_get:atd.perception.Grid.bf_move)
  return bf_move_;
}
inline void Grid::set_bf_move(float value) {
  set_has_bf_move();
  bf_move_ = value;
  // @@protoc_insertion_point(field_set:atd.perception.Grid.bf_move)
}

// optional float bf_free = 3;
inline bool Grid::has_bf_free() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Grid::set_has_bf_free() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Grid::clear_has_bf_free() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Grid::clear_bf_free() {
  bf_free_ = 0;
  clear_has_bf_free();
}
inline float Grid::bf_free() const {
  // @@protoc_insertion_point(field_get:atd.perception.Grid.bf_free)
  return bf_free_;
}
inline void Grid::set_bf_free(float value) {
  set_has_bf_free();
  bf_free_ = value;
  // @@protoc_insertion_point(field_set:atd.perception.Grid.bf_free)
}

// optional float bf_occupy = 4;
inline bool Grid::has_bf_occupy() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Grid::set_has_bf_occupy() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Grid::clear_has_bf_occupy() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Grid::clear_bf_occupy() {
  bf_occupy_ = 0;
  clear_has_bf_occupy();
}
inline float Grid::bf_occupy() const {
  // @@protoc_insertion_point(field_get:atd.perception.Grid.bf_occupy)
  return bf_occupy_;
}
inline void Grid::set_bf_occupy(float value) {
  set_has_bf_occupy();
  bf_occupy_ = value;
  // @@protoc_insertion_point(field_set:atd.perception.Grid.bf_occupy)
}

// optional float bf_free_lane = 5;
inline bool Grid::has_bf_free_lane() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Grid::set_has_bf_free_lane() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Grid::clear_has_bf_free_lane() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Grid::clear_bf_free_lane() {
  bf_free_lane_ = 0;
  clear_has_bf_free_lane();
}
inline float Grid::bf_free_lane() const {
  // @@protoc_insertion_point(field_get:atd.perception.Grid.bf_free_lane)
  return bf_free_lane_;
}
inline void Grid::set_bf_free_lane(float value) {
  set_has_bf_free_lane();
  bf_free_lane_ = value;
  // @@protoc_insertion_point(field_set:atd.perception.Grid.bf_free_lane)
}

// optional float bf_free_lane_solid = 6;
inline bool Grid::has_bf_free_lane_solid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Grid::set_has_bf_free_lane_solid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Grid::clear_has_bf_free_lane_solid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Grid::clear_bf_free_lane_solid() {
  bf_free_lane_solid_ = 0;
  clear_has_bf_free_lane_solid();
}
inline float Grid::bf_free_lane_solid() const {
  // @@protoc_insertion_point(field_get:atd.perception.Grid.bf_free_lane_solid)
  return bf_free_lane_solid_;
}
inline void Grid::set_bf_free_lane_solid(float value) {
  set_has_bf_free_lane_solid();
  bf_free_lane_solid_ = value;
  // @@protoc_insertion_point(field_set:atd.perception.Grid.bf_free_lane_solid)
}

// optional float bf_free_lane_dash = 7;
inline bool Grid::has_bf_free_lane_dash() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Grid::set_has_bf_free_lane_dash() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Grid::clear_has_bf_free_lane_dash() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Grid::clear_bf_free_lane_dash() {
  bf_free_lane_dash_ = 0;
  clear_has_bf_free_lane_dash();
}
inline float Grid::bf_free_lane_dash() const {
  // @@protoc_insertion_point(field_get:atd.perception.Grid.bf_free_lane_dash)
  return bf_free_lane_dash_;
}
inline void Grid::set_bf_free_lane_dash(float value) {
  set_has_bf_free_lane_dash();
  bf_free_lane_dash_ = value;
  // @@protoc_insertion_point(field_set:atd.perception.Grid.bf_free_lane_dash)
}

// optional float bf_free_lane_dsolid = 8;
inline bool Grid::has_bf_free_lane_dsolid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Grid::set_has_bf_free_lane_dsolid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Grid::clear_has_bf_free_lane_dsolid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Grid::clear_bf_free_lane_dsolid() {
  bf_free_lane_dsolid_ = 0;
  clear_has_bf_free_lane_dsolid();
}
inline float Grid::bf_free_lane_dsolid() const {
  // @@protoc_insertion_point(field_get:atd.perception.Grid.bf_free_lane_dsolid)
  return bf_free_lane_dsolid_;
}
inline void Grid::set_bf_free_lane_dsolid(float value) {
  set_has_bf_free_lane_dsolid();
  bf_free_lane_dsolid_ = value;
  // @@protoc_insertion_point(field_set:atd.perception.Grid.bf_free_lane_dsolid)
}

// optional float bf_free_lane_edge = 9;
inline bool Grid::has_bf_free_lane_edge() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Grid::set_has_bf_free_lane_edge() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Grid::clear_has_bf_free_lane_edge() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Grid::clear_bf_free_lane_edge() {
  bf_free_lane_edge_ = 0;
  clear_has_bf_free_lane_edge();
}
inline float Grid::bf_free_lane_edge() const {
  // @@protoc_insertion_point(field_get:atd.perception.Grid.bf_free_lane_edge)
  return bf_free_lane_edge_;
}
inline void Grid::set_bf_free_lane_edge(float value) {
  set_has_bf_free_lane_edge();
  bf_free_lane_edge_ = value;
  // @@protoc_insertion_point(field_set:atd.perception.Grid.bf_free_lane_edge)
}

// optional float bf_free_lane_barrier = 10;
inline bool Grid::has_bf_free_lane_barrier() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Grid::set_has_bf_free_lane_barrier() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Grid::clear_has_bf_free_lane_barrier() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Grid::clear_bf_free_lane_barrier() {
  bf_free_lane_barrier_ = 0;
  clear_has_bf_free_lane_barrier();
}
inline float Grid::bf_free_lane_barrier() const {
  // @@protoc_insertion_point(field_get:atd.perception.Grid.bf_free_lane_barrier)
  return bf_free_lane_barrier_;
}
inline void Grid::set_bf_free_lane_barrier(float value) {
  set_has_bf_free_lane_barrier();
  bf_free_lane_barrier_ = value;
  // @@protoc_insertion_point(field_set:atd.perception.Grid.bf_free_lane_barrier)
}

// -------------------------------------------------------------------

// GridList

// optional .atd.common.Header header = 1;
inline bool GridList::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GridList::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GridList::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GridList::clear_header() {
  if (header_ != NULL) header_->::atd::common::Header::Clear();
  clear_has_header();
}
inline const ::atd::common::Header& GridList::header() const {
  // @@protoc_insertion_point(field_get:atd.perception.GridList.header)
  return header_ != NULL ? *header_
                         : *::atd::common::Header::internal_default_instance();
}
inline ::atd::common::Header* GridList::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::atd::common::Header;
  }
  // @@protoc_insertion_point(field_mutable:atd.perception.GridList.header)
  return header_;
}
inline ::atd::common::Header* GridList::release_header() {
  // @@protoc_insertion_point(field_release:atd.perception.GridList.header)
  clear_has_header();
  ::atd::common::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GridList::set_allocated_header(::atd::common::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.perception.GridList.header)
}

// optional .atd.common.Reserved reservedmsg = 2;
inline bool GridList::has_reservedmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GridList::set_has_reservedmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GridList::clear_has_reservedmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GridList::clear_reservedmsg() {
  if (reservedmsg_ != NULL) reservedmsg_->::atd::common::Reserved::Clear();
  clear_has_reservedmsg();
}
inline const ::atd::common::Reserved& GridList::reservedmsg() const {
  // @@protoc_insertion_point(field_get:atd.perception.GridList.reservedmsg)
  return reservedmsg_ != NULL ? *reservedmsg_
                         : *::atd::common::Reserved::internal_default_instance();
}
inline ::atd::common::Reserved* GridList::mutable_reservedmsg() {
  set_has_reservedmsg();
  if (reservedmsg_ == NULL) {
    reservedmsg_ = new ::atd::common::Reserved;
  }
  // @@protoc_insertion_point(field_mutable:atd.perception.GridList.reservedmsg)
  return reservedmsg_;
}
inline ::atd::common::Reserved* GridList::release_reservedmsg() {
  // @@protoc_insertion_point(field_release:atd.perception.GridList.reservedmsg)
  clear_has_reservedmsg();
  ::atd::common::Reserved* temp = reservedmsg_;
  reservedmsg_ = NULL;
  return temp;
}
inline void GridList::set_allocated_reservedmsg(::atd::common::Reserved* reservedmsg) {
  delete reservedmsg_;
  reservedmsg_ = reservedmsg;
  if (reservedmsg) {
    set_has_reservedmsg();
  } else {
    clear_has_reservedmsg();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.perception.GridList.reservedmsg)
}

// repeated .atd.perception.Grid onegrid = 3;
inline int GridList::onegrid_size() const {
  return onegrid_.size();
}
inline void GridList::clear_onegrid() {
  onegrid_.Clear();
}
inline const ::atd::perception::Grid& GridList::onegrid(int index) const {
  // @@protoc_insertion_point(field_get:atd.perception.GridList.onegrid)
  return onegrid_.Get(index);
}
inline ::atd::perception::Grid* GridList::mutable_onegrid(int index) {
  // @@protoc_insertion_point(field_mutable:atd.perception.GridList.onegrid)
  return onegrid_.Mutable(index);
}
inline ::atd::perception::Grid* GridList::add_onegrid() {
  // @@protoc_insertion_point(field_add:atd.perception.GridList.onegrid)
  return onegrid_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::atd::perception::Grid >*
GridList::mutable_onegrid() {
  // @@protoc_insertion_point(field_mutable_list:atd.perception.GridList.onegrid)
  return &onegrid_;
}
inline const ::google::protobuf::RepeatedPtrField< ::atd::perception::Grid >&
GridList::onegrid() const {
  // @@protoc_insertion_point(field_list:atd.perception.GridList.onegrid)
  return onegrid_;
}

// -------------------------------------------------------------------

// GridDisplay

// required int32 rowindex = 101;
inline bool GridDisplay::has_rowindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GridDisplay::set_has_rowindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GridDisplay::clear_has_rowindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GridDisplay::clear_rowindex() {
  rowindex_ = 0;
  clear_has_rowindex();
}
inline ::google::protobuf::int32 GridDisplay::rowindex() const {
  // @@protoc_insertion_point(field_get:atd.perception.GridDisplay.rowindex)
  return rowindex_;
}
inline void GridDisplay::set_rowindex(::google::protobuf::int32 value) {
  set_has_rowindex();
  rowindex_ = value;
  // @@protoc_insertion_point(field_set:atd.perception.GridDisplay.rowindex)
}

// required int32 columnindex = 102;
inline bool GridDisplay::has_columnindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GridDisplay::set_has_columnindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GridDisplay::clear_has_columnindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GridDisplay::clear_columnindex() {
  columnindex_ = 0;
  clear_has_columnindex();
}
inline ::google::protobuf::int32 GridDisplay::columnindex() const {
  // @@protoc_insertion_point(field_get:atd.perception.GridDisplay.columnindex)
  return columnindex_;
}
inline void GridDisplay::set_columnindex(::google::protobuf::int32 value) {
  set_has_columnindex();
  columnindex_ = value;
  // @@protoc_insertion_point(field_set:atd.perception.GridDisplay.columnindex)
}

// optional int32 matchtype = 1;
inline bool GridDisplay::has_matchtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GridDisplay::set_has_matchtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GridDisplay::clear_has_matchtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GridDisplay::clear_matchtype() {
  matchtype_ = 0;
  clear_has_matchtype();
}
inline ::google::protobuf::int32 GridDisplay::matchtype() const {
  // @@protoc_insertion_point(field_get:atd.perception.GridDisplay.matchtype)
  return matchtype_;
}
inline void GridDisplay::set_matchtype(::google::protobuf::int32 value) {
  set_has_matchtype();
  matchtype_ = value;
  // @@protoc_insertion_point(field_set:atd.perception.GridDisplay.matchtype)
}

// -------------------------------------------------------------------

// OneMatch

// optional float delta_x = 1;
inline bool OneMatch::has_delta_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OneMatch::set_has_delta_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OneMatch::clear_has_delta_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OneMatch::clear_delta_x() {
  delta_x_ = 0;
  clear_has_delta_x();
}
inline float OneMatch::delta_x() const {
  // @@protoc_insertion_point(field_get:atd.perception.OneMatch.delta_x)
  return delta_x_;
}
inline void OneMatch::set_delta_x(float value) {
  set_has_delta_x();
  delta_x_ = value;
  // @@protoc_insertion_point(field_set:atd.perception.OneMatch.delta_x)
}

// optional float delta_y = 2;
inline bool OneMatch::has_delta_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OneMatch::set_has_delta_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OneMatch::clear_has_delta_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OneMatch::clear_delta_y() {
  delta_y_ = 0;
  clear_has_delta_y();
}
inline float OneMatch::delta_y() const {
  // @@protoc_insertion_point(field_get:atd.perception.OneMatch.delta_y)
  return delta_y_;
}
inline void OneMatch::set_delta_y(float value) {
  set_has_delta_y();
  delta_y_ = value;
  // @@protoc_insertion_point(field_set:atd.perception.OneMatch.delta_y)
}

// optional float delta_yaw = 3;
inline bool OneMatch::has_delta_yaw() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OneMatch::set_has_delta_yaw() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OneMatch::clear_has_delta_yaw() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OneMatch::clear_delta_yaw() {
  delta_yaw_ = 0;
  clear_has_delta_yaw();
}
inline float OneMatch::delta_yaw() const {
  // @@protoc_insertion_point(field_get:atd.perception.OneMatch.delta_yaw)
  return delta_yaw_;
}
inline void OneMatch::set_delta_yaw(float value) {
  set_has_delta_yaw();
  delta_yaw_ = value;
  // @@protoc_insertion_point(field_set:atd.perception.OneMatch.delta_yaw)
}

// optional float score = 4;
inline bool OneMatch::has_score() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OneMatch::set_has_score() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OneMatch::clear_has_score() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OneMatch::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline float OneMatch::score() const {
  // @@protoc_insertion_point(field_get:atd.perception.OneMatch.score)
  return score_;
}
inline void OneMatch::set_score(float value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:atd.perception.OneMatch.score)
}

// repeated .atd.perception.GridDisplay onegrid = 5;
inline int OneMatch::onegrid_size() const {
  return onegrid_.size();
}
inline void OneMatch::clear_onegrid() {
  onegrid_.Clear();
}
inline const ::atd::perception::GridDisplay& OneMatch::onegrid(int index) const {
  // @@protoc_insertion_point(field_get:atd.perception.OneMatch.onegrid)
  return onegrid_.Get(index);
}
inline ::atd::perception::GridDisplay* OneMatch::mutable_onegrid(int index) {
  // @@protoc_insertion_point(field_mutable:atd.perception.OneMatch.onegrid)
  return onegrid_.Mutable(index);
}
inline ::atd::perception::GridDisplay* OneMatch::add_onegrid() {
  // @@protoc_insertion_point(field_add:atd.perception.OneMatch.onegrid)
  return onegrid_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::atd::perception::GridDisplay >*
OneMatch::mutable_onegrid() {
  // @@protoc_insertion_point(field_mutable_list:atd.perception.OneMatch.onegrid)
  return &onegrid_;
}
inline const ::google::protobuf::RepeatedPtrField< ::atd::perception::GridDisplay >&
OneMatch::onegrid() const {
  // @@protoc_insertion_point(field_list:atd.perception.OneMatch.onegrid)
  return onegrid_;
}

// -------------------------------------------------------------------

// MatchDisplay

// optional .atd.common.Header header = 1;
inline bool MatchDisplay::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MatchDisplay::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MatchDisplay::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MatchDisplay::clear_header() {
  if (header_ != NULL) header_->::atd::common::Header::Clear();
  clear_has_header();
}
inline const ::atd::common::Header& MatchDisplay::header() const {
  // @@protoc_insertion_point(field_get:atd.perception.MatchDisplay.header)
  return header_ != NULL ? *header_
                         : *::atd::common::Header::internal_default_instance();
}
inline ::atd::common::Header* MatchDisplay::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::atd::common::Header;
  }
  // @@protoc_insertion_point(field_mutable:atd.perception.MatchDisplay.header)
  return header_;
}
inline ::atd::common::Header* MatchDisplay::release_header() {
  // @@protoc_insertion_point(field_release:atd.perception.MatchDisplay.header)
  clear_has_header();
  ::atd::common::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void MatchDisplay::set_allocated_header(::atd::common::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.perception.MatchDisplay.header)
}

// optional .atd.common.Reserved reservedmsg = 2;
inline bool MatchDisplay::has_reservedmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MatchDisplay::set_has_reservedmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MatchDisplay::clear_has_reservedmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MatchDisplay::clear_reservedmsg() {
  if (reservedmsg_ != NULL) reservedmsg_->::atd::common::Reserved::Clear();
  clear_has_reservedmsg();
}
inline const ::atd::common::Reserved& MatchDisplay::reservedmsg() const {
  // @@protoc_insertion_point(field_get:atd.perception.MatchDisplay.reservedmsg)
  return reservedmsg_ != NULL ? *reservedmsg_
                         : *::atd::common::Reserved::internal_default_instance();
}
inline ::atd::common::Reserved* MatchDisplay::mutable_reservedmsg() {
  set_has_reservedmsg();
  if (reservedmsg_ == NULL) {
    reservedmsg_ = new ::atd::common::Reserved;
  }
  // @@protoc_insertion_point(field_mutable:atd.perception.MatchDisplay.reservedmsg)
  return reservedmsg_;
}
inline ::atd::common::Reserved* MatchDisplay::release_reservedmsg() {
  // @@protoc_insertion_point(field_release:atd.perception.MatchDisplay.reservedmsg)
  clear_has_reservedmsg();
  ::atd::common::Reserved* temp = reservedmsg_;
  reservedmsg_ = NULL;
  return temp;
}
inline void MatchDisplay::set_allocated_reservedmsg(::atd::common::Reserved* reservedmsg) {
  delete reservedmsg_;
  reservedmsg_ = reservedmsg;
  if (reservedmsg) {
    set_has_reservedmsg();
  } else {
    clear_has_reservedmsg();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.perception.MatchDisplay.reservedmsg)
}

// repeated .atd.perception.OneMatch onematch = 3;
inline int MatchDisplay::onematch_size() const {
  return onematch_.size();
}
inline void MatchDisplay::clear_onematch() {
  onematch_.Clear();
}
inline const ::atd::perception::OneMatch& MatchDisplay::onematch(int index) const {
  // @@protoc_insertion_point(field_get:atd.perception.MatchDisplay.onematch)
  return onematch_.Get(index);
}
inline ::atd::perception::OneMatch* MatchDisplay::mutable_onematch(int index) {
  // @@protoc_insertion_point(field_mutable:atd.perception.MatchDisplay.onematch)
  return onematch_.Mutable(index);
}
inline ::atd::perception::OneMatch* MatchDisplay::add_onematch() {
  // @@protoc_insertion_point(field_add:atd.perception.MatchDisplay.onematch)
  return onematch_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::atd::perception::OneMatch >*
MatchDisplay::mutable_onematch() {
  // @@protoc_insertion_point(field_mutable_list:atd.perception.MatchDisplay.onematch)
  return &onematch_;
}
inline const ::google::protobuf::RepeatedPtrField< ::atd::perception::OneMatch >&
MatchDisplay::onematch() const {
  // @@protoc_insertion_point(field_list:atd.perception.MatchDisplay.onematch)
  return onematch_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace perception
}  // namespace atd

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_modules_2fipc_2fmessage_2fprotobuf_2fperception_2fgridlist_2eproto__INCLUDED
