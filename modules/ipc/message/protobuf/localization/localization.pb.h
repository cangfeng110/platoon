// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/ipc/message/protobuf/localization/localization.proto

#ifndef PROTOBUF_modules_2fipc_2fmessage_2fprotobuf_2flocalization_2flocalization_2eproto__INCLUDED
#define PROTOBUF_modules_2fipc_2fmessage_2fprotobuf_2flocalization_2flocalization_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "modules/ipc/message/protobuf/common/header.pb.h"
#include "modules/ipc/message/protobuf/common/reserved.pb.h"
#include "modules/ipc/message/protobuf/localization/pose.pb.h"
#include "modules/ipc/message/protobuf/common/geometry.pb.h"
#include "modules/ipc/message/protobuf/common/pnc_point.pb.h"
// @@protoc_insertion_point(includes)
namespace atd {
namespace common {
class Arrow2D;
class Arrow2DDefaultTypeInternal;
extern Arrow2DDefaultTypeInternal _Arrow2D_default_instance_;
class FrenetFramePoint;
class FrenetFramePointDefaultTypeInternal;
extern FrenetFramePointDefaultTypeInternal _FrenetFramePoint_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Path;
class PathDefaultTypeInternal;
extern PathDefaultTypeInternal _Path_default_instance_;
class PathPoint;
class PathPointDefaultTypeInternal;
extern PathPointDefaultTypeInternal _PathPoint_default_instance_;
class Point2D;
class Point2DDefaultTypeInternal;
extern Point2DDefaultTypeInternal _Point2D_default_instance_;
class Point3D;
class Point3DDefaultTypeInternal;
extern Point3DDefaultTypeInternal _Point3D_default_instance_;
class PointENU;
class PointENUDefaultTypeInternal;
extern PointENUDefaultTypeInternal _PointENU_default_instance_;
class PointLLH;
class PointLLHDefaultTypeInternal;
extern PointLLHDefaultTypeInternal _PointLLH_default_instance_;
class Quaternion;
class QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class Reserved;
class ReservedDefaultTypeInternal;
extern ReservedDefaultTypeInternal _Reserved_default_instance_;
class SLPoint;
class SLPointDefaultTypeInternal;
extern SLPointDefaultTypeInternal _SLPoint_default_instance_;
class SpeedPoint;
class SpeedPointDefaultTypeInternal;
extern SpeedPointDefaultTypeInternal _SpeedPoint_default_instance_;
class TrajectoryPoint;
class TrajectoryPointDefaultTypeInternal;
extern TrajectoryPointDefaultTypeInternal _TrajectoryPoint_default_instance_;
}  // namespace common
namespace localization {
class LocalizationAbsEstimate;
class LocalizationAbsEstimateDefaultTypeInternal;
extern LocalizationAbsEstimateDefaultTypeInternal _LocalizationAbsEstimate_default_instance_;
class LocalizationEstimate;
class LocalizationEstimateDefaultTypeInternal;
extern LocalizationEstimateDefaultTypeInternal _LocalizationEstimate_default_instance_;
class LocalizationMapMatchEstimate;
class LocalizationMapMatchEstimateDefaultTypeInternal;
extern LocalizationMapMatchEstimateDefaultTypeInternal _LocalizationMapMatchEstimate_default_instance_;
class Particle;
class ParticleDefaultTypeInternal;
extern ParticleDefaultTypeInternal _Particle_default_instance_;
class Particles;
class ParticlesDefaultTypeInternal;
extern ParticlesDefaultTypeInternal _Particles_default_instance_;
class Particles_Collection;
class Particles_CollectionDefaultTypeInternal;
extern Particles_CollectionDefaultTypeInternal _Particles_Collection_default_instance_;
class Pose;
class PoseDefaultTypeInternal;
extern PoseDefaultTypeInternal _Pose_default_instance_;
class Uncertainty;
class UncertaintyDefaultTypeInternal;
extern UncertaintyDefaultTypeInternal _Uncertainty_default_instance_;
}  // namespace localization
}  // namespace atd

namespace atd {
namespace localization {

namespace protobuf_modules_2fipc_2fmessage_2fprotobuf_2flocalization_2flocalization_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_modules_2fipc_2fmessage_2fprotobuf_2flocalization_2flocalization_2eproto

enum MeasureState {
  NOT_VALID = 0,
  NOT_STABLE = 1,
  OK = 2,
  VALID = 3
};
bool MeasureState_IsValid(int value);
const MeasureState MeasureState_MIN = NOT_VALID;
const MeasureState MeasureState_MAX = VALID;
const int MeasureState_ARRAYSIZE = MeasureState_MAX + 1;

// ===================================================================

class Uncertainty : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.localization.Uncertainty) */ {
 public:
  Uncertainty();
  virtual ~Uncertainty();

  Uncertainty(const Uncertainty& from);

  inline Uncertainty& operator=(const Uncertainty& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Uncertainty& default_instance();

  static inline const Uncertainty* internal_default_instance() {
    return reinterpret_cast<const Uncertainty*>(
               &_Uncertainty_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Uncertainty* other);

  // implements Message ----------------------------------------------

  inline Uncertainty* New() const PROTOBUF_FINAL { return New(NULL); }

  Uncertainty* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Uncertainty& from);
  void MergeFrom(const Uncertainty& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Uncertainty* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .atd.common.Point3D position_std_dev = 1;
  bool has_position_std_dev() const;
  void clear_position_std_dev();
  static const int kPositionStdDevFieldNumber = 1;
  const ::atd::common::Point3D& position_std_dev() const;
  ::atd::common::Point3D* mutable_position_std_dev();
  ::atd::common::Point3D* release_position_std_dev();
  void set_allocated_position_std_dev(::atd::common::Point3D* position_std_dev);

  // optional .atd.common.Point3D orientation_std_dev = 2;
  bool has_orientation_std_dev() const;
  void clear_orientation_std_dev();
  static const int kOrientationStdDevFieldNumber = 2;
  const ::atd::common::Point3D& orientation_std_dev() const;
  ::atd::common::Point3D* mutable_orientation_std_dev();
  ::atd::common::Point3D* release_orientation_std_dev();
  void set_allocated_orientation_std_dev(::atd::common::Point3D* orientation_std_dev);

  // optional .atd.common.Point3D linear_velocity_std_dev = 3;
  bool has_linear_velocity_std_dev() const;
  void clear_linear_velocity_std_dev();
  static const int kLinearVelocityStdDevFieldNumber = 3;
  const ::atd::common::Point3D& linear_velocity_std_dev() const;
  ::atd::common::Point3D* mutable_linear_velocity_std_dev();
  ::atd::common::Point3D* release_linear_velocity_std_dev();
  void set_allocated_linear_velocity_std_dev(::atd::common::Point3D* linear_velocity_std_dev);

  // optional .atd.common.Point3D linear_acceleration_std_dev = 4;
  bool has_linear_acceleration_std_dev() const;
  void clear_linear_acceleration_std_dev();
  static const int kLinearAccelerationStdDevFieldNumber = 4;
  const ::atd::common::Point3D& linear_acceleration_std_dev() const;
  ::atd::common::Point3D* mutable_linear_acceleration_std_dev();
  ::atd::common::Point3D* release_linear_acceleration_std_dev();
  void set_allocated_linear_acceleration_std_dev(::atd::common::Point3D* linear_acceleration_std_dev);

  // optional .atd.common.Point3D angular_velocity_std_dev = 5;
  bool has_angular_velocity_std_dev() const;
  void clear_angular_velocity_std_dev();
  static const int kAngularVelocityStdDevFieldNumber = 5;
  const ::atd::common::Point3D& angular_velocity_std_dev() const;
  ::atd::common::Point3D* mutable_angular_velocity_std_dev();
  ::atd::common::Point3D* release_angular_velocity_std_dev();
  void set_allocated_angular_velocity_std_dev(::atd::common::Point3D* angular_velocity_std_dev);

  // @@protoc_insertion_point(class_scope:atd.localization.Uncertainty)
 private:
  void set_has_position_std_dev();
  void clear_has_position_std_dev();
  void set_has_orientation_std_dev();
  void clear_has_orientation_std_dev();
  void set_has_linear_velocity_std_dev();
  void clear_has_linear_velocity_std_dev();
  void set_has_linear_acceleration_std_dev();
  void clear_has_linear_acceleration_std_dev();
  void set_has_angular_velocity_std_dev();
  void clear_has_angular_velocity_std_dev();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::atd::common::Point3D* position_std_dev_;
  ::atd::common::Point3D* orientation_std_dev_;
  ::atd::common::Point3D* linear_velocity_std_dev_;
  ::atd::common::Point3D* linear_acceleration_std_dev_;
  ::atd::common::Point3D* angular_velocity_std_dev_;
  friend struct protobuf_modules_2fipc_2fmessage_2fprotobuf_2flocalization_2flocalization_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LocalizationAbsEstimate : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.localization.LocalizationAbsEstimate) */ {
 public:
  LocalizationAbsEstimate();
  virtual ~LocalizationAbsEstimate();

  LocalizationAbsEstimate(const LocalizationAbsEstimate& from);

  inline LocalizationAbsEstimate& operator=(const LocalizationAbsEstimate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const LocalizationAbsEstimate& default_instance();

  static inline const LocalizationAbsEstimate* internal_default_instance() {
    return reinterpret_cast<const LocalizationAbsEstimate*>(
               &_LocalizationAbsEstimate_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(LocalizationAbsEstimate* other);

  // implements Message ----------------------------------------------

  inline LocalizationAbsEstimate* New() const PROTOBUF_FINAL { return New(NULL); }

  LocalizationAbsEstimate* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const LocalizationAbsEstimate& from);
  void MergeFrom(const LocalizationAbsEstimate& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LocalizationAbsEstimate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .atd.common.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::atd::common::Header& header() const;
  ::atd::common::Header* mutable_header();
  ::atd::common::Header* release_header();
  void set_allocated_header(::atd::common::Header* header);

  // optional .atd.common.Reserved reservedmsg = 2;
  bool has_reservedmsg() const;
  void clear_reservedmsg();
  static const int kReservedmsgFieldNumber = 2;
  const ::atd::common::Reserved& reservedmsg() const;
  ::atd::common::Reserved* mutable_reservedmsg();
  ::atd::common::Reserved* release_reservedmsg();
  void set_allocated_reservedmsg(::atd::common::Reserved* reservedmsg);

  // optional .atd.localization.Pose pose = 3;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 3;
  const ::atd::localization::Pose& pose() const;
  ::atd::localization::Pose* mutable_pose();
  ::atd::localization::Pose* release_pose();
  void set_allocated_pose(::atd::localization::Pose* pose);

  // optional .atd.localization.Uncertainty uncertainty = 4;
  bool has_uncertainty() const;
  void clear_uncertainty();
  static const int kUncertaintyFieldNumber = 4;
  const ::atd::localization::Uncertainty& uncertainty() const;
  ::atd::localization::Uncertainty* mutable_uncertainty();
  ::atd::localization::Uncertainty* release_uncertainty();
  void set_allocated_uncertainty(::atd::localization::Uncertainty* uncertainty);

  // optional .atd.localization.Particles uwb = 5;
  bool has_uwb() const;
  void clear_uwb();
  static const int kUwbFieldNumber = 5;
  const ::atd::localization::Particles& uwb() const;
  ::atd::localization::Particles* mutable_uwb();
  ::atd::localization::Particles* release_uwb();
  void set_allocated_uwb(::atd::localization::Particles* uwb);

  // optional .atd.localization.Particles ins = 6;
  bool has_ins() const;
  void clear_ins();
  static const int kInsFieldNumber = 6;
  const ::atd::localization::Particles& ins() const;
  ::atd::localization::Particles* mutable_ins();
  ::atd::localization::Particles* release_ins();
  void set_allocated_ins(::atd::localization::Particles* ins);

  // optional .atd.localization.Particles ofilm = 7;
  bool has_ofilm() const;
  void clear_ofilm();
  static const int kOfilmFieldNumber = 7;
  const ::atd::localization::Particles& ofilm() const;
  ::atd::localization::Particles* mutable_ofilm();
  ::atd::localization::Particles* release_ofilm();
  void set_allocated_ofilm(::atd::localization::Particles* ofilm);

  // optional .atd.localization.Particles locabs = 8;
  bool has_locabs() const;
  void clear_locabs();
  static const int kLocabsFieldNumber = 8;
  const ::atd::localization::Particles& locabs() const;
  ::atd::localization::Particles* mutable_locabs();
  ::atd::localization::Particles* release_locabs();
  void set_allocated_locabs(::atd::localization::Particles* locabs);

  // @@protoc_insertion_point(class_scope:atd.localization.LocalizationAbsEstimate)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_reservedmsg();
  void clear_has_reservedmsg();
  void set_has_pose();
  void clear_has_pose();
  void set_has_uncertainty();
  void clear_has_uncertainty();
  void set_has_uwb();
  void clear_has_uwb();
  void set_has_ins();
  void clear_has_ins();
  void set_has_ofilm();
  void clear_has_ofilm();
  void set_has_locabs();
  void clear_has_locabs();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::atd::common::Header* header_;
  ::atd::common::Reserved* reservedmsg_;
  ::atd::localization::Pose* pose_;
  ::atd::localization::Uncertainty* uncertainty_;
  ::atd::localization::Particles* uwb_;
  ::atd::localization::Particles* ins_;
  ::atd::localization::Particles* ofilm_;
  ::atd::localization::Particles* locabs_;
  friend struct protobuf_modules_2fipc_2fmessage_2fprotobuf_2flocalization_2flocalization_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LocalizationMapMatchEstimate : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.localization.LocalizationMapMatchEstimate) */ {
 public:
  LocalizationMapMatchEstimate();
  virtual ~LocalizationMapMatchEstimate();

  LocalizationMapMatchEstimate(const LocalizationMapMatchEstimate& from);

  inline LocalizationMapMatchEstimate& operator=(const LocalizationMapMatchEstimate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const LocalizationMapMatchEstimate& default_instance();

  static inline const LocalizationMapMatchEstimate* internal_default_instance() {
    return reinterpret_cast<const LocalizationMapMatchEstimate*>(
               &_LocalizationMapMatchEstimate_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(LocalizationMapMatchEstimate* other);

  // implements Message ----------------------------------------------

  inline LocalizationMapMatchEstimate* New() const PROTOBUF_FINAL { return New(NULL); }

  LocalizationMapMatchEstimate* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const LocalizationMapMatchEstimate& from);
  void MergeFrom(const LocalizationMapMatchEstimate& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LocalizationMapMatchEstimate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .atd.common.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::atd::common::Header& header() const;
  ::atd::common::Header* mutable_header();
  ::atd::common::Header* release_header();
  void set_allocated_header(::atd::common::Header* header);

  // optional .atd.common.Reserved reservedmsg = 2;
  bool has_reservedmsg() const;
  void clear_reservedmsg();
  static const int kReservedmsgFieldNumber = 2;
  const ::atd::common::Reserved& reservedmsg() const;
  ::atd::common::Reserved* mutable_reservedmsg();
  ::atd::common::Reserved* release_reservedmsg();
  void set_allocated_reservedmsg(::atd::common::Reserved* reservedmsg);

  // optional .atd.localization.Pose pose = 3;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 3;
  const ::atd::localization::Pose& pose() const;
  ::atd::localization::Pose* mutable_pose();
  ::atd::localization::Pose* release_pose();
  void set_allocated_pose(::atd::localization::Pose* pose);

  // optional .atd.localization.Uncertainty uncertainty = 4;
  bool has_uncertainty() const;
  void clear_uncertainty();
  static const int kUncertaintyFieldNumber = 4;
  const ::atd::localization::Uncertainty& uncertainty() const;
  ::atd::localization::Uncertainty* mutable_uncertainty();
  ::atd::localization::Uncertainty* release_uncertainty();
  void set_allocated_uncertainty(::atd::localization::Uncertainty* uncertainty);

  // optional .atd.localization.Particles histraj = 5;
  bool has_histraj() const;
  void clear_histraj();
  static const int kHistrajFieldNumber = 5;
  const ::atd::localization::Particles& histraj() const;
  ::atd::localization::Particles* mutable_histraj();
  ::atd::localization::Particles* release_histraj();
  void set_allocated_histraj(::atd::localization::Particles* histraj);

  // optional .atd.localization.Particles grid = 6;
  bool has_grid() const;
  void clear_grid();
  static const int kGridFieldNumber = 6;
  const ::atd::localization::Particles& grid() const;
  ::atd::localization::Particles* mutable_grid();
  ::atd::localization::Particles* release_grid();
  void set_allocated_grid(::atd::localization::Particles* grid);

  // @@protoc_insertion_point(class_scope:atd.localization.LocalizationMapMatchEstimate)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_reservedmsg();
  void clear_has_reservedmsg();
  void set_has_pose();
  void clear_has_pose();
  void set_has_uncertainty();
  void clear_has_uncertainty();
  void set_has_histraj();
  void clear_has_histraj();
  void set_has_grid();
  void clear_has_grid();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::atd::common::Header* header_;
  ::atd::common::Reserved* reservedmsg_;
  ::atd::localization::Pose* pose_;
  ::atd::localization::Uncertainty* uncertainty_;
  ::atd::localization::Particles* histraj_;
  ::atd::localization::Particles* grid_;
  friend struct protobuf_modules_2fipc_2fmessage_2fprotobuf_2flocalization_2flocalization_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LocalizationEstimate : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.localization.LocalizationEstimate) */ {
 public:
  LocalizationEstimate();
  virtual ~LocalizationEstimate();

  LocalizationEstimate(const LocalizationEstimate& from);

  inline LocalizationEstimate& operator=(const LocalizationEstimate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const LocalizationEstimate& default_instance();

  static inline const LocalizationEstimate* internal_default_instance() {
    return reinterpret_cast<const LocalizationEstimate*>(
               &_LocalizationEstimate_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(LocalizationEstimate* other);

  // implements Message ----------------------------------------------

  inline LocalizationEstimate* New() const PROTOBUF_FINAL { return New(NULL); }

  LocalizationEstimate* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const LocalizationEstimate& from);
  void MergeFrom(const LocalizationEstimate& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LocalizationEstimate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .atd.common.TrajectoryPoint trajectory_point = 6;
  int trajectory_point_size() const;
  void clear_trajectory_point();
  static const int kTrajectoryPointFieldNumber = 6;
  const ::atd::common::TrajectoryPoint& trajectory_point(int index) const;
  ::atd::common::TrajectoryPoint* mutable_trajectory_point(int index);
  ::atd::common::TrajectoryPoint* add_trajectory_point();
  ::google::protobuf::RepeatedPtrField< ::atd::common::TrajectoryPoint >*
      mutable_trajectory_point();
  const ::google::protobuf::RepeatedPtrField< ::atd::common::TrajectoryPoint >&
      trajectory_point() const;

  // optional .atd.common.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::atd::common::Header& header() const;
  ::atd::common::Header* mutable_header();
  ::atd::common::Header* release_header();
  void set_allocated_header(::atd::common::Header* header);

  // optional .atd.common.Reserved reservedmsg = 2;
  bool has_reservedmsg() const;
  void clear_reservedmsg();
  static const int kReservedmsgFieldNumber = 2;
  const ::atd::common::Reserved& reservedmsg() const;
  ::atd::common::Reserved* mutable_reservedmsg();
  ::atd::common::Reserved* release_reservedmsg();
  void set_allocated_reservedmsg(::atd::common::Reserved* reservedmsg);

  // optional .atd.localization.Pose pose = 3;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 3;
  const ::atd::localization::Pose& pose() const;
  ::atd::localization::Pose* mutable_pose();
  ::atd::localization::Pose* release_pose();
  void set_allocated_pose(::atd::localization::Pose* pose);

  // optional .atd.localization.Uncertainty uncertainty = 4;
  bool has_uncertainty() const;
  void clear_uncertainty();
  static const int kUncertaintyFieldNumber = 4;
  const ::atd::localization::Uncertainty& uncertainty() const;
  ::atd::localization::Uncertainty* mutable_uncertainty();
  ::atd::localization::Uncertainty* release_uncertainty();
  void set_allocated_uncertainty(::atd::localization::Uncertainty* uncertainty);

  // optional .atd.localization.Particles particles = 5;
  bool has_particles() const;
  void clear_particles();
  static const int kParticlesFieldNumber = 5;
  const ::atd::localization::Particles& particles() const;
  ::atd::localization::Particles* mutable_particles();
  ::atd::localization::Particles* release_particles();
  void set_allocated_particles(::atd::localization::Particles* particles);

  // @@protoc_insertion_point(class_scope:atd.localization.LocalizationEstimate)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_reservedmsg();
  void clear_has_reservedmsg();
  void set_has_pose();
  void clear_has_pose();
  void set_has_uncertainty();
  void clear_has_uncertainty();
  void set_has_particles();
  void clear_has_particles();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::atd::common::TrajectoryPoint > trajectory_point_;
  ::atd::common::Header* header_;
  ::atd::common::Reserved* reservedmsg_;
  ::atd::localization::Pose* pose_;
  ::atd::localization::Uncertainty* uncertainty_;
  ::atd::localization::Particles* particles_;
  friend struct protobuf_modules_2fipc_2fmessage_2fprotobuf_2flocalization_2flocalization_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Particle : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.localization.Particle) */ {
 public:
  Particle();
  virtual ~Particle();

  Particle(const Particle& from);

  inline Particle& operator=(const Particle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Particle& default_instance();

  static inline const Particle* internal_default_instance() {
    return reinterpret_cast<const Particle*>(
               &_Particle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Particle* other);

  // implements Message ----------------------------------------------

  inline Particle* New() const PROTOBUF_FINAL { return New(NULL); }

  Particle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Particle& from);
  void MergeFrom(const Particle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Particle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .atd.common.Arrow2D arrow = 1;
  bool has_arrow() const;
  void clear_arrow();
  static const int kArrowFieldNumber = 1;
  const ::atd::common::Arrow2D& arrow() const;
  ::atd::common::Arrow2D* mutable_arrow();
  ::atd::common::Arrow2D* release_arrow();
  void set_allocated_arrow(::atd::common::Arrow2D* arrow);

  // optional .atd.localization.Pose pose = 2;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 2;
  const ::atd::localization::Pose& pose() const;
  ::atd::localization::Pose* mutable_pose();
  ::atd::localization::Pose* release_pose();
  void set_allocated_pose(::atd::localization::Pose* pose);

  // optional float score = 3;
  bool has_score() const;
  void clear_score();
  static const int kScoreFieldNumber = 3;
  float score() const;
  void set_score(float value);

  // optional float weight = 4;
  bool has_weight() const;
  void clear_weight();
  static const int kWeightFieldNumber = 4;
  float weight() const;
  void set_weight(float value);

  // @@protoc_insertion_point(class_scope:atd.localization.Particle)
 private:
  void set_has_arrow();
  void clear_has_arrow();
  void set_has_pose();
  void clear_has_pose();
  void set_has_score();
  void clear_has_score();
  void set_has_weight();
  void clear_has_weight();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::atd::common::Arrow2D* arrow_;
  ::atd::localization::Pose* pose_;
  float score_;
  float weight_;
  friend struct protobuf_modules_2fipc_2fmessage_2fprotobuf_2flocalization_2flocalization_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Particles : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.localization.Particles) */ {
 public:
  Particles();
  virtual ~Particles();

  Particles(const Particles& from);

  inline Particles& operator=(const Particles& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Particles& default_instance();

  static inline const Particles* internal_default_instance() {
    return reinterpret_cast<const Particles*>(
               &_Particles_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Particles* other);

  // implements Message ----------------------------------------------

  inline Particles* New() const PROTOBUF_FINAL { return New(NULL); }

  Particles* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Particles& from);
  void MergeFrom(const Particles& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Particles* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .atd.localization.Particle particle = 7;
  int particle_size() const;
  void clear_particle();
  static const int kParticleFieldNumber = 7;
  const ::atd::localization::Particle& particle(int index) const;
  ::atd::localization::Particle* mutable_particle(int index);
  ::atd::localization::Particle* add_particle();
  ::google::protobuf::RepeatedPtrField< ::atd::localization::Particle >*
      mutable_particle();
  const ::google::protobuf::RepeatedPtrField< ::atd::localization::Particle >&
      particle() const;

  // optional string layername = 1;
  bool has_layername() const;
  void clear_layername();
  static const int kLayernameFieldNumber = 1;
  const ::std::string& layername() const;
  void set_layername(const ::std::string& value);
  #if LANG_CXX11
  void set_layername(::std::string&& value);
  #endif
  void set_layername(const char* value);
  void set_layername(const char* value, size_t size);
  ::std::string* mutable_layername();
  ::std::string* release_layername();
  void set_allocated_layername(::std::string* layername);

  // optional float meanscore = 2;
  bool has_meanscore() const;
  void clear_meanscore();
  static const int kMeanscoreFieldNumber = 2;
  float meanscore() const;
  void set_meanscore(float value);

  // optional float belief = 3;
  bool has_belief() const;
  void clear_belief();
  static const int kBeliefFieldNumber = 3;
  float belief() const;
  void set_belief(float value);

  // optional fixed32 colorR = 4;
  bool has_colorr() const;
  void clear_colorr();
  static const int kColorRFieldNumber = 4;
  ::google::protobuf::uint32 colorr() const;
  void set_colorr(::google::protobuf::uint32 value);

  // optional fixed32 colorG = 5;
  bool has_colorg() const;
  void clear_colorg();
  static const int kColorGFieldNumber = 5;
  ::google::protobuf::uint32 colorg() const;
  void set_colorg(::google::protobuf::uint32 value);

  // optional fixed32 colorB = 6;
  bool has_colorb() const;
  void clear_colorb();
  static const int kColorBFieldNumber = 6;
  ::google::protobuf::uint32 colorb() const;
  void set_colorb(::google::protobuf::uint32 value);

  // optional .atd.localization.MeasureState layerState = 9;
  bool has_layerstate() const;
  void clear_layerstate();
  static const int kLayerStateFieldNumber = 9;
  ::atd::localization::MeasureState layerstate() const;
  void set_layerstate(::atd::localization::MeasureState value);

  // @@protoc_insertion_point(class_scope:atd.localization.Particles)
 private:
  void set_has_layername();
  void clear_has_layername();
  void set_has_meanscore();
  void clear_has_meanscore();
  void set_has_belief();
  void clear_has_belief();
  void set_has_colorr();
  void clear_has_colorr();
  void set_has_colorg();
  void clear_has_colorg();
  void set_has_colorb();
  void clear_has_colorb();
  void set_has_layerstate();
  void clear_has_layerstate();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::atd::localization::Particle > particle_;
  ::google::protobuf::internal::ArenaStringPtr layername_;
  float meanscore_;
  float belief_;
  ::google::protobuf::uint32 colorr_;
  ::google::protobuf::uint32 colorg_;
  ::google::protobuf::uint32 colorb_;
  int layerstate_;
  friend struct protobuf_modules_2fipc_2fmessage_2fprotobuf_2flocalization_2flocalization_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Particles_Collection : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.localization.Particles_Collection) */ {
 public:
  Particles_Collection();
  virtual ~Particles_Collection();

  Particles_Collection(const Particles_Collection& from);

  inline Particles_Collection& operator=(const Particles_Collection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Particles_Collection& default_instance();

  static inline const Particles_Collection* internal_default_instance() {
    return reinterpret_cast<const Particles_Collection*>(
               &_Particles_Collection_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Particles_Collection* other);

  // implements Message ----------------------------------------------

  inline Particles_Collection* New() const PROTOBUF_FINAL { return New(NULL); }

  Particles_Collection* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Particles_Collection& from);
  void MergeFrom(const Particles_Collection& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Particles_Collection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .atd.localization.Particles particles = 3;
  int particles_size() const;
  void clear_particles();
  static const int kParticlesFieldNumber = 3;
  const ::atd::localization::Particles& particles(int index) const;
  ::atd::localization::Particles* mutable_particles(int index);
  ::atd::localization::Particles* add_particles();
  ::google::protobuf::RepeatedPtrField< ::atd::localization::Particles >*
      mutable_particles();
  const ::google::protobuf::RepeatedPtrField< ::atd::localization::Particles >&
      particles() const;

  // optional .atd.common.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::atd::common::Header& header() const;
  ::atd::common::Header* mutable_header();
  ::atd::common::Header* release_header();
  void set_allocated_header(::atd::common::Header* header);

  // optional .atd.common.Reserved reservedmsg = 2;
  bool has_reservedmsg() const;
  void clear_reservedmsg();
  static const int kReservedmsgFieldNumber = 2;
  const ::atd::common::Reserved& reservedmsg() const;
  ::atd::common::Reserved* mutable_reservedmsg();
  ::atd::common::Reserved* release_reservedmsg();
  void set_allocated_reservedmsg(::atd::common::Reserved* reservedmsg);

  // @@protoc_insertion_point(class_scope:atd.localization.Particles_Collection)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_reservedmsg();
  void clear_has_reservedmsg();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::atd::localization::Particles > particles_;
  ::atd::common::Header* header_;
  ::atd::common::Reserved* reservedmsg_;
  friend struct protobuf_modules_2fipc_2fmessage_2fprotobuf_2flocalization_2flocalization_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Uncertainty

// optional .atd.common.Point3D position_std_dev = 1;
inline bool Uncertainty::has_position_std_dev() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Uncertainty::set_has_position_std_dev() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Uncertainty::clear_has_position_std_dev() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Uncertainty::clear_position_std_dev() {
  if (position_std_dev_ != NULL) position_std_dev_->::atd::common::Point3D::Clear();
  clear_has_position_std_dev();
}
inline const ::atd::common::Point3D& Uncertainty::position_std_dev() const {
  // @@protoc_insertion_point(field_get:atd.localization.Uncertainty.position_std_dev)
  return position_std_dev_ != NULL ? *position_std_dev_
                         : *::atd::common::Point3D::internal_default_instance();
}
inline ::atd::common::Point3D* Uncertainty::mutable_position_std_dev() {
  set_has_position_std_dev();
  if (position_std_dev_ == NULL) {
    position_std_dev_ = new ::atd::common::Point3D;
  }
  // @@protoc_insertion_point(field_mutable:atd.localization.Uncertainty.position_std_dev)
  return position_std_dev_;
}
inline ::atd::common::Point3D* Uncertainty::release_position_std_dev() {
  // @@protoc_insertion_point(field_release:atd.localization.Uncertainty.position_std_dev)
  clear_has_position_std_dev();
  ::atd::common::Point3D* temp = position_std_dev_;
  position_std_dev_ = NULL;
  return temp;
}
inline void Uncertainty::set_allocated_position_std_dev(::atd::common::Point3D* position_std_dev) {
  delete position_std_dev_;
  position_std_dev_ = position_std_dev;
  if (position_std_dev) {
    set_has_position_std_dev();
  } else {
    clear_has_position_std_dev();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.localization.Uncertainty.position_std_dev)
}

// optional .atd.common.Point3D orientation_std_dev = 2;
inline bool Uncertainty::has_orientation_std_dev() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Uncertainty::set_has_orientation_std_dev() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Uncertainty::clear_has_orientation_std_dev() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Uncertainty::clear_orientation_std_dev() {
  if (orientation_std_dev_ != NULL) orientation_std_dev_->::atd::common::Point3D::Clear();
  clear_has_orientation_std_dev();
}
inline const ::atd::common::Point3D& Uncertainty::orientation_std_dev() const {
  // @@protoc_insertion_point(field_get:atd.localization.Uncertainty.orientation_std_dev)
  return orientation_std_dev_ != NULL ? *orientation_std_dev_
                         : *::atd::common::Point3D::internal_default_instance();
}
inline ::atd::common::Point3D* Uncertainty::mutable_orientation_std_dev() {
  set_has_orientation_std_dev();
  if (orientation_std_dev_ == NULL) {
    orientation_std_dev_ = new ::atd::common::Point3D;
  }
  // @@protoc_insertion_point(field_mutable:atd.localization.Uncertainty.orientation_std_dev)
  return orientation_std_dev_;
}
inline ::atd::common::Point3D* Uncertainty::release_orientation_std_dev() {
  // @@protoc_insertion_point(field_release:atd.localization.Uncertainty.orientation_std_dev)
  clear_has_orientation_std_dev();
  ::atd::common::Point3D* temp = orientation_std_dev_;
  orientation_std_dev_ = NULL;
  return temp;
}
inline void Uncertainty::set_allocated_orientation_std_dev(::atd::common::Point3D* orientation_std_dev) {
  delete orientation_std_dev_;
  orientation_std_dev_ = orientation_std_dev;
  if (orientation_std_dev) {
    set_has_orientation_std_dev();
  } else {
    clear_has_orientation_std_dev();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.localization.Uncertainty.orientation_std_dev)
}

// optional .atd.common.Point3D linear_velocity_std_dev = 3;
inline bool Uncertainty::has_linear_velocity_std_dev() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Uncertainty::set_has_linear_velocity_std_dev() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Uncertainty::clear_has_linear_velocity_std_dev() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Uncertainty::clear_linear_velocity_std_dev() {
  if (linear_velocity_std_dev_ != NULL) linear_velocity_std_dev_->::atd::common::Point3D::Clear();
  clear_has_linear_velocity_std_dev();
}
inline const ::atd::common::Point3D& Uncertainty::linear_velocity_std_dev() const {
  // @@protoc_insertion_point(field_get:atd.localization.Uncertainty.linear_velocity_std_dev)
  return linear_velocity_std_dev_ != NULL ? *linear_velocity_std_dev_
                         : *::atd::common::Point3D::internal_default_instance();
}
inline ::atd::common::Point3D* Uncertainty::mutable_linear_velocity_std_dev() {
  set_has_linear_velocity_std_dev();
  if (linear_velocity_std_dev_ == NULL) {
    linear_velocity_std_dev_ = new ::atd::common::Point3D;
  }
  // @@protoc_insertion_point(field_mutable:atd.localization.Uncertainty.linear_velocity_std_dev)
  return linear_velocity_std_dev_;
}
inline ::atd::common::Point3D* Uncertainty::release_linear_velocity_std_dev() {
  // @@protoc_insertion_point(field_release:atd.localization.Uncertainty.linear_velocity_std_dev)
  clear_has_linear_velocity_std_dev();
  ::atd::common::Point3D* temp = linear_velocity_std_dev_;
  linear_velocity_std_dev_ = NULL;
  return temp;
}
inline void Uncertainty::set_allocated_linear_velocity_std_dev(::atd::common::Point3D* linear_velocity_std_dev) {
  delete linear_velocity_std_dev_;
  linear_velocity_std_dev_ = linear_velocity_std_dev;
  if (linear_velocity_std_dev) {
    set_has_linear_velocity_std_dev();
  } else {
    clear_has_linear_velocity_std_dev();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.localization.Uncertainty.linear_velocity_std_dev)
}

// optional .atd.common.Point3D linear_acceleration_std_dev = 4;
inline bool Uncertainty::has_linear_acceleration_std_dev() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Uncertainty::set_has_linear_acceleration_std_dev() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Uncertainty::clear_has_linear_acceleration_std_dev() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Uncertainty::clear_linear_acceleration_std_dev() {
  if (linear_acceleration_std_dev_ != NULL) linear_acceleration_std_dev_->::atd::common::Point3D::Clear();
  clear_has_linear_acceleration_std_dev();
}
inline const ::atd::common::Point3D& Uncertainty::linear_acceleration_std_dev() const {
  // @@protoc_insertion_point(field_get:atd.localization.Uncertainty.linear_acceleration_std_dev)
  return linear_acceleration_std_dev_ != NULL ? *linear_acceleration_std_dev_
                         : *::atd::common::Point3D::internal_default_instance();
}
inline ::atd::common::Point3D* Uncertainty::mutable_linear_acceleration_std_dev() {
  set_has_linear_acceleration_std_dev();
  if (linear_acceleration_std_dev_ == NULL) {
    linear_acceleration_std_dev_ = new ::atd::common::Point3D;
  }
  // @@protoc_insertion_point(field_mutable:atd.localization.Uncertainty.linear_acceleration_std_dev)
  return linear_acceleration_std_dev_;
}
inline ::atd::common::Point3D* Uncertainty::release_linear_acceleration_std_dev() {
  // @@protoc_insertion_point(field_release:atd.localization.Uncertainty.linear_acceleration_std_dev)
  clear_has_linear_acceleration_std_dev();
  ::atd::common::Point3D* temp = linear_acceleration_std_dev_;
  linear_acceleration_std_dev_ = NULL;
  return temp;
}
inline void Uncertainty::set_allocated_linear_acceleration_std_dev(::atd::common::Point3D* linear_acceleration_std_dev) {
  delete linear_acceleration_std_dev_;
  linear_acceleration_std_dev_ = linear_acceleration_std_dev;
  if (linear_acceleration_std_dev) {
    set_has_linear_acceleration_std_dev();
  } else {
    clear_has_linear_acceleration_std_dev();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.localization.Uncertainty.linear_acceleration_std_dev)
}

// optional .atd.common.Point3D angular_velocity_std_dev = 5;
inline bool Uncertainty::has_angular_velocity_std_dev() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Uncertainty::set_has_angular_velocity_std_dev() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Uncertainty::clear_has_angular_velocity_std_dev() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Uncertainty::clear_angular_velocity_std_dev() {
  if (angular_velocity_std_dev_ != NULL) angular_velocity_std_dev_->::atd::common::Point3D::Clear();
  clear_has_angular_velocity_std_dev();
}
inline const ::atd::common::Point3D& Uncertainty::angular_velocity_std_dev() const {
  // @@protoc_insertion_point(field_get:atd.localization.Uncertainty.angular_velocity_std_dev)
  return angular_velocity_std_dev_ != NULL ? *angular_velocity_std_dev_
                         : *::atd::common::Point3D::internal_default_instance();
}
inline ::atd::common::Point3D* Uncertainty::mutable_angular_velocity_std_dev() {
  set_has_angular_velocity_std_dev();
  if (angular_velocity_std_dev_ == NULL) {
    angular_velocity_std_dev_ = new ::atd::common::Point3D;
  }
  // @@protoc_insertion_point(field_mutable:atd.localization.Uncertainty.angular_velocity_std_dev)
  return angular_velocity_std_dev_;
}
inline ::atd::common::Point3D* Uncertainty::release_angular_velocity_std_dev() {
  // @@protoc_insertion_point(field_release:atd.localization.Uncertainty.angular_velocity_std_dev)
  clear_has_angular_velocity_std_dev();
  ::atd::common::Point3D* temp = angular_velocity_std_dev_;
  angular_velocity_std_dev_ = NULL;
  return temp;
}
inline void Uncertainty::set_allocated_angular_velocity_std_dev(::atd::common::Point3D* angular_velocity_std_dev) {
  delete angular_velocity_std_dev_;
  angular_velocity_std_dev_ = angular_velocity_std_dev;
  if (angular_velocity_std_dev) {
    set_has_angular_velocity_std_dev();
  } else {
    clear_has_angular_velocity_std_dev();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.localization.Uncertainty.angular_velocity_std_dev)
}

// -------------------------------------------------------------------

// LocalizationAbsEstimate

// optional .atd.common.Header header = 1;
inline bool LocalizationAbsEstimate::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocalizationAbsEstimate::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocalizationAbsEstimate::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocalizationAbsEstimate::clear_header() {
  if (header_ != NULL) header_->::atd::common::Header::Clear();
  clear_has_header();
}
inline const ::atd::common::Header& LocalizationAbsEstimate::header() const {
  // @@protoc_insertion_point(field_get:atd.localization.LocalizationAbsEstimate.header)
  return header_ != NULL ? *header_
                         : *::atd::common::Header::internal_default_instance();
}
inline ::atd::common::Header* LocalizationAbsEstimate::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::atd::common::Header;
  }
  // @@protoc_insertion_point(field_mutable:atd.localization.LocalizationAbsEstimate.header)
  return header_;
}
inline ::atd::common::Header* LocalizationAbsEstimate::release_header() {
  // @@protoc_insertion_point(field_release:atd.localization.LocalizationAbsEstimate.header)
  clear_has_header();
  ::atd::common::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void LocalizationAbsEstimate::set_allocated_header(::atd::common::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.localization.LocalizationAbsEstimate.header)
}

// optional .atd.common.Reserved reservedmsg = 2;
inline bool LocalizationAbsEstimate::has_reservedmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocalizationAbsEstimate::set_has_reservedmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocalizationAbsEstimate::clear_has_reservedmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocalizationAbsEstimate::clear_reservedmsg() {
  if (reservedmsg_ != NULL) reservedmsg_->::atd::common::Reserved::Clear();
  clear_has_reservedmsg();
}
inline const ::atd::common::Reserved& LocalizationAbsEstimate::reservedmsg() const {
  // @@protoc_insertion_point(field_get:atd.localization.LocalizationAbsEstimate.reservedmsg)
  return reservedmsg_ != NULL ? *reservedmsg_
                         : *::atd::common::Reserved::internal_default_instance();
}
inline ::atd::common::Reserved* LocalizationAbsEstimate::mutable_reservedmsg() {
  set_has_reservedmsg();
  if (reservedmsg_ == NULL) {
    reservedmsg_ = new ::atd::common::Reserved;
  }
  // @@protoc_insertion_point(field_mutable:atd.localization.LocalizationAbsEstimate.reservedmsg)
  return reservedmsg_;
}
inline ::atd::common::Reserved* LocalizationAbsEstimate::release_reservedmsg() {
  // @@protoc_insertion_point(field_release:atd.localization.LocalizationAbsEstimate.reservedmsg)
  clear_has_reservedmsg();
  ::atd::common::Reserved* temp = reservedmsg_;
  reservedmsg_ = NULL;
  return temp;
}
inline void LocalizationAbsEstimate::set_allocated_reservedmsg(::atd::common::Reserved* reservedmsg) {
  delete reservedmsg_;
  reservedmsg_ = reservedmsg;
  if (reservedmsg) {
    set_has_reservedmsg();
  } else {
    clear_has_reservedmsg();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.localization.LocalizationAbsEstimate.reservedmsg)
}

// optional .atd.localization.Pose pose = 3;
inline bool LocalizationAbsEstimate::has_pose() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocalizationAbsEstimate::set_has_pose() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocalizationAbsEstimate::clear_has_pose() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LocalizationAbsEstimate::clear_pose() {
  if (pose_ != NULL) pose_->::atd::localization::Pose::Clear();
  clear_has_pose();
}
inline const ::atd::localization::Pose& LocalizationAbsEstimate::pose() const {
  // @@protoc_insertion_point(field_get:atd.localization.LocalizationAbsEstimate.pose)
  return pose_ != NULL ? *pose_
                         : *::atd::localization::Pose::internal_default_instance();
}
inline ::atd::localization::Pose* LocalizationAbsEstimate::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) {
    pose_ = new ::atd::localization::Pose;
  }
  // @@protoc_insertion_point(field_mutable:atd.localization.LocalizationAbsEstimate.pose)
  return pose_;
}
inline ::atd::localization::Pose* LocalizationAbsEstimate::release_pose() {
  // @@protoc_insertion_point(field_release:atd.localization.LocalizationAbsEstimate.pose)
  clear_has_pose();
  ::atd::localization::Pose* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline void LocalizationAbsEstimate::set_allocated_pose(::atd::localization::Pose* pose) {
  delete pose_;
  pose_ = pose;
  if (pose) {
    set_has_pose();
  } else {
    clear_has_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.localization.LocalizationAbsEstimate.pose)
}

// optional .atd.localization.Uncertainty uncertainty = 4;
inline bool LocalizationAbsEstimate::has_uncertainty() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LocalizationAbsEstimate::set_has_uncertainty() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LocalizationAbsEstimate::clear_has_uncertainty() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LocalizationAbsEstimate::clear_uncertainty() {
  if (uncertainty_ != NULL) uncertainty_->::atd::localization::Uncertainty::Clear();
  clear_has_uncertainty();
}
inline const ::atd::localization::Uncertainty& LocalizationAbsEstimate::uncertainty() const {
  // @@protoc_insertion_point(field_get:atd.localization.LocalizationAbsEstimate.uncertainty)
  return uncertainty_ != NULL ? *uncertainty_
                         : *::atd::localization::Uncertainty::internal_default_instance();
}
inline ::atd::localization::Uncertainty* LocalizationAbsEstimate::mutable_uncertainty() {
  set_has_uncertainty();
  if (uncertainty_ == NULL) {
    uncertainty_ = new ::atd::localization::Uncertainty;
  }
  // @@protoc_insertion_point(field_mutable:atd.localization.LocalizationAbsEstimate.uncertainty)
  return uncertainty_;
}
inline ::atd::localization::Uncertainty* LocalizationAbsEstimate::release_uncertainty() {
  // @@protoc_insertion_point(field_release:atd.localization.LocalizationAbsEstimate.uncertainty)
  clear_has_uncertainty();
  ::atd::localization::Uncertainty* temp = uncertainty_;
  uncertainty_ = NULL;
  return temp;
}
inline void LocalizationAbsEstimate::set_allocated_uncertainty(::atd::localization::Uncertainty* uncertainty) {
  delete uncertainty_;
  uncertainty_ = uncertainty;
  if (uncertainty) {
    set_has_uncertainty();
  } else {
    clear_has_uncertainty();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.localization.LocalizationAbsEstimate.uncertainty)
}

// optional .atd.localization.Particles uwb = 5;
inline bool LocalizationAbsEstimate::has_uwb() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LocalizationAbsEstimate::set_has_uwb() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LocalizationAbsEstimate::clear_has_uwb() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LocalizationAbsEstimate::clear_uwb() {
  if (uwb_ != NULL) uwb_->::atd::localization::Particles::Clear();
  clear_has_uwb();
}
inline const ::atd::localization::Particles& LocalizationAbsEstimate::uwb() const {
  // @@protoc_insertion_point(field_get:atd.localization.LocalizationAbsEstimate.uwb)
  return uwb_ != NULL ? *uwb_
                         : *::atd::localization::Particles::internal_default_instance();
}
inline ::atd::localization::Particles* LocalizationAbsEstimate::mutable_uwb() {
  set_has_uwb();
  if (uwb_ == NULL) {
    uwb_ = new ::atd::localization::Particles;
  }
  // @@protoc_insertion_point(field_mutable:atd.localization.LocalizationAbsEstimate.uwb)
  return uwb_;
}
inline ::atd::localization::Particles* LocalizationAbsEstimate::release_uwb() {
  // @@protoc_insertion_point(field_release:atd.localization.LocalizationAbsEstimate.uwb)
  clear_has_uwb();
  ::atd::localization::Particles* temp = uwb_;
  uwb_ = NULL;
  return temp;
}
inline void LocalizationAbsEstimate::set_allocated_uwb(::atd::localization::Particles* uwb) {
  delete uwb_;
  uwb_ = uwb;
  if (uwb) {
    set_has_uwb();
  } else {
    clear_has_uwb();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.localization.LocalizationAbsEstimate.uwb)
}

// optional .atd.localization.Particles ins = 6;
inline bool LocalizationAbsEstimate::has_ins() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LocalizationAbsEstimate::set_has_ins() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LocalizationAbsEstimate::clear_has_ins() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LocalizationAbsEstimate::clear_ins() {
  if (ins_ != NULL) ins_->::atd::localization::Particles::Clear();
  clear_has_ins();
}
inline const ::atd::localization::Particles& LocalizationAbsEstimate::ins() const {
  // @@protoc_insertion_point(field_get:atd.localization.LocalizationAbsEstimate.ins)
  return ins_ != NULL ? *ins_
                         : *::atd::localization::Particles::internal_default_instance();
}
inline ::atd::localization::Particles* LocalizationAbsEstimate::mutable_ins() {
  set_has_ins();
  if (ins_ == NULL) {
    ins_ = new ::atd::localization::Particles;
  }
  // @@protoc_insertion_point(field_mutable:atd.localization.LocalizationAbsEstimate.ins)
  return ins_;
}
inline ::atd::localization::Particles* LocalizationAbsEstimate::release_ins() {
  // @@protoc_insertion_point(field_release:atd.localization.LocalizationAbsEstimate.ins)
  clear_has_ins();
  ::atd::localization::Particles* temp = ins_;
  ins_ = NULL;
  return temp;
}
inline void LocalizationAbsEstimate::set_allocated_ins(::atd::localization::Particles* ins) {
  delete ins_;
  ins_ = ins;
  if (ins) {
    set_has_ins();
  } else {
    clear_has_ins();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.localization.LocalizationAbsEstimate.ins)
}

// optional .atd.localization.Particles ofilm = 7;
inline bool LocalizationAbsEstimate::has_ofilm() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LocalizationAbsEstimate::set_has_ofilm() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LocalizationAbsEstimate::clear_has_ofilm() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LocalizationAbsEstimate::clear_ofilm() {
  if (ofilm_ != NULL) ofilm_->::atd::localization::Particles::Clear();
  clear_has_ofilm();
}
inline const ::atd::localization::Particles& LocalizationAbsEstimate::ofilm() const {
  // @@protoc_insertion_point(field_get:atd.localization.LocalizationAbsEstimate.ofilm)
  return ofilm_ != NULL ? *ofilm_
                         : *::atd::localization::Particles::internal_default_instance();
}
inline ::atd::localization::Particles* LocalizationAbsEstimate::mutable_ofilm() {
  set_has_ofilm();
  if (ofilm_ == NULL) {
    ofilm_ = new ::atd::localization::Particles;
  }
  // @@protoc_insertion_point(field_mutable:atd.localization.LocalizationAbsEstimate.ofilm)
  return ofilm_;
}
inline ::atd::localization::Particles* LocalizationAbsEstimate::release_ofilm() {
  // @@protoc_insertion_point(field_release:atd.localization.LocalizationAbsEstimate.ofilm)
  clear_has_ofilm();
  ::atd::localization::Particles* temp = ofilm_;
  ofilm_ = NULL;
  return temp;
}
inline void LocalizationAbsEstimate::set_allocated_ofilm(::atd::localization::Particles* ofilm) {
  delete ofilm_;
  ofilm_ = ofilm;
  if (ofilm) {
    set_has_ofilm();
  } else {
    clear_has_ofilm();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.localization.LocalizationAbsEstimate.ofilm)
}

// optional .atd.localization.Particles locabs = 8;
inline bool LocalizationAbsEstimate::has_locabs() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LocalizationAbsEstimate::set_has_locabs() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LocalizationAbsEstimate::clear_has_locabs() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LocalizationAbsEstimate::clear_locabs() {
  if (locabs_ != NULL) locabs_->::atd::localization::Particles::Clear();
  clear_has_locabs();
}
inline const ::atd::localization::Particles& LocalizationAbsEstimate::locabs() const {
  // @@protoc_insertion_point(field_get:atd.localization.LocalizationAbsEstimate.locabs)
  return locabs_ != NULL ? *locabs_
                         : *::atd::localization::Particles::internal_default_instance();
}
inline ::atd::localization::Particles* LocalizationAbsEstimate::mutable_locabs() {
  set_has_locabs();
  if (locabs_ == NULL) {
    locabs_ = new ::atd::localization::Particles;
  }
  // @@protoc_insertion_point(field_mutable:atd.localization.LocalizationAbsEstimate.locabs)
  return locabs_;
}
inline ::atd::localization::Particles* LocalizationAbsEstimate::release_locabs() {
  // @@protoc_insertion_point(field_release:atd.localization.LocalizationAbsEstimate.locabs)
  clear_has_locabs();
  ::atd::localization::Particles* temp = locabs_;
  locabs_ = NULL;
  return temp;
}
inline void LocalizationAbsEstimate::set_allocated_locabs(::atd::localization::Particles* locabs) {
  delete locabs_;
  locabs_ = locabs;
  if (locabs) {
    set_has_locabs();
  } else {
    clear_has_locabs();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.localization.LocalizationAbsEstimate.locabs)
}

// -------------------------------------------------------------------

// LocalizationMapMatchEstimate

// optional .atd.common.Header header = 1;
inline bool LocalizationMapMatchEstimate::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocalizationMapMatchEstimate::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocalizationMapMatchEstimate::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocalizationMapMatchEstimate::clear_header() {
  if (header_ != NULL) header_->::atd::common::Header::Clear();
  clear_has_header();
}
inline const ::atd::common::Header& LocalizationMapMatchEstimate::header() const {
  // @@protoc_insertion_point(field_get:atd.localization.LocalizationMapMatchEstimate.header)
  return header_ != NULL ? *header_
                         : *::atd::common::Header::internal_default_instance();
}
inline ::atd::common::Header* LocalizationMapMatchEstimate::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::atd::common::Header;
  }
  // @@protoc_insertion_point(field_mutable:atd.localization.LocalizationMapMatchEstimate.header)
  return header_;
}
inline ::atd::common::Header* LocalizationMapMatchEstimate::release_header() {
  // @@protoc_insertion_point(field_release:atd.localization.LocalizationMapMatchEstimate.header)
  clear_has_header();
  ::atd::common::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void LocalizationMapMatchEstimate::set_allocated_header(::atd::common::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.localization.LocalizationMapMatchEstimate.header)
}

// optional .atd.common.Reserved reservedmsg = 2;
inline bool LocalizationMapMatchEstimate::has_reservedmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocalizationMapMatchEstimate::set_has_reservedmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocalizationMapMatchEstimate::clear_has_reservedmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocalizationMapMatchEstimate::clear_reservedmsg() {
  if (reservedmsg_ != NULL) reservedmsg_->::atd::common::Reserved::Clear();
  clear_has_reservedmsg();
}
inline const ::atd::common::Reserved& LocalizationMapMatchEstimate::reservedmsg() const {
  // @@protoc_insertion_point(field_get:atd.localization.LocalizationMapMatchEstimate.reservedmsg)
  return reservedmsg_ != NULL ? *reservedmsg_
                         : *::atd::common::Reserved::internal_default_instance();
}
inline ::atd::common::Reserved* LocalizationMapMatchEstimate::mutable_reservedmsg() {
  set_has_reservedmsg();
  if (reservedmsg_ == NULL) {
    reservedmsg_ = new ::atd::common::Reserved;
  }
  // @@protoc_insertion_point(field_mutable:atd.localization.LocalizationMapMatchEstimate.reservedmsg)
  return reservedmsg_;
}
inline ::atd::common::Reserved* LocalizationMapMatchEstimate::release_reservedmsg() {
  // @@protoc_insertion_point(field_release:atd.localization.LocalizationMapMatchEstimate.reservedmsg)
  clear_has_reservedmsg();
  ::atd::common::Reserved* temp = reservedmsg_;
  reservedmsg_ = NULL;
  return temp;
}
inline void LocalizationMapMatchEstimate::set_allocated_reservedmsg(::atd::common::Reserved* reservedmsg) {
  delete reservedmsg_;
  reservedmsg_ = reservedmsg;
  if (reservedmsg) {
    set_has_reservedmsg();
  } else {
    clear_has_reservedmsg();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.localization.LocalizationMapMatchEstimate.reservedmsg)
}

// optional .atd.localization.Pose pose = 3;
inline bool LocalizationMapMatchEstimate::has_pose() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocalizationMapMatchEstimate::set_has_pose() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocalizationMapMatchEstimate::clear_has_pose() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LocalizationMapMatchEstimate::clear_pose() {
  if (pose_ != NULL) pose_->::atd::localization::Pose::Clear();
  clear_has_pose();
}
inline const ::atd::localization::Pose& LocalizationMapMatchEstimate::pose() const {
  // @@protoc_insertion_point(field_get:atd.localization.LocalizationMapMatchEstimate.pose)
  return pose_ != NULL ? *pose_
                         : *::atd::localization::Pose::internal_default_instance();
}
inline ::atd::localization::Pose* LocalizationMapMatchEstimate::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) {
    pose_ = new ::atd::localization::Pose;
  }
  // @@protoc_insertion_point(field_mutable:atd.localization.LocalizationMapMatchEstimate.pose)
  return pose_;
}
inline ::atd::localization::Pose* LocalizationMapMatchEstimate::release_pose() {
  // @@protoc_insertion_point(field_release:atd.localization.LocalizationMapMatchEstimate.pose)
  clear_has_pose();
  ::atd::localization::Pose* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline void LocalizationMapMatchEstimate::set_allocated_pose(::atd::localization::Pose* pose) {
  delete pose_;
  pose_ = pose;
  if (pose) {
    set_has_pose();
  } else {
    clear_has_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.localization.LocalizationMapMatchEstimate.pose)
}

// optional .atd.localization.Uncertainty uncertainty = 4;
inline bool LocalizationMapMatchEstimate::has_uncertainty() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LocalizationMapMatchEstimate::set_has_uncertainty() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LocalizationMapMatchEstimate::clear_has_uncertainty() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LocalizationMapMatchEstimate::clear_uncertainty() {
  if (uncertainty_ != NULL) uncertainty_->::atd::localization::Uncertainty::Clear();
  clear_has_uncertainty();
}
inline const ::atd::localization::Uncertainty& LocalizationMapMatchEstimate::uncertainty() const {
  // @@protoc_insertion_point(field_get:atd.localization.LocalizationMapMatchEstimate.uncertainty)
  return uncertainty_ != NULL ? *uncertainty_
                         : *::atd::localization::Uncertainty::internal_default_instance();
}
inline ::atd::localization::Uncertainty* LocalizationMapMatchEstimate::mutable_uncertainty() {
  set_has_uncertainty();
  if (uncertainty_ == NULL) {
    uncertainty_ = new ::atd::localization::Uncertainty;
  }
  // @@protoc_insertion_point(field_mutable:atd.localization.LocalizationMapMatchEstimate.uncertainty)
  return uncertainty_;
}
inline ::atd::localization::Uncertainty* LocalizationMapMatchEstimate::release_uncertainty() {
  // @@protoc_insertion_point(field_release:atd.localization.LocalizationMapMatchEstimate.uncertainty)
  clear_has_uncertainty();
  ::atd::localization::Uncertainty* temp = uncertainty_;
  uncertainty_ = NULL;
  return temp;
}
inline void LocalizationMapMatchEstimate::set_allocated_uncertainty(::atd::localization::Uncertainty* uncertainty) {
  delete uncertainty_;
  uncertainty_ = uncertainty;
  if (uncertainty) {
    set_has_uncertainty();
  } else {
    clear_has_uncertainty();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.localization.LocalizationMapMatchEstimate.uncertainty)
}

// optional .atd.localization.Particles histraj = 5;
inline bool LocalizationMapMatchEstimate::has_histraj() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LocalizationMapMatchEstimate::set_has_histraj() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LocalizationMapMatchEstimate::clear_has_histraj() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LocalizationMapMatchEstimate::clear_histraj() {
  if (histraj_ != NULL) histraj_->::atd::localization::Particles::Clear();
  clear_has_histraj();
}
inline const ::atd::localization::Particles& LocalizationMapMatchEstimate::histraj() const {
  // @@protoc_insertion_point(field_get:atd.localization.LocalizationMapMatchEstimate.histraj)
  return histraj_ != NULL ? *histraj_
                         : *::atd::localization::Particles::internal_default_instance();
}
inline ::atd::localization::Particles* LocalizationMapMatchEstimate::mutable_histraj() {
  set_has_histraj();
  if (histraj_ == NULL) {
    histraj_ = new ::atd::localization::Particles;
  }
  // @@protoc_insertion_point(field_mutable:atd.localization.LocalizationMapMatchEstimate.histraj)
  return histraj_;
}
inline ::atd::localization::Particles* LocalizationMapMatchEstimate::release_histraj() {
  // @@protoc_insertion_point(field_release:atd.localization.LocalizationMapMatchEstimate.histraj)
  clear_has_histraj();
  ::atd::localization::Particles* temp = histraj_;
  histraj_ = NULL;
  return temp;
}
inline void LocalizationMapMatchEstimate::set_allocated_histraj(::atd::localization::Particles* histraj) {
  delete histraj_;
  histraj_ = histraj;
  if (histraj) {
    set_has_histraj();
  } else {
    clear_has_histraj();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.localization.LocalizationMapMatchEstimate.histraj)
}

// optional .atd.localization.Particles grid = 6;
inline bool LocalizationMapMatchEstimate::has_grid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LocalizationMapMatchEstimate::set_has_grid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LocalizationMapMatchEstimate::clear_has_grid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LocalizationMapMatchEstimate::clear_grid() {
  if (grid_ != NULL) grid_->::atd::localization::Particles::Clear();
  clear_has_grid();
}
inline const ::atd::localization::Particles& LocalizationMapMatchEstimate::grid() const {
  // @@protoc_insertion_point(field_get:atd.localization.LocalizationMapMatchEstimate.grid)
  return grid_ != NULL ? *grid_
                         : *::atd::localization::Particles::internal_default_instance();
}
inline ::atd::localization::Particles* LocalizationMapMatchEstimate::mutable_grid() {
  set_has_grid();
  if (grid_ == NULL) {
    grid_ = new ::atd::localization::Particles;
  }
  // @@protoc_insertion_point(field_mutable:atd.localization.LocalizationMapMatchEstimate.grid)
  return grid_;
}
inline ::atd::localization::Particles* LocalizationMapMatchEstimate::release_grid() {
  // @@protoc_insertion_point(field_release:atd.localization.LocalizationMapMatchEstimate.grid)
  clear_has_grid();
  ::atd::localization::Particles* temp = grid_;
  grid_ = NULL;
  return temp;
}
inline void LocalizationMapMatchEstimate::set_allocated_grid(::atd::localization::Particles* grid) {
  delete grid_;
  grid_ = grid;
  if (grid) {
    set_has_grid();
  } else {
    clear_has_grid();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.localization.LocalizationMapMatchEstimate.grid)
}

// -------------------------------------------------------------------

// LocalizationEstimate

// optional .atd.common.Header header = 1;
inline bool LocalizationEstimate::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocalizationEstimate::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocalizationEstimate::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocalizationEstimate::clear_header() {
  if (header_ != NULL) header_->::atd::common::Header::Clear();
  clear_has_header();
}
inline const ::atd::common::Header& LocalizationEstimate::header() const {
  // @@protoc_insertion_point(field_get:atd.localization.LocalizationEstimate.header)
  return header_ != NULL ? *header_
                         : *::atd::common::Header::internal_default_instance();
}
inline ::atd::common::Header* LocalizationEstimate::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::atd::common::Header;
  }
  // @@protoc_insertion_point(field_mutable:atd.localization.LocalizationEstimate.header)
  return header_;
}
inline ::atd::common::Header* LocalizationEstimate::release_header() {
  // @@protoc_insertion_point(field_release:atd.localization.LocalizationEstimate.header)
  clear_has_header();
  ::atd::common::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void LocalizationEstimate::set_allocated_header(::atd::common::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.localization.LocalizationEstimate.header)
}

// optional .atd.common.Reserved reservedmsg = 2;
inline bool LocalizationEstimate::has_reservedmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocalizationEstimate::set_has_reservedmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocalizationEstimate::clear_has_reservedmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocalizationEstimate::clear_reservedmsg() {
  if (reservedmsg_ != NULL) reservedmsg_->::atd::common::Reserved::Clear();
  clear_has_reservedmsg();
}
inline const ::atd::common::Reserved& LocalizationEstimate::reservedmsg() const {
  // @@protoc_insertion_point(field_get:atd.localization.LocalizationEstimate.reservedmsg)
  return reservedmsg_ != NULL ? *reservedmsg_
                         : *::atd::common::Reserved::internal_default_instance();
}
inline ::atd::common::Reserved* LocalizationEstimate::mutable_reservedmsg() {
  set_has_reservedmsg();
  if (reservedmsg_ == NULL) {
    reservedmsg_ = new ::atd::common::Reserved;
  }
  // @@protoc_insertion_point(field_mutable:atd.localization.LocalizationEstimate.reservedmsg)
  return reservedmsg_;
}
inline ::atd::common::Reserved* LocalizationEstimate::release_reservedmsg() {
  // @@protoc_insertion_point(field_release:atd.localization.LocalizationEstimate.reservedmsg)
  clear_has_reservedmsg();
  ::atd::common::Reserved* temp = reservedmsg_;
  reservedmsg_ = NULL;
  return temp;
}
inline void LocalizationEstimate::set_allocated_reservedmsg(::atd::common::Reserved* reservedmsg) {
  delete reservedmsg_;
  reservedmsg_ = reservedmsg;
  if (reservedmsg) {
    set_has_reservedmsg();
  } else {
    clear_has_reservedmsg();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.localization.LocalizationEstimate.reservedmsg)
}

// optional .atd.localization.Pose pose = 3;
inline bool LocalizationEstimate::has_pose() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocalizationEstimate::set_has_pose() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocalizationEstimate::clear_has_pose() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LocalizationEstimate::clear_pose() {
  if (pose_ != NULL) pose_->::atd::localization::Pose::Clear();
  clear_has_pose();
}
inline const ::atd::localization::Pose& LocalizationEstimate::pose() const {
  // @@protoc_insertion_point(field_get:atd.localization.LocalizationEstimate.pose)
  return pose_ != NULL ? *pose_
                         : *::atd::localization::Pose::internal_default_instance();
}
inline ::atd::localization::Pose* LocalizationEstimate::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) {
    pose_ = new ::atd::localization::Pose;
  }
  // @@protoc_insertion_point(field_mutable:atd.localization.LocalizationEstimate.pose)
  return pose_;
}
inline ::atd::localization::Pose* LocalizationEstimate::release_pose() {
  // @@protoc_insertion_point(field_release:atd.localization.LocalizationEstimate.pose)
  clear_has_pose();
  ::atd::localization::Pose* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline void LocalizationEstimate::set_allocated_pose(::atd::localization::Pose* pose) {
  delete pose_;
  pose_ = pose;
  if (pose) {
    set_has_pose();
  } else {
    clear_has_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.localization.LocalizationEstimate.pose)
}

// optional .atd.localization.Uncertainty uncertainty = 4;
inline bool LocalizationEstimate::has_uncertainty() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LocalizationEstimate::set_has_uncertainty() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LocalizationEstimate::clear_has_uncertainty() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LocalizationEstimate::clear_uncertainty() {
  if (uncertainty_ != NULL) uncertainty_->::atd::localization::Uncertainty::Clear();
  clear_has_uncertainty();
}
inline const ::atd::localization::Uncertainty& LocalizationEstimate::uncertainty() const {
  // @@protoc_insertion_point(field_get:atd.localization.LocalizationEstimate.uncertainty)
  return uncertainty_ != NULL ? *uncertainty_
                         : *::atd::localization::Uncertainty::internal_default_instance();
}
inline ::atd::localization::Uncertainty* LocalizationEstimate::mutable_uncertainty() {
  set_has_uncertainty();
  if (uncertainty_ == NULL) {
    uncertainty_ = new ::atd::localization::Uncertainty;
  }
  // @@protoc_insertion_point(field_mutable:atd.localization.LocalizationEstimate.uncertainty)
  return uncertainty_;
}
inline ::atd::localization::Uncertainty* LocalizationEstimate::release_uncertainty() {
  // @@protoc_insertion_point(field_release:atd.localization.LocalizationEstimate.uncertainty)
  clear_has_uncertainty();
  ::atd::localization::Uncertainty* temp = uncertainty_;
  uncertainty_ = NULL;
  return temp;
}
inline void LocalizationEstimate::set_allocated_uncertainty(::atd::localization::Uncertainty* uncertainty) {
  delete uncertainty_;
  uncertainty_ = uncertainty;
  if (uncertainty) {
    set_has_uncertainty();
  } else {
    clear_has_uncertainty();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.localization.LocalizationEstimate.uncertainty)
}

// optional .atd.localization.Particles particles = 5;
inline bool LocalizationEstimate::has_particles() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LocalizationEstimate::set_has_particles() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LocalizationEstimate::clear_has_particles() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LocalizationEstimate::clear_particles() {
  if (particles_ != NULL) particles_->::atd::localization::Particles::Clear();
  clear_has_particles();
}
inline const ::atd::localization::Particles& LocalizationEstimate::particles() const {
  // @@protoc_insertion_point(field_get:atd.localization.LocalizationEstimate.particles)
  return particles_ != NULL ? *particles_
                         : *::atd::localization::Particles::internal_default_instance();
}
inline ::atd::localization::Particles* LocalizationEstimate::mutable_particles() {
  set_has_particles();
  if (particles_ == NULL) {
    particles_ = new ::atd::localization::Particles;
  }
  // @@protoc_insertion_point(field_mutable:atd.localization.LocalizationEstimate.particles)
  return particles_;
}
inline ::atd::localization::Particles* LocalizationEstimate::release_particles() {
  // @@protoc_insertion_point(field_release:atd.localization.LocalizationEstimate.particles)
  clear_has_particles();
  ::atd::localization::Particles* temp = particles_;
  particles_ = NULL;
  return temp;
}
inline void LocalizationEstimate::set_allocated_particles(::atd::localization::Particles* particles) {
  delete particles_;
  particles_ = particles;
  if (particles) {
    set_has_particles();
  } else {
    clear_has_particles();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.localization.LocalizationEstimate.particles)
}

// repeated .atd.common.TrajectoryPoint trajectory_point = 6;
inline int LocalizationEstimate::trajectory_point_size() const {
  return trajectory_point_.size();
}
inline void LocalizationEstimate::clear_trajectory_point() {
  trajectory_point_.Clear();
}
inline const ::atd::common::TrajectoryPoint& LocalizationEstimate::trajectory_point(int index) const {
  // @@protoc_insertion_point(field_get:atd.localization.LocalizationEstimate.trajectory_point)
  return trajectory_point_.Get(index);
}
inline ::atd::common::TrajectoryPoint* LocalizationEstimate::mutable_trajectory_point(int index) {
  // @@protoc_insertion_point(field_mutable:atd.localization.LocalizationEstimate.trajectory_point)
  return trajectory_point_.Mutable(index);
}
inline ::atd::common::TrajectoryPoint* LocalizationEstimate::add_trajectory_point() {
  // @@protoc_insertion_point(field_add:atd.localization.LocalizationEstimate.trajectory_point)
  return trajectory_point_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::atd::common::TrajectoryPoint >*
LocalizationEstimate::mutable_trajectory_point() {
  // @@protoc_insertion_point(field_mutable_list:atd.localization.LocalizationEstimate.trajectory_point)
  return &trajectory_point_;
}
inline const ::google::protobuf::RepeatedPtrField< ::atd::common::TrajectoryPoint >&
LocalizationEstimate::trajectory_point() const {
  // @@protoc_insertion_point(field_list:atd.localization.LocalizationEstimate.trajectory_point)
  return trajectory_point_;
}

// -------------------------------------------------------------------

// Particle

// optional .atd.common.Arrow2D arrow = 1;
inline bool Particle::has_arrow() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Particle::set_has_arrow() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Particle::clear_has_arrow() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Particle::clear_arrow() {
  if (arrow_ != NULL) arrow_->::atd::common::Arrow2D::Clear();
  clear_has_arrow();
}
inline const ::atd::common::Arrow2D& Particle::arrow() const {
  // @@protoc_insertion_point(field_get:atd.localization.Particle.arrow)
  return arrow_ != NULL ? *arrow_
                         : *::atd::common::Arrow2D::internal_default_instance();
}
inline ::atd::common::Arrow2D* Particle::mutable_arrow() {
  set_has_arrow();
  if (arrow_ == NULL) {
    arrow_ = new ::atd::common::Arrow2D;
  }
  // @@protoc_insertion_point(field_mutable:atd.localization.Particle.arrow)
  return arrow_;
}
inline ::atd::common::Arrow2D* Particle::release_arrow() {
  // @@protoc_insertion_point(field_release:atd.localization.Particle.arrow)
  clear_has_arrow();
  ::atd::common::Arrow2D* temp = arrow_;
  arrow_ = NULL;
  return temp;
}
inline void Particle::set_allocated_arrow(::atd::common::Arrow2D* arrow) {
  delete arrow_;
  arrow_ = arrow;
  if (arrow) {
    set_has_arrow();
  } else {
    clear_has_arrow();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.localization.Particle.arrow)
}

// optional .atd.localization.Pose pose = 2;
inline bool Particle::has_pose() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Particle::set_has_pose() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Particle::clear_has_pose() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Particle::clear_pose() {
  if (pose_ != NULL) pose_->::atd::localization::Pose::Clear();
  clear_has_pose();
}
inline const ::atd::localization::Pose& Particle::pose() const {
  // @@protoc_insertion_point(field_get:atd.localization.Particle.pose)
  return pose_ != NULL ? *pose_
                         : *::atd::localization::Pose::internal_default_instance();
}
inline ::atd::localization::Pose* Particle::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) {
    pose_ = new ::atd::localization::Pose;
  }
  // @@protoc_insertion_point(field_mutable:atd.localization.Particle.pose)
  return pose_;
}
inline ::atd::localization::Pose* Particle::release_pose() {
  // @@protoc_insertion_point(field_release:atd.localization.Particle.pose)
  clear_has_pose();
  ::atd::localization::Pose* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline void Particle::set_allocated_pose(::atd::localization::Pose* pose) {
  delete pose_;
  pose_ = pose;
  if (pose) {
    set_has_pose();
  } else {
    clear_has_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.localization.Particle.pose)
}

// optional float score = 3;
inline bool Particle::has_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Particle::set_has_score() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Particle::clear_has_score() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Particle::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline float Particle::score() const {
  // @@protoc_insertion_point(field_get:atd.localization.Particle.score)
  return score_;
}
inline void Particle::set_score(float value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:atd.localization.Particle.score)
}

// optional float weight = 4;
inline bool Particle::has_weight() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Particle::set_has_weight() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Particle::clear_has_weight() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Particle::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline float Particle::weight() const {
  // @@protoc_insertion_point(field_get:atd.localization.Particle.weight)
  return weight_;
}
inline void Particle::set_weight(float value) {
  set_has_weight();
  weight_ = value;
  // @@protoc_insertion_point(field_set:atd.localization.Particle.weight)
}

// -------------------------------------------------------------------

// Particles

// optional string layername = 1;
inline bool Particles::has_layername() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Particles::set_has_layername() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Particles::clear_has_layername() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Particles::clear_layername() {
  layername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_layername();
}
inline const ::std::string& Particles::layername() const {
  // @@protoc_insertion_point(field_get:atd.localization.Particles.layername)
  return layername_.GetNoArena();
}
inline void Particles::set_layername(const ::std::string& value) {
  set_has_layername();
  layername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:atd.localization.Particles.layername)
}
#if LANG_CXX11
inline void Particles::set_layername(::std::string&& value) {
  set_has_layername();
  layername_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:atd.localization.Particles.layername)
}
#endif
inline void Particles::set_layername(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_layername();
  layername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:atd.localization.Particles.layername)
}
inline void Particles::set_layername(const char* value, size_t size) {
  set_has_layername();
  layername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:atd.localization.Particles.layername)
}
inline ::std::string* Particles::mutable_layername() {
  set_has_layername();
  // @@protoc_insertion_point(field_mutable:atd.localization.Particles.layername)
  return layername_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Particles::release_layername() {
  // @@protoc_insertion_point(field_release:atd.localization.Particles.layername)
  clear_has_layername();
  return layername_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Particles::set_allocated_layername(::std::string* layername) {
  if (layername != NULL) {
    set_has_layername();
  } else {
    clear_has_layername();
  }
  layername_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), layername);
  // @@protoc_insertion_point(field_set_allocated:atd.localization.Particles.layername)
}

// optional float meanscore = 2;
inline bool Particles::has_meanscore() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Particles::set_has_meanscore() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Particles::clear_has_meanscore() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Particles::clear_meanscore() {
  meanscore_ = 0;
  clear_has_meanscore();
}
inline float Particles::meanscore() const {
  // @@protoc_insertion_point(field_get:atd.localization.Particles.meanscore)
  return meanscore_;
}
inline void Particles::set_meanscore(float value) {
  set_has_meanscore();
  meanscore_ = value;
  // @@protoc_insertion_point(field_set:atd.localization.Particles.meanscore)
}

// optional float belief = 3;
inline bool Particles::has_belief() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Particles::set_has_belief() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Particles::clear_has_belief() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Particles::clear_belief() {
  belief_ = 0;
  clear_has_belief();
}
inline float Particles::belief() const {
  // @@protoc_insertion_point(field_get:atd.localization.Particles.belief)
  return belief_;
}
inline void Particles::set_belief(float value) {
  set_has_belief();
  belief_ = value;
  // @@protoc_insertion_point(field_set:atd.localization.Particles.belief)
}

// optional fixed32 colorR = 4;
inline bool Particles::has_colorr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Particles::set_has_colorr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Particles::clear_has_colorr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Particles::clear_colorr() {
  colorr_ = 0u;
  clear_has_colorr();
}
inline ::google::protobuf::uint32 Particles::colorr() const {
  // @@protoc_insertion_point(field_get:atd.localization.Particles.colorR)
  return colorr_;
}
inline void Particles::set_colorr(::google::protobuf::uint32 value) {
  set_has_colorr();
  colorr_ = value;
  // @@protoc_insertion_point(field_set:atd.localization.Particles.colorR)
}

// optional fixed32 colorG = 5;
inline bool Particles::has_colorg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Particles::set_has_colorg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Particles::clear_has_colorg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Particles::clear_colorg() {
  colorg_ = 0u;
  clear_has_colorg();
}
inline ::google::protobuf::uint32 Particles::colorg() const {
  // @@protoc_insertion_point(field_get:atd.localization.Particles.colorG)
  return colorg_;
}
inline void Particles::set_colorg(::google::protobuf::uint32 value) {
  set_has_colorg();
  colorg_ = value;
  // @@protoc_insertion_point(field_set:atd.localization.Particles.colorG)
}

// optional fixed32 colorB = 6;
inline bool Particles::has_colorb() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Particles::set_has_colorb() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Particles::clear_has_colorb() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Particles::clear_colorb() {
  colorb_ = 0u;
  clear_has_colorb();
}
inline ::google::protobuf::uint32 Particles::colorb() const {
  // @@protoc_insertion_point(field_get:atd.localization.Particles.colorB)
  return colorb_;
}
inline void Particles::set_colorb(::google::protobuf::uint32 value) {
  set_has_colorb();
  colorb_ = value;
  // @@protoc_insertion_point(field_set:atd.localization.Particles.colorB)
}

// repeated .atd.localization.Particle particle = 7;
inline int Particles::particle_size() const {
  return particle_.size();
}
inline void Particles::clear_particle() {
  particle_.Clear();
}
inline const ::atd::localization::Particle& Particles::particle(int index) const {
  // @@protoc_insertion_point(field_get:atd.localization.Particles.particle)
  return particle_.Get(index);
}
inline ::atd::localization::Particle* Particles::mutable_particle(int index) {
  // @@protoc_insertion_point(field_mutable:atd.localization.Particles.particle)
  return particle_.Mutable(index);
}
inline ::atd::localization::Particle* Particles::add_particle() {
  // @@protoc_insertion_point(field_add:atd.localization.Particles.particle)
  return particle_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::atd::localization::Particle >*
Particles::mutable_particle() {
  // @@protoc_insertion_point(field_mutable_list:atd.localization.Particles.particle)
  return &particle_;
}
inline const ::google::protobuf::RepeatedPtrField< ::atd::localization::Particle >&
Particles::particle() const {
  // @@protoc_insertion_point(field_list:atd.localization.Particles.particle)
  return particle_;
}

// optional .atd.localization.MeasureState layerState = 9;
inline bool Particles::has_layerstate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Particles::set_has_layerstate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Particles::clear_has_layerstate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Particles::clear_layerstate() {
  layerstate_ = 0;
  clear_has_layerstate();
}
inline ::atd::localization::MeasureState Particles::layerstate() const {
  // @@protoc_insertion_point(field_get:atd.localization.Particles.layerState)
  return static_cast< ::atd::localization::MeasureState >(layerstate_);
}
inline void Particles::set_layerstate(::atd::localization::MeasureState value) {
  assert(::atd::localization::MeasureState_IsValid(value));
  set_has_layerstate();
  layerstate_ = value;
  // @@protoc_insertion_point(field_set:atd.localization.Particles.layerState)
}

// -------------------------------------------------------------------

// Particles_Collection

// optional .atd.common.Header header = 1;
inline bool Particles_Collection::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Particles_Collection::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Particles_Collection::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Particles_Collection::clear_header() {
  if (header_ != NULL) header_->::atd::common::Header::Clear();
  clear_has_header();
}
inline const ::atd::common::Header& Particles_Collection::header() const {
  // @@protoc_insertion_point(field_get:atd.localization.Particles_Collection.header)
  return header_ != NULL ? *header_
                         : *::atd::common::Header::internal_default_instance();
}
inline ::atd::common::Header* Particles_Collection::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::atd::common::Header;
  }
  // @@protoc_insertion_point(field_mutable:atd.localization.Particles_Collection.header)
  return header_;
}
inline ::atd::common::Header* Particles_Collection::release_header() {
  // @@protoc_insertion_point(field_release:atd.localization.Particles_Collection.header)
  clear_has_header();
  ::atd::common::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void Particles_Collection::set_allocated_header(::atd::common::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.localization.Particles_Collection.header)
}

// optional .atd.common.Reserved reservedmsg = 2;
inline bool Particles_Collection::has_reservedmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Particles_Collection::set_has_reservedmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Particles_Collection::clear_has_reservedmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Particles_Collection::clear_reservedmsg() {
  if (reservedmsg_ != NULL) reservedmsg_->::atd::common::Reserved::Clear();
  clear_has_reservedmsg();
}
inline const ::atd::common::Reserved& Particles_Collection::reservedmsg() const {
  // @@protoc_insertion_point(field_get:atd.localization.Particles_Collection.reservedmsg)
  return reservedmsg_ != NULL ? *reservedmsg_
                         : *::atd::common::Reserved::internal_default_instance();
}
inline ::atd::common::Reserved* Particles_Collection::mutable_reservedmsg() {
  set_has_reservedmsg();
  if (reservedmsg_ == NULL) {
    reservedmsg_ = new ::atd::common::Reserved;
  }
  // @@protoc_insertion_point(field_mutable:atd.localization.Particles_Collection.reservedmsg)
  return reservedmsg_;
}
inline ::atd::common::Reserved* Particles_Collection::release_reservedmsg() {
  // @@protoc_insertion_point(field_release:atd.localization.Particles_Collection.reservedmsg)
  clear_has_reservedmsg();
  ::atd::common::Reserved* temp = reservedmsg_;
  reservedmsg_ = NULL;
  return temp;
}
inline void Particles_Collection::set_allocated_reservedmsg(::atd::common::Reserved* reservedmsg) {
  delete reservedmsg_;
  reservedmsg_ = reservedmsg;
  if (reservedmsg) {
    set_has_reservedmsg();
  } else {
    clear_has_reservedmsg();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.localization.Particles_Collection.reservedmsg)
}

// repeated .atd.localization.Particles particles = 3;
inline int Particles_Collection::particles_size() const {
  return particles_.size();
}
inline void Particles_Collection::clear_particles() {
  particles_.Clear();
}
inline const ::atd::localization::Particles& Particles_Collection::particles(int index) const {
  // @@protoc_insertion_point(field_get:atd.localization.Particles_Collection.particles)
  return particles_.Get(index);
}
inline ::atd::localization::Particles* Particles_Collection::mutable_particles(int index) {
  // @@protoc_insertion_point(field_mutable:atd.localization.Particles_Collection.particles)
  return particles_.Mutable(index);
}
inline ::atd::localization::Particles* Particles_Collection::add_particles() {
  // @@protoc_insertion_point(field_add:atd.localization.Particles_Collection.particles)
  return particles_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::atd::localization::Particles >*
Particles_Collection::mutable_particles() {
  // @@protoc_insertion_point(field_mutable_list:atd.localization.Particles_Collection.particles)
  return &particles_;
}
inline const ::google::protobuf::RepeatedPtrField< ::atd::localization::Particles >&
Particles_Collection::particles() const {
  // @@protoc_insertion_point(field_list:atd.localization.Particles_Collection.particles)
  return particles_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace localization
}  // namespace atd

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::atd::localization::MeasureState> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_modules_2fipc_2fmessage_2fprotobuf_2flocalization_2flocalization_2eproto__INCLUDED
