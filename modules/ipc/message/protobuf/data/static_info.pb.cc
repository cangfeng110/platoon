// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/ipc/message/protobuf/data/static_info.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "modules/ipc/message/protobuf/data/static_info.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace atd {
namespace data {
class VehicleInfoDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<VehicleInfo> {
} _VehicleInfo_default_instance_;
class EnvironmentInfoDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<EnvironmentInfo> {
} _EnvironmentInfo_default_instance_;
class HardwareInfo_ConfigsEntryDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<HardwareInfo::HardwareInfo_ConfigsEntry> {
} _HardwareInfo_ConfigsEntry_default_instance_;
class HardwareInfoDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<HardwareInfo> {
} _HardwareInfo_default_instance_;
class SoftwareInfo_ConfigsEntryDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<SoftwareInfo::SoftwareInfo_ConfigsEntry> {
} _SoftwareInfo_ConfigsEntry_default_instance_;
class SoftwareInfoDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<SoftwareInfo> {
} _SoftwareInfo_default_instance_;
class UserInfoDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<UserInfo> {
} _UserInfo_default_instance_;
class StaticInfoDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<StaticInfo> {
} _StaticInfo_default_instance_;
class StaticInfoConfDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<StaticInfoConf> {
} _StaticInfoConf_default_instance_;

namespace protobuf_modules_2fipc_2fmessage_2fprotobuf_2fdata_2fstatic_5finfo_2eproto {

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTableField
    const TableStruct::entries[] = {
  {0, 0, 0, ::google::protobuf::internal::kInvalidMask, 0, 0},
};

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::AuxillaryParseTableField
    const TableStruct::aux[] = {
  ::google::protobuf::internal::AuxillaryParseTableField(),
};
PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTable const
    TableStruct::schema[] = {
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
};


void TableStruct::Shutdown() {
  _VehicleInfo_default_instance_.Shutdown();
  _EnvironmentInfo_default_instance_.Shutdown();
  _HardwareInfo_default_instance_.Shutdown();
  _SoftwareInfo_default_instance_.Shutdown();
  _UserInfo_default_instance_.Shutdown();
  _StaticInfo_default_instance_.Shutdown();
  _StaticInfoConf_default_instance_.Shutdown();
}

void TableStruct::InitDefaultsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::internal::InitProtobufDefaults();
  ::atd::canbus::protobuf_modules_2fipc_2fmessage_2fprotobuf_2fcanbus_2fcanbus_5fconf_2eproto::InitDefaults();
  ::atd::canbus::protobuf_modules_2fipc_2fmessage_2fprotobuf_2fcanbus_2fchassis_5fdetail_2eproto::InitDefaults();
  ::atd::common::protobuf_modules_2fipc_2fmessage_2fprotobuf_2fcommon_2fconfigs_2fvehicle_5fconfig_2eproto::InitDefaults();
  _VehicleInfo_default_instance_.DefaultConstruct();
  _EnvironmentInfo_default_instance_.DefaultConstruct();
  _HardwareInfo_ConfigsEntry_default_instance_.DefaultConstruct();
  _HardwareInfo_default_instance_.DefaultConstruct();
  _SoftwareInfo_ConfigsEntry_default_instance_.DefaultConstruct();
  _SoftwareInfo_default_instance_.DefaultConstruct();
  _UserInfo_default_instance_.DefaultConstruct();
  _StaticInfo_default_instance_.DefaultConstruct();
  _StaticInfoConf_default_instance_.DefaultConstruct();
  _VehicleInfo_default_instance_.get_mutable()->license_ = const_cast< ::atd::canbus::License*>(
      ::atd::canbus::License::internal_default_instance());
  _VehicleInfo_default_instance_.get_mutable()->canbus_conf_ = const_cast< ::atd::canbus::CanbusConf*>(
      ::atd::canbus::CanbusConf::internal_default_instance());
  _VehicleInfo_default_instance_.get_mutable()->vehicle_config_ = const_cast< ::atd::common::VehicleConfig*>(
      ::atd::common::VehicleConfig::internal_default_instance());
  _HardwareInfo_ConfigsEntry_default_instance_.get_mutable()->set_default_instance(_HardwareInfo_ConfigsEntry_default_instance_.get_mutable());
  _HardwareInfo_ConfigsEntry_default_instance_.get_mutable()->InitAsDefaultInstance();
  _SoftwareInfo_ConfigsEntry_default_instance_.get_mutable()->set_default_instance(_SoftwareInfo_ConfigsEntry_default_instance_.get_mutable());
  _SoftwareInfo_ConfigsEntry_default_instance_.get_mutable()->InitAsDefaultInstance();
  _StaticInfo_default_instance_.get_mutable()->vehicle_ = const_cast< ::atd::data::VehicleInfo*>(
      ::atd::data::VehicleInfo::internal_default_instance());
  _StaticInfo_default_instance_.get_mutable()->environment_ = const_cast< ::atd::data::EnvironmentInfo*>(
      ::atd::data::EnvironmentInfo::internal_default_instance());
  _StaticInfo_default_instance_.get_mutable()->hardware_ = const_cast< ::atd::data::HardwareInfo*>(
      ::atd::data::HardwareInfo::internal_default_instance());
  _StaticInfo_default_instance_.get_mutable()->software_ = const_cast< ::atd::data::SoftwareInfo*>(
      ::atd::data::SoftwareInfo::internal_default_instance());
  _StaticInfo_default_instance_.get_mutable()->user_ = const_cast< ::atd::data::UserInfo*>(
      ::atd::data::UserInfo::internal_default_instance());
}

void InitDefaults() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &TableStruct::InitDefaultsImpl);
}
void AddDescriptorsImpl() {
  InitDefaults();
  ::atd::canbus::protobuf_modules_2fipc_2fmessage_2fprotobuf_2fcanbus_2fcanbus_5fconf_2eproto::AddDescriptors();
  ::atd::canbus::protobuf_modules_2fipc_2fmessage_2fprotobuf_2fcanbus_2fchassis_5fdetail_2eproto::AddDescriptors();
  ::atd::common::protobuf_modules_2fipc_2fmessage_2fprotobuf_2fcommon_2fconfigs_2fvehicle_5fconfig_2eproto::AddDescriptors();
  ::google::protobuf::internal::OnShutdown(&TableStruct::Shutdown);
}

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;
#endif  // GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

}  // namespace protobuf_modules_2fipc_2fmessage_2fprotobuf_2fdata_2fstatic_5finfo_2eproto

bool VehicleInfo_Brand_IsValid(int value) {
  switch (value) {
    case 1:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const VehicleInfo_Brand VehicleInfo::LINCOLN;
const VehicleInfo_Brand VehicleInfo::Brand_MIN;
const VehicleInfo_Brand VehicleInfo::Brand_MAX;
const int VehicleInfo::Brand_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
bool VehicleInfo_Model_IsValid(int value) {
  switch (value) {
    case 1:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const VehicleInfo_Model VehicleInfo::MKZ;
const VehicleInfo_Model VehicleInfo::Model_MIN;
const VehicleInfo_Model VehicleInfo::Model_MAX;
const int VehicleInfo::Model_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int VehicleInfo::kNameFieldNumber;
const int VehicleInfo::kBrandFieldNumber;
const int VehicleInfo::kModelFieldNumber;
const int VehicleInfo::kLicenseFieldNumber;
const int VehicleInfo::kCanbusConfFieldNumber;
const int VehicleInfo::kVehicleConfigFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

VehicleInfo::VehicleInfo()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fipc_2fmessage_2fprotobuf_2fdata_2fstatic_5finfo_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:atd.data.VehicleInfo)
}
VehicleInfo::VehicleInfo(const VehicleInfo& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  if (from.has_license()) {
    license_ = new ::atd::canbus::License(*from.license_);
  } else {
    license_ = NULL;
  }
  if (from.has_canbus_conf()) {
    canbus_conf_ = new ::atd::canbus::CanbusConf(*from.canbus_conf_);
  } else {
    canbus_conf_ = NULL;
  }
  if (from.has_vehicle_config()) {
    vehicle_config_ = new ::atd::common::VehicleConfig(*from.vehicle_config_);
  } else {
    vehicle_config_ = NULL;
  }
  ::memcpy(&brand_, &from.brand_,
    reinterpret_cast<char*>(&model_) -
    reinterpret_cast<char*>(&brand_) + sizeof(model_));
  // @@protoc_insertion_point(copy_constructor:atd.data.VehicleInfo)
}

void VehicleInfo::SharedCtor() {
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&license_, 0, reinterpret_cast<char*>(&vehicle_config_) -
    reinterpret_cast<char*>(&license_) + sizeof(vehicle_config_));
  brand_ = 1;
  model_ = 1;
}

VehicleInfo::~VehicleInfo() {
  // @@protoc_insertion_point(destructor:atd.data.VehicleInfo)
  SharedDtor();
}

void VehicleInfo::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) {
    delete license_;
  }
  if (this != internal_default_instance()) {
    delete canbus_conf_;
  }
  if (this != internal_default_instance()) {
    delete vehicle_config_;
  }
}

void VehicleInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const VehicleInfo& VehicleInfo::default_instance() {
  protobuf_modules_2fipc_2fmessage_2fprotobuf_2fdata_2fstatic_5finfo_2eproto::InitDefaults();
  return *internal_default_instance();
}

VehicleInfo* VehicleInfo::New(::google::protobuf::Arena* arena) const {
  VehicleInfo* n = new VehicleInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void VehicleInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:atd.data.VehicleInfo)
  if (_has_bits_[0 / 32] & 63u) {
    if (has_name()) {
      GOOGLE_DCHECK(!name_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*name_.UnsafeRawStringPointer())->clear();
    }
    if (has_license()) {
      GOOGLE_DCHECK(license_ != NULL);
      license_->::atd::canbus::License::Clear();
    }
    if (has_canbus_conf()) {
      GOOGLE_DCHECK(canbus_conf_ != NULL);
      canbus_conf_->::atd::canbus::CanbusConf::Clear();
    }
    if (has_vehicle_config()) {
      GOOGLE_DCHECK(vehicle_config_ != NULL);
      vehicle_config_->::atd::common::VehicleConfig::Clear();
    }
    brand_ = 1;
    model_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool VehicleInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:atd.data.VehicleInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .atd.data.VehicleInfo.Brand brand = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::atd::data::VehicleInfo_Brand_IsValid(value)) {
            set_brand(static_cast< ::atd::data::VehicleInfo_Brand >(value));
          } else {
            unknown_fields_stream.WriteVarint32(16u);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .atd.data.VehicleInfo.Model model = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::atd::data::VehicleInfo_Model_IsValid(value)) {
            set_model(static_cast< ::atd::data::VehicleInfo_Model >(value));
          } else {
            unknown_fields_stream.WriteVarint32(24u);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .atd.canbus.License license = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_license()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .atd.canbus.CanbusConf canbus_conf = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_canbus_conf()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .atd.common.VehicleConfig vehicle_config = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_vehicle_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:atd.data.VehicleInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:atd.data.VehicleInfo)
  return false;
#undef DO_
}

void VehicleInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:atd.data.VehicleInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional .atd.data.VehicleInfo.Brand brand = 2;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->brand(), output);
  }

  // optional .atd.data.VehicleInfo.Model model = 3;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->model(), output);
  }

  // optional .atd.canbus.License license = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *this->license_, output);
  }

  // optional .atd.canbus.CanbusConf canbus_conf = 5;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, *this->canbus_conf_, output);
  }

  // optional .atd.common.VehicleConfig vehicle_config = 6;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, *this->vehicle_config_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:atd.data.VehicleInfo)
}

size_t VehicleInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:atd.data.VehicleInfo)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  if (_has_bits_[0 / 32] & 63u) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional .atd.canbus.License license = 4;
    if (has_license()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->license_);
    }

    // optional .atd.canbus.CanbusConf canbus_conf = 5;
    if (has_canbus_conf()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->canbus_conf_);
    }

    // optional .atd.common.VehicleConfig vehicle_config = 6;
    if (has_vehicle_config()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->vehicle_config_);
    }

    // optional .atd.data.VehicleInfo.Brand brand = 2;
    if (has_brand()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->brand());
    }

    // optional .atd.data.VehicleInfo.Model model = 3;
    if (has_model()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->model());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VehicleInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const VehicleInfo*>(&from));
}

void VehicleInfo::MergeFrom(const VehicleInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:atd.data.VehicleInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 63u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_license()->::atd::canbus::License::MergeFrom(from.license());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_canbus_conf()->::atd::canbus::CanbusConf::MergeFrom(from.canbus_conf());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_vehicle_config()->::atd::common::VehicleConfig::MergeFrom(from.vehicle_config());
    }
    if (cached_has_bits & 0x00000010u) {
      brand_ = from.brand_;
    }
    if (cached_has_bits & 0x00000020u) {
      model_ = from.model_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void VehicleInfo::CopyFrom(const VehicleInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:atd.data.VehicleInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VehicleInfo::IsInitialized() const {
  return true;
}

void VehicleInfo::Swap(VehicleInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void VehicleInfo::InternalSwap(VehicleInfo* other) {
  name_.Swap(&other->name_);
  std::swap(license_, other->license_);
  std::swap(canbus_conf_, other->canbus_conf_);
  std::swap(vehicle_config_, other->vehicle_config_);
  std::swap(brand_, other->brand_);
  std::swap(model_, other->model_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string VehicleInfo::GetTypeName() const {
  return "atd.data.VehicleInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// VehicleInfo

// optional string name = 1;
bool VehicleInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void VehicleInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void VehicleInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void VehicleInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
const ::std::string& VehicleInfo::name() const {
  // @@protoc_insertion_point(field_get:atd.data.VehicleInfo.name)
  return name_.GetNoArena();
}
void VehicleInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:atd.data.VehicleInfo.name)
}
#if LANG_CXX11
void VehicleInfo::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:atd.data.VehicleInfo.name)
}
#endif
void VehicleInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:atd.data.VehicleInfo.name)
}
void VehicleInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:atd.data.VehicleInfo.name)
}
::std::string* VehicleInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:atd.data.VehicleInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* VehicleInfo::release_name() {
  // @@protoc_insertion_point(field_release:atd.data.VehicleInfo.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void VehicleInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:atd.data.VehicleInfo.name)
}

// optional .atd.data.VehicleInfo.Brand brand = 2;
bool VehicleInfo::has_brand() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void VehicleInfo::set_has_brand() {
  _has_bits_[0] |= 0x00000010u;
}
void VehicleInfo::clear_has_brand() {
  _has_bits_[0] &= ~0x00000010u;
}
void VehicleInfo::clear_brand() {
  brand_ = 1;
  clear_has_brand();
}
::atd::data::VehicleInfo_Brand VehicleInfo::brand() const {
  // @@protoc_insertion_point(field_get:atd.data.VehicleInfo.brand)
  return static_cast< ::atd::data::VehicleInfo_Brand >(brand_);
}
void VehicleInfo::set_brand(::atd::data::VehicleInfo_Brand value) {
  assert(::atd::data::VehicleInfo_Brand_IsValid(value));
  set_has_brand();
  brand_ = value;
  // @@protoc_insertion_point(field_set:atd.data.VehicleInfo.brand)
}

// optional .atd.data.VehicleInfo.Model model = 3;
bool VehicleInfo::has_model() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void VehicleInfo::set_has_model() {
  _has_bits_[0] |= 0x00000020u;
}
void VehicleInfo::clear_has_model() {
  _has_bits_[0] &= ~0x00000020u;
}
void VehicleInfo::clear_model() {
  model_ = 1;
  clear_has_model();
}
::atd::data::VehicleInfo_Model VehicleInfo::model() const {
  // @@protoc_insertion_point(field_get:atd.data.VehicleInfo.model)
  return static_cast< ::atd::data::VehicleInfo_Model >(model_);
}
void VehicleInfo::set_model(::atd::data::VehicleInfo_Model value) {
  assert(::atd::data::VehicleInfo_Model_IsValid(value));
  set_has_model();
  model_ = value;
  // @@protoc_insertion_point(field_set:atd.data.VehicleInfo.model)
}

// optional .atd.canbus.License license = 4;
bool VehicleInfo::has_license() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void VehicleInfo::set_has_license() {
  _has_bits_[0] |= 0x00000002u;
}
void VehicleInfo::clear_has_license() {
  _has_bits_[0] &= ~0x00000002u;
}
void VehicleInfo::clear_license() {
  if (license_ != NULL) license_->::atd::canbus::License::Clear();
  clear_has_license();
}
const ::atd::canbus::License& VehicleInfo::license() const {
  // @@protoc_insertion_point(field_get:atd.data.VehicleInfo.license)
  return license_ != NULL ? *license_
                         : *::atd::canbus::License::internal_default_instance();
}
::atd::canbus::License* VehicleInfo::mutable_license() {
  set_has_license();
  if (license_ == NULL) {
    license_ = new ::atd::canbus::License;
  }
  // @@protoc_insertion_point(field_mutable:atd.data.VehicleInfo.license)
  return license_;
}
::atd::canbus::License* VehicleInfo::release_license() {
  // @@protoc_insertion_point(field_release:atd.data.VehicleInfo.license)
  clear_has_license();
  ::atd::canbus::License* temp = license_;
  license_ = NULL;
  return temp;
}
void VehicleInfo::set_allocated_license(::atd::canbus::License* license) {
  delete license_;
  license_ = license;
  if (license) {
    set_has_license();
  } else {
    clear_has_license();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.data.VehicleInfo.license)
}

// optional .atd.canbus.CanbusConf canbus_conf = 5;
bool VehicleInfo::has_canbus_conf() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void VehicleInfo::set_has_canbus_conf() {
  _has_bits_[0] |= 0x00000004u;
}
void VehicleInfo::clear_has_canbus_conf() {
  _has_bits_[0] &= ~0x00000004u;
}
void VehicleInfo::clear_canbus_conf() {
  if (canbus_conf_ != NULL) canbus_conf_->::atd::canbus::CanbusConf::Clear();
  clear_has_canbus_conf();
}
const ::atd::canbus::CanbusConf& VehicleInfo::canbus_conf() const {
  // @@protoc_insertion_point(field_get:atd.data.VehicleInfo.canbus_conf)
  return canbus_conf_ != NULL ? *canbus_conf_
                         : *::atd::canbus::CanbusConf::internal_default_instance();
}
::atd::canbus::CanbusConf* VehicleInfo::mutable_canbus_conf() {
  set_has_canbus_conf();
  if (canbus_conf_ == NULL) {
    canbus_conf_ = new ::atd::canbus::CanbusConf;
  }
  // @@protoc_insertion_point(field_mutable:atd.data.VehicleInfo.canbus_conf)
  return canbus_conf_;
}
::atd::canbus::CanbusConf* VehicleInfo::release_canbus_conf() {
  // @@protoc_insertion_point(field_release:atd.data.VehicleInfo.canbus_conf)
  clear_has_canbus_conf();
  ::atd::canbus::CanbusConf* temp = canbus_conf_;
  canbus_conf_ = NULL;
  return temp;
}
void VehicleInfo::set_allocated_canbus_conf(::atd::canbus::CanbusConf* canbus_conf) {
  delete canbus_conf_;
  canbus_conf_ = canbus_conf;
  if (canbus_conf) {
    set_has_canbus_conf();
  } else {
    clear_has_canbus_conf();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.data.VehicleInfo.canbus_conf)
}

// optional .atd.common.VehicleConfig vehicle_config = 6;
bool VehicleInfo::has_vehicle_config() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void VehicleInfo::set_has_vehicle_config() {
  _has_bits_[0] |= 0x00000008u;
}
void VehicleInfo::clear_has_vehicle_config() {
  _has_bits_[0] &= ~0x00000008u;
}
void VehicleInfo::clear_vehicle_config() {
  if (vehicle_config_ != NULL) vehicle_config_->::atd::common::VehicleConfig::Clear();
  clear_has_vehicle_config();
}
const ::atd::common::VehicleConfig& VehicleInfo::vehicle_config() const {
  // @@protoc_insertion_point(field_get:atd.data.VehicleInfo.vehicle_config)
  return vehicle_config_ != NULL ? *vehicle_config_
                         : *::atd::common::VehicleConfig::internal_default_instance();
}
::atd::common::VehicleConfig* VehicleInfo::mutable_vehicle_config() {
  set_has_vehicle_config();
  if (vehicle_config_ == NULL) {
    vehicle_config_ = new ::atd::common::VehicleConfig;
  }
  // @@protoc_insertion_point(field_mutable:atd.data.VehicleInfo.vehicle_config)
  return vehicle_config_;
}
::atd::common::VehicleConfig* VehicleInfo::release_vehicle_config() {
  // @@protoc_insertion_point(field_release:atd.data.VehicleInfo.vehicle_config)
  clear_has_vehicle_config();
  ::atd::common::VehicleConfig* temp = vehicle_config_;
  vehicle_config_ = NULL;
  return temp;
}
void VehicleInfo::set_allocated_vehicle_config(::atd::common::VehicleConfig* vehicle_config) {
  delete vehicle_config_;
  vehicle_config_ = vehicle_config;
  if (vehicle_config) {
    set_has_vehicle_config();
  } else {
    clear_has_vehicle_config();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.data.VehicleInfo.vehicle_config)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EnvironmentInfo::kMapNameFieldNumber;
const int EnvironmentInfo::kTemperatureFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EnvironmentInfo::EnvironmentInfo()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fipc_2fmessage_2fprotobuf_2fdata_2fstatic_5finfo_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:atd.data.EnvironmentInfo)
}
EnvironmentInfo::EnvironmentInfo(const EnvironmentInfo& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  map_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_map_name()) {
    map_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.map_name_);
  }
  temperature_ = from.temperature_;
  // @@protoc_insertion_point(copy_constructor:atd.data.EnvironmentInfo)
}

void EnvironmentInfo::SharedCtor() {
  _cached_size_ = 0;
  map_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  temperature_ = 0;
}

EnvironmentInfo::~EnvironmentInfo() {
  // @@protoc_insertion_point(destructor:atd.data.EnvironmentInfo)
  SharedDtor();
}

void EnvironmentInfo::SharedDtor() {
  map_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void EnvironmentInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EnvironmentInfo& EnvironmentInfo::default_instance() {
  protobuf_modules_2fipc_2fmessage_2fprotobuf_2fdata_2fstatic_5finfo_2eproto::InitDefaults();
  return *internal_default_instance();
}

EnvironmentInfo* EnvironmentInfo::New(::google::protobuf::Arena* arena) const {
  EnvironmentInfo* n = new EnvironmentInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EnvironmentInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:atd.data.EnvironmentInfo)
  if (has_map_name()) {
    GOOGLE_DCHECK(!map_name_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*map_name_.UnsafeRawStringPointer())->clear();
  }
  temperature_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EnvironmentInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:atd.data.EnvironmentInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string map_name = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_map_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float temperature = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(21u)) {
          set_has_temperature();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &temperature_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:atd.data.EnvironmentInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:atd.data.EnvironmentInfo)
  return false;
#undef DO_
}

void EnvironmentInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:atd.data.EnvironmentInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string map_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->map_name(), output);
  }

  // optional float temperature = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->temperature(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:atd.data.EnvironmentInfo)
}

size_t EnvironmentInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:atd.data.EnvironmentInfo)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  if (_has_bits_[0 / 32] & 3u) {
    // optional string map_name = 1;
    if (has_map_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->map_name());
    }

    // optional float temperature = 2;
    if (has_temperature()) {
      total_size += 1 + 4;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EnvironmentInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EnvironmentInfo*>(&from));
}

void EnvironmentInfo::MergeFrom(const EnvironmentInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:atd.data.EnvironmentInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_map_name();
      map_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.map_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      temperature_ = from.temperature_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void EnvironmentInfo::CopyFrom(const EnvironmentInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:atd.data.EnvironmentInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnvironmentInfo::IsInitialized() const {
  return true;
}

void EnvironmentInfo::Swap(EnvironmentInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EnvironmentInfo::InternalSwap(EnvironmentInfo* other) {
  map_name_.Swap(&other->map_name_);
  std::swap(temperature_, other->temperature_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string EnvironmentInfo::GetTypeName() const {
  return "atd.data.EnvironmentInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// EnvironmentInfo

// optional string map_name = 1;
bool EnvironmentInfo::has_map_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void EnvironmentInfo::set_has_map_name() {
  _has_bits_[0] |= 0x00000001u;
}
void EnvironmentInfo::clear_has_map_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void EnvironmentInfo::clear_map_name() {
  map_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_map_name();
}
const ::std::string& EnvironmentInfo::map_name() const {
  // @@protoc_insertion_point(field_get:atd.data.EnvironmentInfo.map_name)
  return map_name_.GetNoArena();
}
void EnvironmentInfo::set_map_name(const ::std::string& value) {
  set_has_map_name();
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:atd.data.EnvironmentInfo.map_name)
}
#if LANG_CXX11
void EnvironmentInfo::set_map_name(::std::string&& value) {
  set_has_map_name();
  map_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:atd.data.EnvironmentInfo.map_name)
}
#endif
void EnvironmentInfo::set_map_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_map_name();
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:atd.data.EnvironmentInfo.map_name)
}
void EnvironmentInfo::set_map_name(const char* value, size_t size) {
  set_has_map_name();
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:atd.data.EnvironmentInfo.map_name)
}
::std::string* EnvironmentInfo::mutable_map_name() {
  set_has_map_name();
  // @@protoc_insertion_point(field_mutable:atd.data.EnvironmentInfo.map_name)
  return map_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* EnvironmentInfo::release_map_name() {
  // @@protoc_insertion_point(field_release:atd.data.EnvironmentInfo.map_name)
  clear_has_map_name();
  return map_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void EnvironmentInfo::set_allocated_map_name(::std::string* map_name) {
  if (map_name != NULL) {
    set_has_map_name();
  } else {
    clear_has_map_name();
  }
  map_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_name);
  // @@protoc_insertion_point(field_set_allocated:atd.data.EnvironmentInfo.map_name)
}

// optional float temperature = 2;
bool EnvironmentInfo::has_temperature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void EnvironmentInfo::set_has_temperature() {
  _has_bits_[0] |= 0x00000002u;
}
void EnvironmentInfo::clear_has_temperature() {
  _has_bits_[0] &= ~0x00000002u;
}
void EnvironmentInfo::clear_temperature() {
  temperature_ = 0;
  clear_has_temperature();
}
float EnvironmentInfo::temperature() const {
  // @@protoc_insertion_point(field_get:atd.data.EnvironmentInfo.temperature)
  return temperature_;
}
void EnvironmentInfo::set_temperature(float value) {
  set_has_temperature();
  temperature_ = value;
  // @@protoc_insertion_point(field_set:atd.data.EnvironmentInfo.temperature)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if PROTOBUF_INLINE_NOT_IN_HEADERS
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int HardwareInfo::kConfigsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

HardwareInfo::HardwareInfo()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fipc_2fmessage_2fprotobuf_2fdata_2fstatic_5finfo_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:atd.data.HardwareInfo)
}
HardwareInfo::HardwareInfo(const HardwareInfo& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  configs_.MergeFrom(from.configs_);
  // @@protoc_insertion_point(copy_constructor:atd.data.HardwareInfo)
}

void HardwareInfo::SharedCtor() {
  _cached_size_ = 0;
}

HardwareInfo::~HardwareInfo() {
  // @@protoc_insertion_point(destructor:atd.data.HardwareInfo)
  SharedDtor();
}

void HardwareInfo::SharedDtor() {
}

void HardwareInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const HardwareInfo& HardwareInfo::default_instance() {
  protobuf_modules_2fipc_2fmessage_2fprotobuf_2fdata_2fstatic_5finfo_2eproto::InitDefaults();
  return *internal_default_instance();
}

HardwareInfo* HardwareInfo::New(::google::protobuf::Arena* arena) const {
  HardwareInfo* n = new HardwareInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void HardwareInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:atd.data.HardwareInfo)
  configs_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool HardwareInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:atd.data.HardwareInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // map<string, string> configs = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          HardwareInfo_ConfigsEntry::Parser< ::google::protobuf::internal::MapFieldLite<
              HardwareInfo_ConfigsEntry,
              ::std::string, ::std::string,
              ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
              ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
              0 >,
            ::google::protobuf::Map< ::std::string, ::std::string > > parser(&configs_);
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
              input, &parser));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:atd.data.HardwareInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:atd.data.HardwareInfo)
  return false;
#undef DO_
}

void HardwareInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:atd.data.HardwareInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, string> configs = 1;
  if (!this->configs().empty()) {
    typedef ::google::protobuf::Map< ::std::string, ::std::string >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::google::protobuf::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
      }
    };

    if (output->IsSerializationDeterministic() &&
        this->configs().size() > 1) {
      ::google::protobuf::scoped_array<SortItem> items(
          new SortItem[this->configs().size()]);
      typedef ::google::protobuf::Map< ::std::string, ::std::string >::size_type size_type;
      size_type n = 0;
      for (::google::protobuf::Map< ::std::string, ::std::string >::const_iterator
          it = this->configs().begin();
          it != this->configs().end(); ++it, ++n) {
        items[n] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[n], Less());
      ::google::protobuf::scoped_ptr<HardwareInfo_ConfigsEntry> entry;
      for (size_type i = 0; i < n; i++) {
        entry.reset(configs_.NewEntryWrapper(
            items[i]->first, items[i]->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, *entry, output);
        Utf8Check::Check(items[i]);
      }
    } else {
      ::google::protobuf::scoped_ptr<HardwareInfo_ConfigsEntry> entry;
      for (::google::protobuf::Map< ::std::string, ::std::string >::const_iterator
          it = this->configs().begin();
          it != this->configs().end(); ++it) {
        entry.reset(configs_.NewEntryWrapper(
            it->first, it->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, *entry, output);
        Utf8Check::Check(&*it);
      }
    }
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:atd.data.HardwareInfo)
}

size_t HardwareInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:atd.data.HardwareInfo)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  // map<string, string> configs = 1;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->configs_size());
  {
    ::google::protobuf::scoped_ptr<HardwareInfo_ConfigsEntry> entry;
    for (::google::protobuf::Map< ::std::string, ::std::string >::const_iterator
        it = this->configs().begin();
        it != this->configs().end(); ++it) {
      entry.reset(configs_.NewEntryWrapper(it->first, it->second));
      total_size += ::google::protobuf::internal::WireFormatLite::
          MessageSizeNoVirtual(*entry);
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HardwareInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const HardwareInfo*>(&from));
}

void HardwareInfo::MergeFrom(const HardwareInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:atd.data.HardwareInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  configs_.MergeFrom(from.configs_);
}

void HardwareInfo::CopyFrom(const HardwareInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:atd.data.HardwareInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HardwareInfo::IsInitialized() const {
  return true;
}

void HardwareInfo::Swap(HardwareInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void HardwareInfo::InternalSwap(HardwareInfo* other) {
  configs_.Swap(&other->configs_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string HardwareInfo::GetTypeName() const {
  return "atd.data.HardwareInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// HardwareInfo

// map<string, string> configs = 1;
int HardwareInfo::configs_size() const {
  return configs_.size();
}
void HardwareInfo::clear_configs() {
  configs_.Clear();
}
 const ::google::protobuf::Map< ::std::string, ::std::string >&
HardwareInfo::configs() const {
  // @@protoc_insertion_point(field_map:atd.data.HardwareInfo.configs)
  return configs_.GetMap();
}
 ::google::protobuf::Map< ::std::string, ::std::string >*
HardwareInfo::mutable_configs() {
  // @@protoc_insertion_point(field_mutable_map:atd.data.HardwareInfo.configs)
  return configs_.MutableMap();
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if PROTOBUF_INLINE_NOT_IN_HEADERS
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SoftwareInfo::kDockerImageFieldNumber;
const int SoftwareInfo::kCommitIdFieldNumber;
const int SoftwareInfo::kModeFieldNumber;
const int SoftwareInfo::kConfigsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SoftwareInfo::SoftwareInfo()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fipc_2fmessage_2fprotobuf_2fdata_2fstatic_5finfo_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:atd.data.SoftwareInfo)
}
SoftwareInfo::SoftwareInfo(const SoftwareInfo& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  configs_.MergeFrom(from.configs_);
  docker_image_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_docker_image()) {
    docker_image_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.docker_image_);
  }
  commit_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_commit_id()) {
    commit_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.commit_id_);
  }
  mode_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_mode()) {
    mode_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.mode_);
  }
  // @@protoc_insertion_point(copy_constructor:atd.data.SoftwareInfo)
}

void SoftwareInfo::SharedCtor() {
  _cached_size_ = 0;
  docker_image_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  commit_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  mode_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

SoftwareInfo::~SoftwareInfo() {
  // @@protoc_insertion_point(destructor:atd.data.SoftwareInfo)
  SharedDtor();
}

void SoftwareInfo::SharedDtor() {
  docker_image_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  commit_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  mode_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void SoftwareInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SoftwareInfo& SoftwareInfo::default_instance() {
  protobuf_modules_2fipc_2fmessage_2fprotobuf_2fdata_2fstatic_5finfo_2eproto::InitDefaults();
  return *internal_default_instance();
}

SoftwareInfo* SoftwareInfo::New(::google::protobuf::Arena* arena) const {
  SoftwareInfo* n = new SoftwareInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SoftwareInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:atd.data.SoftwareInfo)
  configs_.Clear();
  if (_has_bits_[0 / 32] & 7u) {
    if (has_docker_image()) {
      GOOGLE_DCHECK(!docker_image_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*docker_image_.UnsafeRawStringPointer())->clear();
    }
    if (has_commit_id()) {
      GOOGLE_DCHECK(!commit_id_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*commit_id_.UnsafeRawStringPointer())->clear();
    }
    if (has_mode()) {
      GOOGLE_DCHECK(!mode_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*mode_.UnsafeRawStringPointer())->clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool SoftwareInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:atd.data.SoftwareInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string docker_image = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_docker_image()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string commit_id = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_commit_id()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string mode = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mode()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // map<string, string> configs = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          SoftwareInfo_ConfigsEntry::Parser< ::google::protobuf::internal::MapFieldLite<
              SoftwareInfo_ConfigsEntry,
              ::std::string, ::std::string,
              ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
              ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
              0 >,
            ::google::protobuf::Map< ::std::string, ::std::string > > parser(&configs_);
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
              input, &parser));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:atd.data.SoftwareInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:atd.data.SoftwareInfo)
  return false;
#undef DO_
}

void SoftwareInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:atd.data.SoftwareInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string docker_image = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->docker_image(), output);
  }

  // optional string commit_id = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->commit_id(), output);
  }

  // optional string mode = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->mode(), output);
  }

  // map<string, string> configs = 4;
  if (!this->configs().empty()) {
    typedef ::google::protobuf::Map< ::std::string, ::std::string >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::google::protobuf::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
      }
    };

    if (output->IsSerializationDeterministic() &&
        this->configs().size() > 1) {
      ::google::protobuf::scoped_array<SortItem> items(
          new SortItem[this->configs().size()]);
      typedef ::google::protobuf::Map< ::std::string, ::std::string >::size_type size_type;
      size_type n = 0;
      for (::google::protobuf::Map< ::std::string, ::std::string >::const_iterator
          it = this->configs().begin();
          it != this->configs().end(); ++it, ++n) {
        items[n] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[n], Less());
      ::google::protobuf::scoped_ptr<SoftwareInfo_ConfigsEntry> entry;
      for (size_type i = 0; i < n; i++) {
        entry.reset(configs_.NewEntryWrapper(
            items[i]->first, items[i]->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            4, *entry, output);
        Utf8Check::Check(items[i]);
      }
    } else {
      ::google::protobuf::scoped_ptr<SoftwareInfo_ConfigsEntry> entry;
      for (::google::protobuf::Map< ::std::string, ::std::string >::const_iterator
          it = this->configs().begin();
          it != this->configs().end(); ++it) {
        entry.reset(configs_.NewEntryWrapper(
            it->first, it->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            4, *entry, output);
        Utf8Check::Check(&*it);
      }
    }
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:atd.data.SoftwareInfo)
}

size_t SoftwareInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:atd.data.SoftwareInfo)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  // map<string, string> configs = 4;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->configs_size());
  {
    ::google::protobuf::scoped_ptr<SoftwareInfo_ConfigsEntry> entry;
    for (::google::protobuf::Map< ::std::string, ::std::string >::const_iterator
        it = this->configs().begin();
        it != this->configs().end(); ++it) {
      entry.reset(configs_.NewEntryWrapper(it->first, it->second));
      total_size += ::google::protobuf::internal::WireFormatLite::
          MessageSizeNoVirtual(*entry);
    }
  }

  if (_has_bits_[0 / 32] & 7u) {
    // optional string docker_image = 1;
    if (has_docker_image()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->docker_image());
    }

    // optional string commit_id = 2;
    if (has_commit_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->commit_id());
    }

    // optional string mode = 3;
    if (has_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->mode());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SoftwareInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SoftwareInfo*>(&from));
}

void SoftwareInfo::MergeFrom(const SoftwareInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:atd.data.SoftwareInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  configs_.MergeFrom(from.configs_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_docker_image();
      docker_image_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.docker_image_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_commit_id();
      commit_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.commit_id_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_mode();
      mode_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.mode_);
    }
  }
}

void SoftwareInfo::CopyFrom(const SoftwareInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:atd.data.SoftwareInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SoftwareInfo::IsInitialized() const {
  return true;
}

void SoftwareInfo::Swap(SoftwareInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SoftwareInfo::InternalSwap(SoftwareInfo* other) {
  configs_.Swap(&other->configs_);
  docker_image_.Swap(&other->docker_image_);
  commit_id_.Swap(&other->commit_id_);
  mode_.Swap(&other->mode_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string SoftwareInfo::GetTypeName() const {
  return "atd.data.SoftwareInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SoftwareInfo

// optional string docker_image = 1;
bool SoftwareInfo::has_docker_image() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SoftwareInfo::set_has_docker_image() {
  _has_bits_[0] |= 0x00000001u;
}
void SoftwareInfo::clear_has_docker_image() {
  _has_bits_[0] &= ~0x00000001u;
}
void SoftwareInfo::clear_docker_image() {
  docker_image_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_docker_image();
}
const ::std::string& SoftwareInfo::docker_image() const {
  // @@protoc_insertion_point(field_get:atd.data.SoftwareInfo.docker_image)
  return docker_image_.GetNoArena();
}
void SoftwareInfo::set_docker_image(const ::std::string& value) {
  set_has_docker_image();
  docker_image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:atd.data.SoftwareInfo.docker_image)
}
#if LANG_CXX11
void SoftwareInfo::set_docker_image(::std::string&& value) {
  set_has_docker_image();
  docker_image_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:atd.data.SoftwareInfo.docker_image)
}
#endif
void SoftwareInfo::set_docker_image(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_docker_image();
  docker_image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:atd.data.SoftwareInfo.docker_image)
}
void SoftwareInfo::set_docker_image(const char* value, size_t size) {
  set_has_docker_image();
  docker_image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:atd.data.SoftwareInfo.docker_image)
}
::std::string* SoftwareInfo::mutable_docker_image() {
  set_has_docker_image();
  // @@protoc_insertion_point(field_mutable:atd.data.SoftwareInfo.docker_image)
  return docker_image_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* SoftwareInfo::release_docker_image() {
  // @@protoc_insertion_point(field_release:atd.data.SoftwareInfo.docker_image)
  clear_has_docker_image();
  return docker_image_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void SoftwareInfo::set_allocated_docker_image(::std::string* docker_image) {
  if (docker_image != NULL) {
    set_has_docker_image();
  } else {
    clear_has_docker_image();
  }
  docker_image_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), docker_image);
  // @@protoc_insertion_point(field_set_allocated:atd.data.SoftwareInfo.docker_image)
}

// optional string commit_id = 2;
bool SoftwareInfo::has_commit_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void SoftwareInfo::set_has_commit_id() {
  _has_bits_[0] |= 0x00000002u;
}
void SoftwareInfo::clear_has_commit_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void SoftwareInfo::clear_commit_id() {
  commit_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_commit_id();
}
const ::std::string& SoftwareInfo::commit_id() const {
  // @@protoc_insertion_point(field_get:atd.data.SoftwareInfo.commit_id)
  return commit_id_.GetNoArena();
}
void SoftwareInfo::set_commit_id(const ::std::string& value) {
  set_has_commit_id();
  commit_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:atd.data.SoftwareInfo.commit_id)
}
#if LANG_CXX11
void SoftwareInfo::set_commit_id(::std::string&& value) {
  set_has_commit_id();
  commit_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:atd.data.SoftwareInfo.commit_id)
}
#endif
void SoftwareInfo::set_commit_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_commit_id();
  commit_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:atd.data.SoftwareInfo.commit_id)
}
void SoftwareInfo::set_commit_id(const char* value, size_t size) {
  set_has_commit_id();
  commit_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:atd.data.SoftwareInfo.commit_id)
}
::std::string* SoftwareInfo::mutable_commit_id() {
  set_has_commit_id();
  // @@protoc_insertion_point(field_mutable:atd.data.SoftwareInfo.commit_id)
  return commit_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* SoftwareInfo::release_commit_id() {
  // @@protoc_insertion_point(field_release:atd.data.SoftwareInfo.commit_id)
  clear_has_commit_id();
  return commit_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void SoftwareInfo::set_allocated_commit_id(::std::string* commit_id) {
  if (commit_id != NULL) {
    set_has_commit_id();
  } else {
    clear_has_commit_id();
  }
  commit_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), commit_id);
  // @@protoc_insertion_point(field_set_allocated:atd.data.SoftwareInfo.commit_id)
}

// optional string mode = 3;
bool SoftwareInfo::has_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void SoftwareInfo::set_has_mode() {
  _has_bits_[0] |= 0x00000004u;
}
void SoftwareInfo::clear_has_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
void SoftwareInfo::clear_mode() {
  mode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mode();
}
const ::std::string& SoftwareInfo::mode() const {
  // @@protoc_insertion_point(field_get:atd.data.SoftwareInfo.mode)
  return mode_.GetNoArena();
}
void SoftwareInfo::set_mode(const ::std::string& value) {
  set_has_mode();
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:atd.data.SoftwareInfo.mode)
}
#if LANG_CXX11
void SoftwareInfo::set_mode(::std::string&& value) {
  set_has_mode();
  mode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:atd.data.SoftwareInfo.mode)
}
#endif
void SoftwareInfo::set_mode(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_mode();
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:atd.data.SoftwareInfo.mode)
}
void SoftwareInfo::set_mode(const char* value, size_t size) {
  set_has_mode();
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:atd.data.SoftwareInfo.mode)
}
::std::string* SoftwareInfo::mutable_mode() {
  set_has_mode();
  // @@protoc_insertion_point(field_mutable:atd.data.SoftwareInfo.mode)
  return mode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* SoftwareInfo::release_mode() {
  // @@protoc_insertion_point(field_release:atd.data.SoftwareInfo.mode)
  clear_has_mode();
  return mode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void SoftwareInfo::set_allocated_mode(::std::string* mode) {
  if (mode != NULL) {
    set_has_mode();
  } else {
    clear_has_mode();
  }
  mode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mode);
  // @@protoc_insertion_point(field_set_allocated:atd.data.SoftwareInfo.mode)
}

// map<string, string> configs = 4;
int SoftwareInfo::configs_size() const {
  return configs_.size();
}
void SoftwareInfo::clear_configs() {
  configs_.Clear();
}
 const ::google::protobuf::Map< ::std::string, ::std::string >&
SoftwareInfo::configs() const {
  // @@protoc_insertion_point(field_map:atd.data.SoftwareInfo.configs)
  return configs_.GetMap();
}
 ::google::protobuf::Map< ::std::string, ::std::string >*
SoftwareInfo::mutable_configs() {
  // @@protoc_insertion_point(field_mutable_map:atd.data.SoftwareInfo.configs)
  return configs_.MutableMap();
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int UserInfo::kEntityFieldNumber;
const int UserInfo::kDriverFieldNumber;
const int UserInfo::kCoDriverFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

UserInfo::UserInfo()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fipc_2fmessage_2fprotobuf_2fdata_2fstatic_5finfo_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:atd.data.UserInfo)
}
UserInfo::UserInfo(const UserInfo& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  entity_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_entity()) {
    entity_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.entity_);
  }
  driver_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_driver()) {
    driver_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.driver_);
  }
  co_driver_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_co_driver()) {
    co_driver_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.co_driver_);
  }
  // @@protoc_insertion_point(copy_constructor:atd.data.UserInfo)
}

void UserInfo::SharedCtor() {
  _cached_size_ = 0;
  entity_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  driver_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  co_driver_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

UserInfo::~UserInfo() {
  // @@protoc_insertion_point(destructor:atd.data.UserInfo)
  SharedDtor();
}

void UserInfo::SharedDtor() {
  entity_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  driver_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  co_driver_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void UserInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UserInfo& UserInfo::default_instance() {
  protobuf_modules_2fipc_2fmessage_2fprotobuf_2fdata_2fstatic_5finfo_2eproto::InitDefaults();
  return *internal_default_instance();
}

UserInfo* UserInfo::New(::google::protobuf::Arena* arena) const {
  UserInfo* n = new UserInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void UserInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:atd.data.UserInfo)
  if (_has_bits_[0 / 32] & 7u) {
    if (has_entity()) {
      GOOGLE_DCHECK(!entity_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*entity_.UnsafeRawStringPointer())->clear();
    }
    if (has_driver()) {
      GOOGLE_DCHECK(!driver_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*driver_.UnsafeRawStringPointer())->clear();
    }
    if (has_co_driver()) {
      GOOGLE_DCHECK(!co_driver_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*co_driver_.UnsafeRawStringPointer())->clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool UserInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:atd.data.UserInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string entity = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_entity()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string driver = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_driver()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string co_driver = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_co_driver()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:atd.data.UserInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:atd.data.UserInfo)
  return false;
#undef DO_
}

void UserInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:atd.data.UserInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string entity = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->entity(), output);
  }

  // optional string driver = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->driver(), output);
  }

  // optional string co_driver = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->co_driver(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:atd.data.UserInfo)
}

size_t UserInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:atd.data.UserInfo)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  if (_has_bits_[0 / 32] & 7u) {
    // optional string entity = 1;
    if (has_entity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->entity());
    }

    // optional string driver = 2;
    if (has_driver()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->driver());
    }

    // optional string co_driver = 3;
    if (has_co_driver()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->co_driver());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UserInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UserInfo*>(&from));
}

void UserInfo::MergeFrom(const UserInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:atd.data.UserInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_entity();
      entity_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.entity_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_driver();
      driver_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.driver_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_co_driver();
      co_driver_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.co_driver_);
    }
  }
}

void UserInfo::CopyFrom(const UserInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:atd.data.UserInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserInfo::IsInitialized() const {
  return true;
}

void UserInfo::Swap(UserInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void UserInfo::InternalSwap(UserInfo* other) {
  entity_.Swap(&other->entity_);
  driver_.Swap(&other->driver_);
  co_driver_.Swap(&other->co_driver_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string UserInfo::GetTypeName() const {
  return "atd.data.UserInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// UserInfo

// optional string entity = 1;
bool UserInfo::has_entity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void UserInfo::set_has_entity() {
  _has_bits_[0] |= 0x00000001u;
}
void UserInfo::clear_has_entity() {
  _has_bits_[0] &= ~0x00000001u;
}
void UserInfo::clear_entity() {
  entity_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_entity();
}
const ::std::string& UserInfo::entity() const {
  // @@protoc_insertion_point(field_get:atd.data.UserInfo.entity)
  return entity_.GetNoArena();
}
void UserInfo::set_entity(const ::std::string& value) {
  set_has_entity();
  entity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:atd.data.UserInfo.entity)
}
#if LANG_CXX11
void UserInfo::set_entity(::std::string&& value) {
  set_has_entity();
  entity_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:atd.data.UserInfo.entity)
}
#endif
void UserInfo::set_entity(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_entity();
  entity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:atd.data.UserInfo.entity)
}
void UserInfo::set_entity(const char* value, size_t size) {
  set_has_entity();
  entity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:atd.data.UserInfo.entity)
}
::std::string* UserInfo::mutable_entity() {
  set_has_entity();
  // @@protoc_insertion_point(field_mutable:atd.data.UserInfo.entity)
  return entity_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* UserInfo::release_entity() {
  // @@protoc_insertion_point(field_release:atd.data.UserInfo.entity)
  clear_has_entity();
  return entity_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void UserInfo::set_allocated_entity(::std::string* entity) {
  if (entity != NULL) {
    set_has_entity();
  } else {
    clear_has_entity();
  }
  entity_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), entity);
  // @@protoc_insertion_point(field_set_allocated:atd.data.UserInfo.entity)
}

// optional string driver = 2;
bool UserInfo::has_driver() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void UserInfo::set_has_driver() {
  _has_bits_[0] |= 0x00000002u;
}
void UserInfo::clear_has_driver() {
  _has_bits_[0] &= ~0x00000002u;
}
void UserInfo::clear_driver() {
  driver_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_driver();
}
const ::std::string& UserInfo::driver() const {
  // @@protoc_insertion_point(field_get:atd.data.UserInfo.driver)
  return driver_.GetNoArena();
}
void UserInfo::set_driver(const ::std::string& value) {
  set_has_driver();
  driver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:atd.data.UserInfo.driver)
}
#if LANG_CXX11
void UserInfo::set_driver(::std::string&& value) {
  set_has_driver();
  driver_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:atd.data.UserInfo.driver)
}
#endif
void UserInfo::set_driver(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_driver();
  driver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:atd.data.UserInfo.driver)
}
void UserInfo::set_driver(const char* value, size_t size) {
  set_has_driver();
  driver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:atd.data.UserInfo.driver)
}
::std::string* UserInfo::mutable_driver() {
  set_has_driver();
  // @@protoc_insertion_point(field_mutable:atd.data.UserInfo.driver)
  return driver_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* UserInfo::release_driver() {
  // @@protoc_insertion_point(field_release:atd.data.UserInfo.driver)
  clear_has_driver();
  return driver_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void UserInfo::set_allocated_driver(::std::string* driver) {
  if (driver != NULL) {
    set_has_driver();
  } else {
    clear_has_driver();
  }
  driver_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), driver);
  // @@protoc_insertion_point(field_set_allocated:atd.data.UserInfo.driver)
}

// optional string co_driver = 3;
bool UserInfo::has_co_driver() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void UserInfo::set_has_co_driver() {
  _has_bits_[0] |= 0x00000004u;
}
void UserInfo::clear_has_co_driver() {
  _has_bits_[0] &= ~0x00000004u;
}
void UserInfo::clear_co_driver() {
  co_driver_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_co_driver();
}
const ::std::string& UserInfo::co_driver() const {
  // @@protoc_insertion_point(field_get:atd.data.UserInfo.co_driver)
  return co_driver_.GetNoArena();
}
void UserInfo::set_co_driver(const ::std::string& value) {
  set_has_co_driver();
  co_driver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:atd.data.UserInfo.co_driver)
}
#if LANG_CXX11
void UserInfo::set_co_driver(::std::string&& value) {
  set_has_co_driver();
  co_driver_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:atd.data.UserInfo.co_driver)
}
#endif
void UserInfo::set_co_driver(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_co_driver();
  co_driver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:atd.data.UserInfo.co_driver)
}
void UserInfo::set_co_driver(const char* value, size_t size) {
  set_has_co_driver();
  co_driver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:atd.data.UserInfo.co_driver)
}
::std::string* UserInfo::mutable_co_driver() {
  set_has_co_driver();
  // @@protoc_insertion_point(field_mutable:atd.data.UserInfo.co_driver)
  return co_driver_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* UserInfo::release_co_driver() {
  // @@protoc_insertion_point(field_release:atd.data.UserInfo.co_driver)
  clear_has_co_driver();
  return co_driver_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void UserInfo::set_allocated_co_driver(::std::string* co_driver) {
  if (co_driver != NULL) {
    set_has_co_driver();
  } else {
    clear_has_co_driver();
  }
  co_driver_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), co_driver);
  // @@protoc_insertion_point(field_set_allocated:atd.data.UserInfo.co_driver)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int StaticInfo::kVehicleFieldNumber;
const int StaticInfo::kEnvironmentFieldNumber;
const int StaticInfo::kHardwareFieldNumber;
const int StaticInfo::kSoftwareFieldNumber;
const int StaticInfo::kUserFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

StaticInfo::StaticInfo()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fipc_2fmessage_2fprotobuf_2fdata_2fstatic_5finfo_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:atd.data.StaticInfo)
}
StaticInfo::StaticInfo(const StaticInfo& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_vehicle()) {
    vehicle_ = new ::atd::data::VehicleInfo(*from.vehicle_);
  } else {
    vehicle_ = NULL;
  }
  if (from.has_environment()) {
    environment_ = new ::atd::data::EnvironmentInfo(*from.environment_);
  } else {
    environment_ = NULL;
  }
  if (from.has_hardware()) {
    hardware_ = new ::atd::data::HardwareInfo(*from.hardware_);
  } else {
    hardware_ = NULL;
  }
  if (from.has_software()) {
    software_ = new ::atd::data::SoftwareInfo(*from.software_);
  } else {
    software_ = NULL;
  }
  if (from.has_user()) {
    user_ = new ::atd::data::UserInfo(*from.user_);
  } else {
    user_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:atd.data.StaticInfo)
}

void StaticInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&vehicle_, 0, reinterpret_cast<char*>(&user_) -
    reinterpret_cast<char*>(&vehicle_) + sizeof(user_));
}

StaticInfo::~StaticInfo() {
  // @@protoc_insertion_point(destructor:atd.data.StaticInfo)
  SharedDtor();
}

void StaticInfo::SharedDtor() {
  if (this != internal_default_instance()) {
    delete vehicle_;
  }
  if (this != internal_default_instance()) {
    delete environment_;
  }
  if (this != internal_default_instance()) {
    delete hardware_;
  }
  if (this != internal_default_instance()) {
    delete software_;
  }
  if (this != internal_default_instance()) {
    delete user_;
  }
}

void StaticInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StaticInfo& StaticInfo::default_instance() {
  protobuf_modules_2fipc_2fmessage_2fprotobuf_2fdata_2fstatic_5finfo_2eproto::InitDefaults();
  return *internal_default_instance();
}

StaticInfo* StaticInfo::New(::google::protobuf::Arena* arena) const {
  StaticInfo* n = new StaticInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void StaticInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:atd.data.StaticInfo)
  if (_has_bits_[0 / 32] & 31u) {
    if (has_vehicle()) {
      GOOGLE_DCHECK(vehicle_ != NULL);
      vehicle_->::atd::data::VehicleInfo::Clear();
    }
    if (has_environment()) {
      GOOGLE_DCHECK(environment_ != NULL);
      environment_->::atd::data::EnvironmentInfo::Clear();
    }
    if (has_hardware()) {
      GOOGLE_DCHECK(hardware_ != NULL);
      hardware_->::atd::data::HardwareInfo::Clear();
    }
    if (has_software()) {
      GOOGLE_DCHECK(software_ != NULL);
      software_->::atd::data::SoftwareInfo::Clear();
    }
    if (has_user()) {
      GOOGLE_DCHECK(user_ != NULL);
      user_->::atd::data::UserInfo::Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool StaticInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:atd.data.StaticInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .atd.data.VehicleInfo vehicle = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_vehicle()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .atd.data.EnvironmentInfo environment = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_environment()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .atd.data.HardwareInfo hardware = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_hardware()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .atd.data.SoftwareInfo software = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_software()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .atd.data.UserInfo user = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:atd.data.StaticInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:atd.data.StaticInfo)
  return false;
#undef DO_
}

void StaticInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:atd.data.StaticInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .atd.data.VehicleInfo vehicle = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->vehicle_, output);
  }

  // optional .atd.data.EnvironmentInfo environment = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->environment_, output);
  }

  // optional .atd.data.HardwareInfo hardware = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->hardware_, output);
  }

  // optional .atd.data.SoftwareInfo software = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *this->software_, output);
  }

  // optional .atd.data.UserInfo user = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, *this->user_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:atd.data.StaticInfo)
}

size_t StaticInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:atd.data.StaticInfo)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  if (_has_bits_[0 / 32] & 31u) {
    // optional .atd.data.VehicleInfo vehicle = 1;
    if (has_vehicle()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->vehicle_);
    }

    // optional .atd.data.EnvironmentInfo environment = 2;
    if (has_environment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->environment_);
    }

    // optional .atd.data.HardwareInfo hardware = 3;
    if (has_hardware()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->hardware_);
    }

    // optional .atd.data.SoftwareInfo software = 4;
    if (has_software()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->software_);
    }

    // optional .atd.data.UserInfo user = 5;
    if (has_user()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->user_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StaticInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StaticInfo*>(&from));
}

void StaticInfo::MergeFrom(const StaticInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:atd.data.StaticInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_vehicle()->::atd::data::VehicleInfo::MergeFrom(from.vehicle());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_environment()->::atd::data::EnvironmentInfo::MergeFrom(from.environment());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_hardware()->::atd::data::HardwareInfo::MergeFrom(from.hardware());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_software()->::atd::data::SoftwareInfo::MergeFrom(from.software());
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_user()->::atd::data::UserInfo::MergeFrom(from.user());
    }
  }
}

void StaticInfo::CopyFrom(const StaticInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:atd.data.StaticInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StaticInfo::IsInitialized() const {
  return true;
}

void StaticInfo::Swap(StaticInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void StaticInfo::InternalSwap(StaticInfo* other) {
  std::swap(vehicle_, other->vehicle_);
  std::swap(environment_, other->environment_);
  std::swap(hardware_, other->hardware_);
  std::swap(software_, other->software_);
  std::swap(user_, other->user_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string StaticInfo::GetTypeName() const {
  return "atd.data.StaticInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// StaticInfo

// optional .atd.data.VehicleInfo vehicle = 1;
bool StaticInfo::has_vehicle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void StaticInfo::set_has_vehicle() {
  _has_bits_[0] |= 0x00000001u;
}
void StaticInfo::clear_has_vehicle() {
  _has_bits_[0] &= ~0x00000001u;
}
void StaticInfo::clear_vehicle() {
  if (vehicle_ != NULL) vehicle_->::atd::data::VehicleInfo::Clear();
  clear_has_vehicle();
}
const ::atd::data::VehicleInfo& StaticInfo::vehicle() const {
  // @@protoc_insertion_point(field_get:atd.data.StaticInfo.vehicle)
  return vehicle_ != NULL ? *vehicle_
                         : *::atd::data::VehicleInfo::internal_default_instance();
}
::atd::data::VehicleInfo* StaticInfo::mutable_vehicle() {
  set_has_vehicle();
  if (vehicle_ == NULL) {
    vehicle_ = new ::atd::data::VehicleInfo;
  }
  // @@protoc_insertion_point(field_mutable:atd.data.StaticInfo.vehicle)
  return vehicle_;
}
::atd::data::VehicleInfo* StaticInfo::release_vehicle() {
  // @@protoc_insertion_point(field_release:atd.data.StaticInfo.vehicle)
  clear_has_vehicle();
  ::atd::data::VehicleInfo* temp = vehicle_;
  vehicle_ = NULL;
  return temp;
}
void StaticInfo::set_allocated_vehicle(::atd::data::VehicleInfo* vehicle) {
  delete vehicle_;
  vehicle_ = vehicle;
  if (vehicle) {
    set_has_vehicle();
  } else {
    clear_has_vehicle();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.data.StaticInfo.vehicle)
}

// optional .atd.data.EnvironmentInfo environment = 2;
bool StaticInfo::has_environment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void StaticInfo::set_has_environment() {
  _has_bits_[0] |= 0x00000002u;
}
void StaticInfo::clear_has_environment() {
  _has_bits_[0] &= ~0x00000002u;
}
void StaticInfo::clear_environment() {
  if (environment_ != NULL) environment_->::atd::data::EnvironmentInfo::Clear();
  clear_has_environment();
}
const ::atd::data::EnvironmentInfo& StaticInfo::environment() const {
  // @@protoc_insertion_point(field_get:atd.data.StaticInfo.environment)
  return environment_ != NULL ? *environment_
                         : *::atd::data::EnvironmentInfo::internal_default_instance();
}
::atd::data::EnvironmentInfo* StaticInfo::mutable_environment() {
  set_has_environment();
  if (environment_ == NULL) {
    environment_ = new ::atd::data::EnvironmentInfo;
  }
  // @@protoc_insertion_point(field_mutable:atd.data.StaticInfo.environment)
  return environment_;
}
::atd::data::EnvironmentInfo* StaticInfo::release_environment() {
  // @@protoc_insertion_point(field_release:atd.data.StaticInfo.environment)
  clear_has_environment();
  ::atd::data::EnvironmentInfo* temp = environment_;
  environment_ = NULL;
  return temp;
}
void StaticInfo::set_allocated_environment(::atd::data::EnvironmentInfo* environment) {
  delete environment_;
  environment_ = environment;
  if (environment) {
    set_has_environment();
  } else {
    clear_has_environment();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.data.StaticInfo.environment)
}

// optional .atd.data.HardwareInfo hardware = 3;
bool StaticInfo::has_hardware() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void StaticInfo::set_has_hardware() {
  _has_bits_[0] |= 0x00000004u;
}
void StaticInfo::clear_has_hardware() {
  _has_bits_[0] &= ~0x00000004u;
}
void StaticInfo::clear_hardware() {
  if (hardware_ != NULL) hardware_->::atd::data::HardwareInfo::Clear();
  clear_has_hardware();
}
const ::atd::data::HardwareInfo& StaticInfo::hardware() const {
  // @@protoc_insertion_point(field_get:atd.data.StaticInfo.hardware)
  return hardware_ != NULL ? *hardware_
                         : *::atd::data::HardwareInfo::internal_default_instance();
}
::atd::data::HardwareInfo* StaticInfo::mutable_hardware() {
  set_has_hardware();
  if (hardware_ == NULL) {
    hardware_ = new ::atd::data::HardwareInfo;
  }
  // @@protoc_insertion_point(field_mutable:atd.data.StaticInfo.hardware)
  return hardware_;
}
::atd::data::HardwareInfo* StaticInfo::release_hardware() {
  // @@protoc_insertion_point(field_release:atd.data.StaticInfo.hardware)
  clear_has_hardware();
  ::atd::data::HardwareInfo* temp = hardware_;
  hardware_ = NULL;
  return temp;
}
void StaticInfo::set_allocated_hardware(::atd::data::HardwareInfo* hardware) {
  delete hardware_;
  hardware_ = hardware;
  if (hardware) {
    set_has_hardware();
  } else {
    clear_has_hardware();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.data.StaticInfo.hardware)
}

// optional .atd.data.SoftwareInfo software = 4;
bool StaticInfo::has_software() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void StaticInfo::set_has_software() {
  _has_bits_[0] |= 0x00000008u;
}
void StaticInfo::clear_has_software() {
  _has_bits_[0] &= ~0x00000008u;
}
void StaticInfo::clear_software() {
  if (software_ != NULL) software_->::atd::data::SoftwareInfo::Clear();
  clear_has_software();
}
const ::atd::data::SoftwareInfo& StaticInfo::software() const {
  // @@protoc_insertion_point(field_get:atd.data.StaticInfo.software)
  return software_ != NULL ? *software_
                         : *::atd::data::SoftwareInfo::internal_default_instance();
}
::atd::data::SoftwareInfo* StaticInfo::mutable_software() {
  set_has_software();
  if (software_ == NULL) {
    software_ = new ::atd::data::SoftwareInfo;
  }
  // @@protoc_insertion_point(field_mutable:atd.data.StaticInfo.software)
  return software_;
}
::atd::data::SoftwareInfo* StaticInfo::release_software() {
  // @@protoc_insertion_point(field_release:atd.data.StaticInfo.software)
  clear_has_software();
  ::atd::data::SoftwareInfo* temp = software_;
  software_ = NULL;
  return temp;
}
void StaticInfo::set_allocated_software(::atd::data::SoftwareInfo* software) {
  delete software_;
  software_ = software;
  if (software) {
    set_has_software();
  } else {
    clear_has_software();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.data.StaticInfo.software)
}

// optional .atd.data.UserInfo user = 5;
bool StaticInfo::has_user() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void StaticInfo::set_has_user() {
  _has_bits_[0] |= 0x00000010u;
}
void StaticInfo::clear_has_user() {
  _has_bits_[0] &= ~0x00000010u;
}
void StaticInfo::clear_user() {
  if (user_ != NULL) user_->::atd::data::UserInfo::Clear();
  clear_has_user();
}
const ::atd::data::UserInfo& StaticInfo::user() const {
  // @@protoc_insertion_point(field_get:atd.data.StaticInfo.user)
  return user_ != NULL ? *user_
                         : *::atd::data::UserInfo::internal_default_instance();
}
::atd::data::UserInfo* StaticInfo::mutable_user() {
  set_has_user();
  if (user_ == NULL) {
    user_ = new ::atd::data::UserInfo;
  }
  // @@protoc_insertion_point(field_mutable:atd.data.StaticInfo.user)
  return user_;
}
::atd::data::UserInfo* StaticInfo::release_user() {
  // @@protoc_insertion_point(field_release:atd.data.StaticInfo.user)
  clear_has_user();
  ::atd::data::UserInfo* temp = user_;
  user_ = NULL;
  return temp;
}
void StaticInfo::set_allocated_user(::atd::data::UserInfo* user) {
  delete user_;
  user_ = user;
  if (user) {
    set_has_user();
  } else {
    clear_has_user();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.data.StaticInfo.user)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int StaticInfoConf::kHardwareConfigsFieldNumber;
const int StaticInfoConf::kSoftwareConfigsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

StaticInfoConf::StaticInfoConf()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fipc_2fmessage_2fprotobuf_2fdata_2fstatic_5finfo_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:atd.data.StaticInfoConf)
}
StaticInfoConf::StaticInfoConf(const StaticInfoConf& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      hardware_configs_(from.hardware_configs_),
      software_configs_(from.software_configs_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:atd.data.StaticInfoConf)
}

void StaticInfoConf::SharedCtor() {
  _cached_size_ = 0;
}

StaticInfoConf::~StaticInfoConf() {
  // @@protoc_insertion_point(destructor:atd.data.StaticInfoConf)
  SharedDtor();
}

void StaticInfoConf::SharedDtor() {
}

void StaticInfoConf::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StaticInfoConf& StaticInfoConf::default_instance() {
  protobuf_modules_2fipc_2fmessage_2fprotobuf_2fdata_2fstatic_5finfo_2eproto::InitDefaults();
  return *internal_default_instance();
}

StaticInfoConf* StaticInfoConf::New(::google::protobuf::Arena* arena) const {
  StaticInfoConf* n = new StaticInfoConf;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void StaticInfoConf::Clear() {
// @@protoc_insertion_point(message_clear_start:atd.data.StaticInfoConf)
  hardware_configs_.Clear();
  software_configs_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool StaticInfoConf::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:atd.data.StaticInfoConf)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string hardware_configs = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_hardware_configs()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated string software_configs = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_software_configs()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:atd.data.StaticInfoConf)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:atd.data.StaticInfoConf)
  return false;
#undef DO_
}

void StaticInfoConf::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:atd.data.StaticInfoConf)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string hardware_configs = 1;
  for (int i = 0, n = this->hardware_configs_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->hardware_configs(i), output);
  }

  // repeated string software_configs = 2;
  for (int i = 0, n = this->software_configs_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->software_configs(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:atd.data.StaticInfoConf)
}

size_t StaticInfoConf::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:atd.data.StaticInfoConf)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  // repeated string hardware_configs = 1;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->hardware_configs_size());
  for (int i = 0, n = this->hardware_configs_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->hardware_configs(i));
  }

  // repeated string software_configs = 2;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->software_configs_size());
  for (int i = 0, n = this->software_configs_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->software_configs(i));
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StaticInfoConf::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StaticInfoConf*>(&from));
}

void StaticInfoConf::MergeFrom(const StaticInfoConf& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:atd.data.StaticInfoConf)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  hardware_configs_.MergeFrom(from.hardware_configs_);
  software_configs_.MergeFrom(from.software_configs_);
}

void StaticInfoConf::CopyFrom(const StaticInfoConf& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:atd.data.StaticInfoConf)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StaticInfoConf::IsInitialized() const {
  return true;
}

void StaticInfoConf::Swap(StaticInfoConf* other) {
  if (other == this) return;
  InternalSwap(other);
}
void StaticInfoConf::InternalSwap(StaticInfoConf* other) {
  hardware_configs_.InternalSwap(&other->hardware_configs_);
  software_configs_.InternalSwap(&other->software_configs_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string StaticInfoConf::GetTypeName() const {
  return "atd.data.StaticInfoConf";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// StaticInfoConf

// repeated string hardware_configs = 1;
int StaticInfoConf::hardware_configs_size() const {
  return hardware_configs_.size();
}
void StaticInfoConf::clear_hardware_configs() {
  hardware_configs_.Clear();
}
const ::std::string& StaticInfoConf::hardware_configs(int index) const {
  // @@protoc_insertion_point(field_get:atd.data.StaticInfoConf.hardware_configs)
  return hardware_configs_.Get(index);
}
::std::string* StaticInfoConf::mutable_hardware_configs(int index) {
  // @@protoc_insertion_point(field_mutable:atd.data.StaticInfoConf.hardware_configs)
  return hardware_configs_.Mutable(index);
}
void StaticInfoConf::set_hardware_configs(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:atd.data.StaticInfoConf.hardware_configs)
  hardware_configs_.Mutable(index)->assign(value);
}
#if LANG_CXX11
void StaticInfoConf::set_hardware_configs(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:atd.data.StaticInfoConf.hardware_configs)
  hardware_configs_.Mutable(index)->assign(std::move(value));
}
#endif
void StaticInfoConf::set_hardware_configs(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  hardware_configs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:atd.data.StaticInfoConf.hardware_configs)
}
void StaticInfoConf::set_hardware_configs(int index, const char* value, size_t size) {
  hardware_configs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:atd.data.StaticInfoConf.hardware_configs)
}
::std::string* StaticInfoConf::add_hardware_configs() {
  // @@protoc_insertion_point(field_add_mutable:atd.data.StaticInfoConf.hardware_configs)
  return hardware_configs_.Add();
}
void StaticInfoConf::add_hardware_configs(const ::std::string& value) {
  hardware_configs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:atd.data.StaticInfoConf.hardware_configs)
}
#if LANG_CXX11
void StaticInfoConf::add_hardware_configs(::std::string&& value) {
  hardware_configs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:atd.data.StaticInfoConf.hardware_configs)
}
#endif
void StaticInfoConf::add_hardware_configs(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  hardware_configs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:atd.data.StaticInfoConf.hardware_configs)
}
void StaticInfoConf::add_hardware_configs(const char* value, size_t size) {
  hardware_configs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:atd.data.StaticInfoConf.hardware_configs)
}
const ::google::protobuf::RepeatedPtrField< ::std::string>&
StaticInfoConf::hardware_configs() const {
  // @@protoc_insertion_point(field_list:atd.data.StaticInfoConf.hardware_configs)
  return hardware_configs_;
}
::google::protobuf::RepeatedPtrField< ::std::string>*
StaticInfoConf::mutable_hardware_configs() {
  // @@protoc_insertion_point(field_mutable_list:atd.data.StaticInfoConf.hardware_configs)
  return &hardware_configs_;
}

// repeated string software_configs = 2;
int StaticInfoConf::software_configs_size() const {
  return software_configs_.size();
}
void StaticInfoConf::clear_software_configs() {
  software_configs_.Clear();
}
const ::std::string& StaticInfoConf::software_configs(int index) const {
  // @@protoc_insertion_point(field_get:atd.data.StaticInfoConf.software_configs)
  return software_configs_.Get(index);
}
::std::string* StaticInfoConf::mutable_software_configs(int index) {
  // @@protoc_insertion_point(field_mutable:atd.data.StaticInfoConf.software_configs)
  return software_configs_.Mutable(index);
}
void StaticInfoConf::set_software_configs(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:atd.data.StaticInfoConf.software_configs)
  software_configs_.Mutable(index)->assign(value);
}
#if LANG_CXX11
void StaticInfoConf::set_software_configs(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:atd.data.StaticInfoConf.software_configs)
  software_configs_.Mutable(index)->assign(std::move(value));
}
#endif
void StaticInfoConf::set_software_configs(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  software_configs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:atd.data.StaticInfoConf.software_configs)
}
void StaticInfoConf::set_software_configs(int index, const char* value, size_t size) {
  software_configs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:atd.data.StaticInfoConf.software_configs)
}
::std::string* StaticInfoConf::add_software_configs() {
  // @@protoc_insertion_point(field_add_mutable:atd.data.StaticInfoConf.software_configs)
  return software_configs_.Add();
}
void StaticInfoConf::add_software_configs(const ::std::string& value) {
  software_configs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:atd.data.StaticInfoConf.software_configs)
}
#if LANG_CXX11
void StaticInfoConf::add_software_configs(::std::string&& value) {
  software_configs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:atd.data.StaticInfoConf.software_configs)
}
#endif
void StaticInfoConf::add_software_configs(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  software_configs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:atd.data.StaticInfoConf.software_configs)
}
void StaticInfoConf::add_software_configs(const char* value, size_t size) {
  software_configs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:atd.data.StaticInfoConf.software_configs)
}
const ::google::protobuf::RepeatedPtrField< ::std::string>&
StaticInfoConf::software_configs() const {
  // @@protoc_insertion_point(field_list:atd.data.StaticInfoConf.software_configs)
  return software_configs_;
}
::google::protobuf::RepeatedPtrField< ::std::string>*
StaticInfoConf::mutable_software_configs() {
  // @@protoc_insertion_point(field_mutable_list:atd.data.StaticInfoConf.software_configs)
  return &software_configs_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace data
}  // namespace atd

// @@protoc_insertion_point(global_scope)
