// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/ipc/message/protobuf/hdmap/enginetargetlanes.proto

#ifndef PROTOBUF_modules_2fipc_2fmessage_2fprotobuf_2fhdmap_2fenginetargetlanes_2eproto__INCLUDED
#define PROTOBUF_modules_2fipc_2fmessage_2fprotobuf_2fhdmap_2fenginetargetlanes_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include "modules/ipc/message/protobuf/common/header.pb.h"
#include "modules/ipc/message/protobuf/common/reserved.pb.h"
#include "modules/ipc/message/protobuf/localization/pose.pb.h"
#include "modules/ipc/message/protobuf/common/geometry.pb.h"
#include "modules/ipc/message/protobuf/hdmap/enginesurmap.pb.h"
#include "modules/ipc/message/protobuf/MeProcess/mobileyeq4.pb.h"
// @@protoc_insertion_point(includes)
namespace atd {
namespace common {
class Arrow2D;
class Arrow2DDefaultTypeInternal;
extern Arrow2DDefaultTypeInternal _Arrow2D_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Point2D;
class Point2DDefaultTypeInternal;
extern Point2DDefaultTypeInternal _Point2D_default_instance_;
class Point3D;
class Point3DDefaultTypeInternal;
extern Point3DDefaultTypeInternal _Point3D_default_instance_;
class PointENU;
class PointENUDefaultTypeInternal;
extern PointENUDefaultTypeInternal _PointENU_default_instance_;
class PointLLH;
class PointLLHDefaultTypeInternal;
extern PointLLHDefaultTypeInternal _PointLLH_default_instance_;
class Quaternion;
class QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class Reserved;
class ReservedDefaultTypeInternal;
extern ReservedDefaultTypeInternal _Reserved_default_instance_;
}  // namespace common
namespace localization {
class Pose;
class PoseDefaultTypeInternal;
extern PoseDefaultTypeInternal _Pose_default_instance_;
}  // namespace localization
namespace map {
class EngineSurMap;
class EngineSurMapDefaultTypeInternal;
extern EngineSurMapDefaultTypeInternal _EngineSurMap_default_instance_;
class EngineTargetLanes;
class EngineTargetLanesDefaultTypeInternal;
extern EngineTargetLanesDefaultTypeInternal _EngineTargetLanes_default_instance_;
class EyeQLaneCenter;
class EyeQLaneCenterDefaultTypeInternal;
extern EyeQLaneCenterDefaultTypeInternal _EyeQLaneCenter_default_instance_;
class LaneChangeDecision;
class LaneChangeDecisionDefaultTypeInternal;
extern LaneChangeDecisionDefaultTypeInternal _LaneChangeDecision_default_instance_;
class SurElement;
class SurElementDefaultTypeInternal;
extern SurElementDefaultTypeInternal _SurElement_default_instance_;
class SurElements;
class SurElementsDefaultTypeInternal;
extern SurElementsDefaultTypeInternal _SurElements_default_instance_;
class TargetArrow;
class TargetArrowDefaultTypeInternal;
extern TargetArrowDefaultTypeInternal _TargetArrow_default_instance_;
class TargetLane;
class TargetLaneDefaultTypeInternal;
extern TargetLaneDefaultTypeInternal _TargetLane_default_instance_;
}  // namespace map
namespace meprocess {
class ADVCommon;
class ADVCommonDefaultTypeInternal;
extern ADVCommonDefaultTypeInternal _ADVCommon_default_instance_;
class CACommon;
class CACommonDefaultTypeInternal;
extern CACommonDefaultTypeInternal _CACommon_default_instance_;
class ConArea;
class ConAreaDefaultTypeInternal;
extern ConAreaDefaultTypeInternal _ConArea_default_instance_;
class Dt_Record_App;
class Dt_Record_AppDefaultTypeInternal;
extern Dt_Record_AppDefaultTypeInternal _Dt_Record_App_default_instance_;
class Dt_Record_Common;
class Dt_Record_CommonDefaultTypeInternal;
extern Dt_Record_CommonDefaultTypeInternal _Dt_Record_Common_default_instance_;
class Dt_Record_ConstructionArea;
class Dt_Record_ConstructionAreaDefaultTypeInternal;
extern Dt_Record_ConstructionAreaDefaultTypeInternal _Dt_Record_ConstructionArea_default_instance_;
class Dt_Record_FCF;
class Dt_Record_FCFDefaultTypeInternal;
extern Dt_Record_FCFDefaultTypeInternal _Dt_Record_FCF_default_instance_;
class Dt_Record_FCF_VRU;
class Dt_Record_FCF_VRUDefaultTypeInternal;
extern Dt_Record_FCF_VRUDefaultTypeInternal _Dt_Record_FCF_VRU_default_instance_;
class Dt_Record_FailSafe;
class Dt_Record_FailSafeDefaultTypeInternal;
extern Dt_Record_FailSafeDefaultTypeInternal _Dt_Record_FailSafe_default_instance_;
class Dt_Record_HLB;
class Dt_Record_HLBDefaultTypeInternal;
extern Dt_Record_HLBDefaultTypeInternal _Dt_Record_HLB_default_instance_;
class Dt_Record_LDW;
class Dt_Record_LDWDefaultTypeInternal;
extern Dt_Record_LDWDefaultTypeInternal _Dt_Record_LDW_default_instance_;
class Dt_Record_LS_ADV;
class Dt_Record_LS_ADVDefaultTypeInternal;
extern Dt_Record_LS_ADVDefaultTypeInternal _Dt_Record_LS_ADV_default_instance_;
class Dt_Record_LS_Road_Edge;
class Dt_Record_LS_Road_EdgeDefaultTypeInternal;
extern Dt_Record_LS_Road_EdgeDefaultTypeInternal _Dt_Record_LS_Road_Edge_default_instance_;
class Dt_Record_Lane_Support;
class Dt_Record_Lane_SupportDefaultTypeInternal;
extern Dt_Record_Lane_SupportDefaultTypeInternal _Dt_Record_Lane_Support_default_instance_;
class Dt_Record_MeFreeSpace;
class Dt_Record_MeFreeSpaceDefaultTypeInternal;
extern Dt_Record_MeFreeSpaceDefaultTypeInternal _Dt_Record_MeFreeSpace_default_instance_;
class Dt_Record_MeObjects;
class Dt_Record_MeObjectsDefaultTypeInternal;
extern Dt_Record_MeObjectsDefaultTypeInternal _Dt_Record_MeObjects_default_instance_;
class Dt_Record_SL_Descrip;
class Dt_Record_SL_DescripDefaultTypeInternal;
extern Dt_Record_SL_DescripDefaultTypeInternal _Dt_Record_SL_Descrip_default_instance_;
class Dt_Record_SematicLine;
class Dt_Record_SematicLineDefaultTypeInternal;
extern Dt_Record_SematicLineDefaultTypeInternal _Dt_Record_SematicLine_default_instance_;
class Dt_Record_SematicMark;
class Dt_Record_SematicMarkDefaultTypeInternal;
extern Dt_Record_SematicMarkDefaultTypeInternal _Dt_Record_SematicMark_default_instance_;
class Dt_Record_TFL;
class Dt_Record_TFLDefaultTypeInternal;
extern Dt_Record_TFLDefaultTypeInternal _Dt_Record_TFL_default_instance_;
class Dt_Record_TSR;
class Dt_Record_TSRDefaultTypeInternal;
extern Dt_Record_TSRDefaultTypeInternal _Dt_Record_TSR_default_instance_;
class FCF_VRU;
class FCF_VRUDefaultTypeInternal;
extern FCF_VRUDefaultTypeInternal _FCF_VRU_default_instance_;
class FSPCommon;
class FSPCommonDefaultTypeInternal;
extern FSPCommonDefaultTypeInternal _FSPCommon_default_instance_;
class FSPoint;
class FSPointDefaultTypeInternal;
extern FSPointDefaultTypeInternal _FSPoint_default_instance_;
class LSCommon;
class LSCommonDefaultTypeInternal;
extern LSCommonDefaultTypeInternal _LSCommon_default_instance_;
class LS_Adjacent_Line;
class LS_Adjacent_LineDefaultTypeInternal;
extern LS_Adjacent_LineDefaultTypeInternal _LS_Adjacent_Line_default_instance_;
class LS_Host_Line;
class LS_Host_LineDefaultTypeInternal;
extern LS_Host_LineDefaultTypeInternal _LS_Host_Line_default_instance_;
class LS_INTP;
class LS_INTPDefaultTypeInternal;
extern LS_INTPDefaultTypeInternal _LS_INTP_default_instance_;
class LineParam;
class LineParamDefaultTypeInternal;
extern LineParamDefaultTypeInternal _LineParam_default_instance_;
class MeObject;
class MeObjectDefaultTypeInternal;
extern MeObjectDefaultTypeInternal _MeObject_default_instance_;
class ObjCommon;
class ObjCommonDefaultTypeInternal;
extern ObjCommonDefaultTypeInternal _ObjCommon_default_instance_;
class RoadEdge;
class RoadEdgeDefaultTypeInternal;
extern RoadEdgeDefaultTypeInternal _RoadEdge_default_instance_;
class RoadEdgeCommon;
class RoadEdgeCommonDefaultTypeInternal;
extern RoadEdgeCommonDefaultTypeInternal _RoadEdgeCommon_default_instance_;
class SLCommon;
class SLCommonDefaultTypeInternal;
extern SLCommonDefaultTypeInternal _SLCommon_default_instance_;
class SLD;
class SLDDefaultTypeInternal;
extern SLDDefaultTypeInternal _SLD_default_instance_;
class SLDCommon;
class SLDCommonDefaultTypeInternal;
extern SLDCommonDefaultTypeInternal _SLDCommon_default_instance_;
class SMCommon;
class SMCommonDefaultTypeInternal;
extern SMCommonDefaultTypeInternal _SMCommon_default_instance_;
class SematicLine;
class SematicLineDefaultTypeInternal;
extern SematicLineDefaultTypeInternal _SematicLine_default_instance_;
class SematicMark;
class SematicMarkDefaultTypeInternal;
extern SematicMarkDefaultTypeInternal _SematicMark_default_instance_;
class TFL;
class TFLDefaultTypeInternal;
extern TFLDefaultTypeInternal _TFL_default_instance_;
class TFLCommon;
class TFLCommonDefaultTypeInternal;
extern TFLCommonDefaultTypeInternal _TFLCommon_default_instance_;
class TSR;
class TSRDefaultTypeInternal;
extern TSRDefaultTypeInternal _TSR_default_instance_;
class TSRCommon;
class TSRCommonDefaultTypeInternal;
extern TSRCommonDefaultTypeInternal _TSRCommon_default_instance_;
class VRUCommon;
class VRUCommonDefaultTypeInternal;
extern VRUCommonDefaultTypeInternal _VRUCommon_default_instance_;
}  // namespace meprocess
}  // namespace atd

namespace atd {
namespace map {

namespace protobuf_modules_2fipc_2fmessage_2fprotobuf_2fhdmap_2fenginetargetlanes_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_modules_2fipc_2fmessage_2fprotobuf_2fhdmap_2fenginetargetlanes_2eproto

// ===================================================================

class LaneChangeDecision : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.map.LaneChangeDecision) */ {
 public:
  LaneChangeDecision();
  virtual ~LaneChangeDecision();

  LaneChangeDecision(const LaneChangeDecision& from);

  inline LaneChangeDecision& operator=(const LaneChangeDecision& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const LaneChangeDecision& default_instance();

  static inline const LaneChangeDecision* internal_default_instance() {
    return reinterpret_cast<const LaneChangeDecision*>(
               &_LaneChangeDecision_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(LaneChangeDecision* other);

  // implements Message ----------------------------------------------

  inline LaneChangeDecision* New() const PROTOBUF_FINAL { return New(NULL); }

  LaneChangeDecision* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const LaneChangeDecision& from);
  void MergeFrom(const LaneChangeDecision& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LaneChangeDecision* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 leftBG = 1;
  bool has_leftbg() const;
  void clear_leftbg();
  static const int kLeftBGFieldNumber = 1;
  ::google::protobuf::int32 leftbg() const;
  void set_leftbg(::google::protobuf::int32 value);

  // optional int32 centerBG = 2;
  bool has_centerbg() const;
  void clear_centerbg();
  static const int kCenterBGFieldNumber = 2;
  ::google::protobuf::int32 centerbg() const;
  void set_centerbg(::google::protobuf::int32 value);

  // optional int32 rightBG = 3;
  bool has_rightbg() const;
  void clear_rightbg();
  static const int kRightBGFieldNumber = 3;
  ::google::protobuf::int32 rightbg() const;
  void set_rightbg(::google::protobuf::int32 value);

  // optional float RemainLength = 4;
  bool has_remainlength() const;
  void clear_remainlength();
  static const int kRemainLengthFieldNumber = 4;
  float remainlength() const;
  void set_remainlength(float value);

  // optional float leftTurnAreaLength = 5;
  bool has_leftturnarealength() const;
  void clear_leftturnarealength();
  static const int kLeftTurnAreaLengthFieldNumber = 5;
  float leftturnarealength() const;
  void set_leftturnarealength(float value);

  // optional float rightTurnAreaLength = 6;
  bool has_rightturnarealength() const;
  void clear_rightturnarealength();
  static const int kRightTurnAreaLengthFieldNumber = 6;
  float rightturnarealength() const;
  void set_rightturnarealength(float value);

  // @@protoc_insertion_point(class_scope:atd.map.LaneChangeDecision)
 private:
  void set_has_leftbg();
  void clear_has_leftbg();
  void set_has_centerbg();
  void clear_has_centerbg();
  void set_has_rightbg();
  void clear_has_rightbg();
  void set_has_remainlength();
  void clear_has_remainlength();
  void set_has_leftturnarealength();
  void clear_has_leftturnarealength();
  void set_has_rightturnarealength();
  void clear_has_rightturnarealength();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 leftbg_;
  ::google::protobuf::int32 centerbg_;
  ::google::protobuf::int32 rightbg_;
  float remainlength_;
  float leftturnarealength_;
  float rightturnarealength_;
  friend struct protobuf_modules_2fipc_2fmessage_2fprotobuf_2fhdmap_2fenginetargetlanes_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TargetLane : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.map.TargetLane) */ {
 public:
  TargetLane();
  virtual ~TargetLane();

  TargetLane(const TargetLane& from);

  inline TargetLane& operator=(const TargetLane& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const TargetLane& default_instance();

  static inline const TargetLane* internal_default_instance() {
    return reinterpret_cast<const TargetLane*>(
               &_TargetLane_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(TargetLane* other);

  // implements Message ----------------------------------------------

  inline TargetLane* New() const PROTOBUF_FINAL { return New(NULL); }

  TargetLane* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const TargetLane& from);
  void MergeFrom(const TargetLane& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TargetLane* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .atd.common.Point2D point = 4;
  int point_size() const;
  void clear_point();
  static const int kPointFieldNumber = 4;
  const ::atd::common::Point2D& point(int index) const;
  ::atd::common::Point2D* mutable_point(int index);
  ::atd::common::Point2D* add_point();
  ::google::protobuf::RepeatedPtrField< ::atd::common::Point2D >*
      mutable_point();
  const ::google::protobuf::RepeatedPtrField< ::atd::common::Point2D >&
      point() const;

  // repeated .atd.common.Point2D point_EC = 5;
  int point_ec_size() const;
  void clear_point_ec();
  static const int kPointECFieldNumber = 5;
  const ::atd::common::Point2D& point_ec(int index) const;
  ::atd::common::Point2D* mutable_point_ec(int index);
  ::atd::common::Point2D* add_point_ec();
  ::google::protobuf::RepeatedPtrField< ::atd::common::Point2D >*
      mutable_point_ec();
  const ::google::protobuf::RepeatedPtrField< ::atd::common::Point2D >&
      point_ec() const;

  // optional bool bLine = 1;
  bool has_bline() const;
  void clear_bline();
  static const int kBLineFieldNumber = 1;
  bool bline() const;
  void set_bline(bool value);

  // optional int32 nLineType = 2;
  bool has_nlinetype() const;
  void clear_nlinetype();
  static const int kNLineTypeFieldNumber = 2;
  ::google::protobuf::int32 nlinetype() const;
  void set_nlinetype(::google::protobuf::int32 value);

  // optional int32 nArrayLength = 3;
  bool has_narraylength() const;
  void clear_narraylength();
  static const int kNArrayLengthFieldNumber = 3;
  ::google::protobuf::int32 narraylength() const;
  void set_narraylength(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:atd.map.TargetLane)
 private:
  void set_has_bline();
  void clear_has_bline();
  void set_has_nlinetype();
  void clear_has_nlinetype();
  void set_has_narraylength();
  void clear_has_narraylength();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::atd::common::Point2D > point_;
  ::google::protobuf::RepeatedPtrField< ::atd::common::Point2D > point_ec_;
  bool bline_;
  ::google::protobuf::int32 nlinetype_;
  ::google::protobuf::int32 narraylength_;
  friend struct protobuf_modules_2fipc_2fmessage_2fprotobuf_2fhdmap_2fenginetargetlanes_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EyeQLaneCenter : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.map.EyeQLaneCenter) */ {
 public:
  EyeQLaneCenter();
  virtual ~EyeQLaneCenter();

  EyeQLaneCenter(const EyeQLaneCenter& from);

  inline EyeQLaneCenter& operator=(const EyeQLaneCenter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const EyeQLaneCenter& default_instance();

  static inline const EyeQLaneCenter* internal_default_instance() {
    return reinterpret_cast<const EyeQLaneCenter*>(
               &_EyeQLaneCenter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(EyeQLaneCenter* other);

  // implements Message ----------------------------------------------

  inline EyeQLaneCenter* New() const PROTOBUF_FINAL { return New(NULL); }

  EyeQLaneCenter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const EyeQLaneCenter& from);
  void MergeFrom(const EyeQLaneCenter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EyeQLaneCenter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .atd.meprocess.LineParam centerlaneParam = 1;
  bool has_centerlaneparam() const;
  void clear_centerlaneparam();
  static const int kCenterlaneParamFieldNumber = 1;
  const ::atd::meprocess::LineParam& centerlaneparam() const;
  ::atd::meprocess::LineParam* mutable_centerlaneparam();
  ::atd::meprocess::LineParam* release_centerlaneparam();
  void set_allocated_centerlaneparam(::atd::meprocess::LineParam* centerlaneparam);

  // optional .atd.meprocess.LineParam leftlaneParam = 2;
  bool has_leftlaneparam() const;
  void clear_leftlaneparam();
  static const int kLeftlaneParamFieldNumber = 2;
  const ::atd::meprocess::LineParam& leftlaneparam() const;
  ::atd::meprocess::LineParam* mutable_leftlaneparam();
  ::atd::meprocess::LineParam* release_leftlaneparam();
  void set_allocated_leftlaneparam(::atd::meprocess::LineParam* leftlaneparam);

  // optional .atd.meprocess.LineParam rightlaneParam = 3;
  bool has_rightlaneparam() const;
  void clear_rightlaneparam();
  static const int kRightlaneParamFieldNumber = 3;
  const ::atd::meprocess::LineParam& rightlaneparam() const;
  ::atd::meprocess::LineParam* mutable_rightlaneparam();
  ::atd::meprocess::LineParam* release_rightlaneparam();
  void set_allocated_rightlaneparam(::atd::meprocess::LineParam* rightlaneparam);

  // @@protoc_insertion_point(class_scope:atd.map.EyeQLaneCenter)
 private:
  void set_has_centerlaneparam();
  void clear_has_centerlaneparam();
  void set_has_leftlaneparam();
  void clear_has_leftlaneparam();
  void set_has_rightlaneparam();
  void clear_has_rightlaneparam();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::atd::meprocess::LineParam* centerlaneparam_;
  ::atd::meprocess::LineParam* leftlaneparam_;
  ::atd::meprocess::LineParam* rightlaneparam_;
  friend struct protobuf_modules_2fipc_2fmessage_2fprotobuf_2fhdmap_2fenginetargetlanes_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TargetArrow : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.map.TargetArrow) */ {
 public:
  TargetArrow();
  virtual ~TargetArrow();

  TargetArrow(const TargetArrow& from);

  inline TargetArrow& operator=(const TargetArrow& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const TargetArrow& default_instance();

  static inline const TargetArrow* internal_default_instance() {
    return reinterpret_cast<const TargetArrow*>(
               &_TargetArrow_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(TargetArrow* other);

  // implements Message ----------------------------------------------

  inline TargetArrow* New() const PROTOBUF_FINAL { return New(NULL); }

  TargetArrow* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const TargetArrow& from);
  void MergeFrom(const TargetArrow& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TargetArrow* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .atd.common.Arrow2D centerlane = 6;
  int centerlane_size() const;
  void clear_centerlane();
  static const int kCenterlaneFieldNumber = 6;
  const ::atd::common::Arrow2D& centerlane(int index) const;
  ::atd::common::Arrow2D* mutable_centerlane(int index);
  ::atd::common::Arrow2D* add_centerlane();
  ::google::protobuf::RepeatedPtrField< ::atd::common::Arrow2D >*
      mutable_centerlane();
  const ::google::protobuf::RepeatedPtrField< ::atd::common::Arrow2D >&
      centerlane() const;

  // repeated .atd.common.Point2D leftlane = 7;
  int leftlane_size() const;
  void clear_leftlane();
  static const int kLeftlaneFieldNumber = 7;
  const ::atd::common::Point2D& leftlane(int index) const;
  ::atd::common::Point2D* mutable_leftlane(int index);
  ::atd::common::Point2D* add_leftlane();
  ::google::protobuf::RepeatedPtrField< ::atd::common::Point2D >*
      mutable_leftlane();
  const ::google::protobuf::RepeatedPtrField< ::atd::common::Point2D >&
      leftlane() const;

  // repeated .atd.common.Point2D rightlane = 8;
  int rightlane_size() const;
  void clear_rightlane();
  static const int kRightlaneFieldNumber = 8;
  const ::atd::common::Point2D& rightlane(int index) const;
  ::atd::common::Point2D* mutable_rightlane(int index);
  ::atd::common::Point2D* add_rightlane();
  ::google::protobuf::RepeatedPtrField< ::atd::common::Point2D >*
      mutable_rightlane();
  const ::google::protobuf::RepeatedPtrField< ::atd::common::Point2D >&
      rightlane() const;

  // optional .atd.common.Arrow2D targetarrow = 3;
  bool has_targetarrow() const;
  void clear_targetarrow();
  static const int kTargetarrowFieldNumber = 3;
  const ::atd::common::Arrow2D& targetarrow() const;
  ::atd::common::Arrow2D* mutable_targetarrow();
  ::atd::common::Arrow2D* release_targetarrow();
  void set_allocated_targetarrow(::atd::common::Arrow2D* targetarrow);

  // optional int32 level = 1;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 1;
  ::google::protobuf::int32 level() const;
  void set_level(::google::protobuf::int32 value);

  // optional int32 guide_info = 2;
  bool has_guide_info() const;
  void clear_guide_info();
  static const int kGuideInfoFieldNumber = 2;
  ::google::protobuf::int32 guide_info() const;
  void set_guide_info(::google::protobuf::int32 value);

  // optional double target_diff = 5;
  bool has_target_diff() const;
  void clear_target_diff();
  static const int kTargetDiffFieldNumber = 5;
  double target_diff() const;
  void set_target_diff(double value);

  // @@protoc_insertion_point(class_scope:atd.map.TargetArrow)
 private:
  void set_has_level();
  void clear_has_level();
  void set_has_guide_info();
  void clear_has_guide_info();
  void set_has_targetarrow();
  void clear_has_targetarrow();
  void set_has_target_diff();
  void clear_has_target_diff();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::atd::common::Arrow2D > centerlane_;
  ::google::protobuf::RepeatedPtrField< ::atd::common::Point2D > leftlane_;
  ::google::protobuf::RepeatedPtrField< ::atd::common::Point2D > rightlane_;
  ::atd::common::Arrow2D* targetarrow_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 guide_info_;
  double target_diff_;
  friend struct protobuf_modules_2fipc_2fmessage_2fprotobuf_2fhdmap_2fenginetargetlanes_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EngineTargetLanes : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.map.EngineTargetLanes) */ {
 public:
  EngineTargetLanes();
  virtual ~EngineTargetLanes();

  EngineTargetLanes(const EngineTargetLanes& from);

  inline EngineTargetLanes& operator=(const EngineTargetLanes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const EngineTargetLanes& default_instance();

  static inline const EngineTargetLanes* internal_default_instance() {
    return reinterpret_cast<const EngineTargetLanes*>(
               &_EngineTargetLanes_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(EngineTargetLanes* other);

  // implements Message ----------------------------------------------

  inline EngineTargetLanes* New() const PROTOBUF_FINAL { return New(NULL); }

  EngineTargetLanes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const EngineTargetLanes& from);
  void MergeFrom(const EngineTargetLanes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EngineTargetLanes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .atd.map.TargetArrow target = 9;
  int target_size() const;
  void clear_target();
  static const int kTargetFieldNumber = 9;
  const ::atd::map::TargetArrow& target(int index) const;
  ::atd::map::TargetArrow* mutable_target(int index);
  ::atd::map::TargetArrow* add_target();
  ::google::protobuf::RepeatedPtrField< ::atd::map::TargetArrow >*
      mutable_target();
  const ::google::protobuf::RepeatedPtrField< ::atd::map::TargetArrow >&
      target() const;

  // repeated .atd.map.SurElements elements = 10;
  int elements_size() const;
  void clear_elements();
  static const int kElementsFieldNumber = 10;
  const ::atd::map::SurElements& elements(int index) const;
  ::atd::map::SurElements* mutable_elements(int index);
  ::atd::map::SurElements* add_elements();
  ::google::protobuf::RepeatedPtrField< ::atd::map::SurElements >*
      mutable_elements();
  const ::google::protobuf::RepeatedPtrField< ::atd::map::SurElements >&
      elements() const;

  // optional .atd.common.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::atd::common::Header& header() const;
  ::atd::common::Header* mutable_header();
  ::atd::common::Header* release_header();
  void set_allocated_header(::atd::common::Header* header);

  // optional .atd.common.Reserved reservedmsg = 2;
  bool has_reservedmsg() const;
  void clear_reservedmsg();
  static const int kReservedmsgFieldNumber = 2;
  const ::atd::common::Reserved& reservedmsg() const;
  ::atd::common::Reserved* mutable_reservedmsg();
  ::atd::common::Reserved* release_reservedmsg();
  void set_allocated_reservedmsg(::atd::common::Reserved* reservedmsg);

  // optional .atd.localization.Pose pose = 3;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 3;
  const ::atd::localization::Pose& pose() const;
  ::atd::localization::Pose* mutable_pose();
  ::atd::localization::Pose* release_pose();
  void set_allocated_pose(::atd::localization::Pose* pose);

  // optional .atd.map.TargetLane leftleftlane = 4;
  bool has_leftleftlane() const;
  void clear_leftleftlane();
  static const int kLeftleftlaneFieldNumber = 4;
  const ::atd::map::TargetLane& leftleftlane() const;
  ::atd::map::TargetLane* mutable_leftleftlane();
  ::atd::map::TargetLane* release_leftleftlane();
  void set_allocated_leftleftlane(::atd::map::TargetLane* leftleftlane);

  // optional .atd.map.TargetLane leftlane = 5;
  bool has_leftlane() const;
  void clear_leftlane();
  static const int kLeftlaneFieldNumber = 5;
  const ::atd::map::TargetLane& leftlane() const;
  ::atd::map::TargetLane* mutable_leftlane();
  ::atd::map::TargetLane* release_leftlane();
  void set_allocated_leftlane(::atd::map::TargetLane* leftlane);

  // optional .atd.map.TargetLane rightlane = 6;
  bool has_rightlane() const;
  void clear_rightlane();
  static const int kRightlaneFieldNumber = 6;
  const ::atd::map::TargetLane& rightlane() const;
  ::atd::map::TargetLane* mutable_rightlane();
  ::atd::map::TargetLane* release_rightlane();
  void set_allocated_rightlane(::atd::map::TargetLane* rightlane);

  // optional .atd.map.TargetLane rightrightlane = 7;
  bool has_rightrightlane() const;
  void clear_rightrightlane();
  static const int kRightrightlaneFieldNumber = 7;
  const ::atd::map::TargetLane& rightrightlane() const;
  ::atd::map::TargetLane* mutable_rightrightlane();
  ::atd::map::TargetLane* release_rightrightlane();
  void set_allocated_rightrightlane(::atd::map::TargetLane* rightrightlane);

  // optional .atd.map.LaneChangeDecision lanechange = 8;
  bool has_lanechange() const;
  void clear_lanechange();
  static const int kLanechangeFieldNumber = 8;
  const ::atd::map::LaneChangeDecision& lanechange() const;
  ::atd::map::LaneChangeDecision* mutable_lanechange();
  ::atd::map::LaneChangeDecision* release_lanechange();
  void set_allocated_lanechange(::atd::map::LaneChangeDecision* lanechange);

  // optional .atd.map.EyeQLaneCenter eyeQLaneParam = 110;
  bool has_eyeqlaneparam() const;
  void clear_eyeqlaneparam();
  static const int kEyeQLaneParamFieldNumber = 110;
  const ::atd::map::EyeQLaneCenter& eyeqlaneparam() const;
  ::atd::map::EyeQLaneCenter* mutable_eyeqlaneparam();
  ::atd::map::EyeQLaneCenter* release_eyeqlaneparam();
  void set_allocated_eyeqlaneparam(::atd::map::EyeQLaneCenter* eyeqlaneparam);

  // @@protoc_insertion_point(class_scope:atd.map.EngineTargetLanes)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_reservedmsg();
  void clear_has_reservedmsg();
  void set_has_pose();
  void clear_has_pose();
  void set_has_leftleftlane();
  void clear_has_leftleftlane();
  void set_has_leftlane();
  void clear_has_leftlane();
  void set_has_rightlane();
  void clear_has_rightlane();
  void set_has_rightrightlane();
  void clear_has_rightrightlane();
  void set_has_lanechange();
  void clear_has_lanechange();
  void set_has_eyeqlaneparam();
  void clear_has_eyeqlaneparam();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::atd::map::TargetArrow > target_;
  ::google::protobuf::RepeatedPtrField< ::atd::map::SurElements > elements_;
  ::atd::common::Header* header_;
  ::atd::common::Reserved* reservedmsg_;
  ::atd::localization::Pose* pose_;
  ::atd::map::TargetLane* leftleftlane_;
  ::atd::map::TargetLane* leftlane_;
  ::atd::map::TargetLane* rightlane_;
  ::atd::map::TargetLane* rightrightlane_;
  ::atd::map::LaneChangeDecision* lanechange_;
  ::atd::map::EyeQLaneCenter* eyeqlaneparam_;
  friend struct protobuf_modules_2fipc_2fmessage_2fprotobuf_2fhdmap_2fenginetargetlanes_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// LaneChangeDecision

// optional int32 leftBG = 1;
inline bool LaneChangeDecision::has_leftbg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneChangeDecision::set_has_leftbg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaneChangeDecision::clear_has_leftbg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaneChangeDecision::clear_leftbg() {
  leftbg_ = 0;
  clear_has_leftbg();
}
inline ::google::protobuf::int32 LaneChangeDecision::leftbg() const {
  // @@protoc_insertion_point(field_get:atd.map.LaneChangeDecision.leftBG)
  return leftbg_;
}
inline void LaneChangeDecision::set_leftbg(::google::protobuf::int32 value) {
  set_has_leftbg();
  leftbg_ = value;
  // @@protoc_insertion_point(field_set:atd.map.LaneChangeDecision.leftBG)
}

// optional int32 centerBG = 2;
inline bool LaneChangeDecision::has_centerbg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneChangeDecision::set_has_centerbg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaneChangeDecision::clear_has_centerbg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaneChangeDecision::clear_centerbg() {
  centerbg_ = 0;
  clear_has_centerbg();
}
inline ::google::protobuf::int32 LaneChangeDecision::centerbg() const {
  // @@protoc_insertion_point(field_get:atd.map.LaneChangeDecision.centerBG)
  return centerbg_;
}
inline void LaneChangeDecision::set_centerbg(::google::protobuf::int32 value) {
  set_has_centerbg();
  centerbg_ = value;
  // @@protoc_insertion_point(field_set:atd.map.LaneChangeDecision.centerBG)
}

// optional int32 rightBG = 3;
inline bool LaneChangeDecision::has_rightbg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LaneChangeDecision::set_has_rightbg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LaneChangeDecision::clear_has_rightbg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LaneChangeDecision::clear_rightbg() {
  rightbg_ = 0;
  clear_has_rightbg();
}
inline ::google::protobuf::int32 LaneChangeDecision::rightbg() const {
  // @@protoc_insertion_point(field_get:atd.map.LaneChangeDecision.rightBG)
  return rightbg_;
}
inline void LaneChangeDecision::set_rightbg(::google::protobuf::int32 value) {
  set_has_rightbg();
  rightbg_ = value;
  // @@protoc_insertion_point(field_set:atd.map.LaneChangeDecision.rightBG)
}

// optional float RemainLength = 4;
inline bool LaneChangeDecision::has_remainlength() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LaneChangeDecision::set_has_remainlength() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LaneChangeDecision::clear_has_remainlength() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LaneChangeDecision::clear_remainlength() {
  remainlength_ = 0;
  clear_has_remainlength();
}
inline float LaneChangeDecision::remainlength() const {
  // @@protoc_insertion_point(field_get:atd.map.LaneChangeDecision.RemainLength)
  return remainlength_;
}
inline void LaneChangeDecision::set_remainlength(float value) {
  set_has_remainlength();
  remainlength_ = value;
  // @@protoc_insertion_point(field_set:atd.map.LaneChangeDecision.RemainLength)
}

// optional float leftTurnAreaLength = 5;
inline bool LaneChangeDecision::has_leftturnarealength() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LaneChangeDecision::set_has_leftturnarealength() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LaneChangeDecision::clear_has_leftturnarealength() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LaneChangeDecision::clear_leftturnarealength() {
  leftturnarealength_ = 0;
  clear_has_leftturnarealength();
}
inline float LaneChangeDecision::leftturnarealength() const {
  // @@protoc_insertion_point(field_get:atd.map.LaneChangeDecision.leftTurnAreaLength)
  return leftturnarealength_;
}
inline void LaneChangeDecision::set_leftturnarealength(float value) {
  set_has_leftturnarealength();
  leftturnarealength_ = value;
  // @@protoc_insertion_point(field_set:atd.map.LaneChangeDecision.leftTurnAreaLength)
}

// optional float rightTurnAreaLength = 6;
inline bool LaneChangeDecision::has_rightturnarealength() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LaneChangeDecision::set_has_rightturnarealength() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LaneChangeDecision::clear_has_rightturnarealength() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LaneChangeDecision::clear_rightturnarealength() {
  rightturnarealength_ = 0;
  clear_has_rightturnarealength();
}
inline float LaneChangeDecision::rightturnarealength() const {
  // @@protoc_insertion_point(field_get:atd.map.LaneChangeDecision.rightTurnAreaLength)
  return rightturnarealength_;
}
inline void LaneChangeDecision::set_rightturnarealength(float value) {
  set_has_rightturnarealength();
  rightturnarealength_ = value;
  // @@protoc_insertion_point(field_set:atd.map.LaneChangeDecision.rightTurnAreaLength)
}

// -------------------------------------------------------------------

// TargetLane

// optional bool bLine = 1;
inline bool TargetLane::has_bline() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TargetLane::set_has_bline() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TargetLane::clear_has_bline() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TargetLane::clear_bline() {
  bline_ = false;
  clear_has_bline();
}
inline bool TargetLane::bline() const {
  // @@protoc_insertion_point(field_get:atd.map.TargetLane.bLine)
  return bline_;
}
inline void TargetLane::set_bline(bool value) {
  set_has_bline();
  bline_ = value;
  // @@protoc_insertion_point(field_set:atd.map.TargetLane.bLine)
}

// optional int32 nLineType = 2;
inline bool TargetLane::has_nlinetype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TargetLane::set_has_nlinetype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TargetLane::clear_has_nlinetype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TargetLane::clear_nlinetype() {
  nlinetype_ = 0;
  clear_has_nlinetype();
}
inline ::google::protobuf::int32 TargetLane::nlinetype() const {
  // @@protoc_insertion_point(field_get:atd.map.TargetLane.nLineType)
  return nlinetype_;
}
inline void TargetLane::set_nlinetype(::google::protobuf::int32 value) {
  set_has_nlinetype();
  nlinetype_ = value;
  // @@protoc_insertion_point(field_set:atd.map.TargetLane.nLineType)
}

// optional int32 nArrayLength = 3;
inline bool TargetLane::has_narraylength() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TargetLane::set_has_narraylength() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TargetLane::clear_has_narraylength() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TargetLane::clear_narraylength() {
  narraylength_ = 0;
  clear_has_narraylength();
}
inline ::google::protobuf::int32 TargetLane::narraylength() const {
  // @@protoc_insertion_point(field_get:atd.map.TargetLane.nArrayLength)
  return narraylength_;
}
inline void TargetLane::set_narraylength(::google::protobuf::int32 value) {
  set_has_narraylength();
  narraylength_ = value;
  // @@protoc_insertion_point(field_set:atd.map.TargetLane.nArrayLength)
}

// repeated .atd.common.Point2D point = 4;
inline int TargetLane::point_size() const {
  return point_.size();
}
inline void TargetLane::clear_point() {
  point_.Clear();
}
inline const ::atd::common::Point2D& TargetLane::point(int index) const {
  // @@protoc_insertion_point(field_get:atd.map.TargetLane.point)
  return point_.Get(index);
}
inline ::atd::common::Point2D* TargetLane::mutable_point(int index) {
  // @@protoc_insertion_point(field_mutable:atd.map.TargetLane.point)
  return point_.Mutable(index);
}
inline ::atd::common::Point2D* TargetLane::add_point() {
  // @@protoc_insertion_point(field_add:atd.map.TargetLane.point)
  return point_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::atd::common::Point2D >*
TargetLane::mutable_point() {
  // @@protoc_insertion_point(field_mutable_list:atd.map.TargetLane.point)
  return &point_;
}
inline const ::google::protobuf::RepeatedPtrField< ::atd::common::Point2D >&
TargetLane::point() const {
  // @@protoc_insertion_point(field_list:atd.map.TargetLane.point)
  return point_;
}

// repeated .atd.common.Point2D point_EC = 5;
inline int TargetLane::point_ec_size() const {
  return point_ec_.size();
}
inline void TargetLane::clear_point_ec() {
  point_ec_.Clear();
}
inline const ::atd::common::Point2D& TargetLane::point_ec(int index) const {
  // @@protoc_insertion_point(field_get:atd.map.TargetLane.point_EC)
  return point_ec_.Get(index);
}
inline ::atd::common::Point2D* TargetLane::mutable_point_ec(int index) {
  // @@protoc_insertion_point(field_mutable:atd.map.TargetLane.point_EC)
  return point_ec_.Mutable(index);
}
inline ::atd::common::Point2D* TargetLane::add_point_ec() {
  // @@protoc_insertion_point(field_add:atd.map.TargetLane.point_EC)
  return point_ec_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::atd::common::Point2D >*
TargetLane::mutable_point_ec() {
  // @@protoc_insertion_point(field_mutable_list:atd.map.TargetLane.point_EC)
  return &point_ec_;
}
inline const ::google::protobuf::RepeatedPtrField< ::atd::common::Point2D >&
TargetLane::point_ec() const {
  // @@protoc_insertion_point(field_list:atd.map.TargetLane.point_EC)
  return point_ec_;
}

// -------------------------------------------------------------------

// EyeQLaneCenter

// required .atd.meprocess.LineParam centerlaneParam = 1;
inline bool EyeQLaneCenter::has_centerlaneparam() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EyeQLaneCenter::set_has_centerlaneparam() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EyeQLaneCenter::clear_has_centerlaneparam() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EyeQLaneCenter::clear_centerlaneparam() {
  if (centerlaneparam_ != NULL) centerlaneparam_->::atd::meprocess::LineParam::Clear();
  clear_has_centerlaneparam();
}
inline const ::atd::meprocess::LineParam& EyeQLaneCenter::centerlaneparam() const {
  // @@protoc_insertion_point(field_get:atd.map.EyeQLaneCenter.centerlaneParam)
  return centerlaneparam_ != NULL ? *centerlaneparam_
                         : *::atd::meprocess::LineParam::internal_default_instance();
}
inline ::atd::meprocess::LineParam* EyeQLaneCenter::mutable_centerlaneparam() {
  set_has_centerlaneparam();
  if (centerlaneparam_ == NULL) {
    centerlaneparam_ = new ::atd::meprocess::LineParam;
  }
  // @@protoc_insertion_point(field_mutable:atd.map.EyeQLaneCenter.centerlaneParam)
  return centerlaneparam_;
}
inline ::atd::meprocess::LineParam* EyeQLaneCenter::release_centerlaneparam() {
  // @@protoc_insertion_point(field_release:atd.map.EyeQLaneCenter.centerlaneParam)
  clear_has_centerlaneparam();
  ::atd::meprocess::LineParam* temp = centerlaneparam_;
  centerlaneparam_ = NULL;
  return temp;
}
inline void EyeQLaneCenter::set_allocated_centerlaneparam(::atd::meprocess::LineParam* centerlaneparam) {
  delete centerlaneparam_;
  centerlaneparam_ = centerlaneparam;
  if (centerlaneparam) {
    set_has_centerlaneparam();
  } else {
    clear_has_centerlaneparam();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.map.EyeQLaneCenter.centerlaneParam)
}

// optional .atd.meprocess.LineParam leftlaneParam = 2;
inline bool EyeQLaneCenter::has_leftlaneparam() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EyeQLaneCenter::set_has_leftlaneparam() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EyeQLaneCenter::clear_has_leftlaneparam() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EyeQLaneCenter::clear_leftlaneparam() {
  if (leftlaneparam_ != NULL) leftlaneparam_->::atd::meprocess::LineParam::Clear();
  clear_has_leftlaneparam();
}
inline const ::atd::meprocess::LineParam& EyeQLaneCenter::leftlaneparam() const {
  // @@protoc_insertion_point(field_get:atd.map.EyeQLaneCenter.leftlaneParam)
  return leftlaneparam_ != NULL ? *leftlaneparam_
                         : *::atd::meprocess::LineParam::internal_default_instance();
}
inline ::atd::meprocess::LineParam* EyeQLaneCenter::mutable_leftlaneparam() {
  set_has_leftlaneparam();
  if (leftlaneparam_ == NULL) {
    leftlaneparam_ = new ::atd::meprocess::LineParam;
  }
  // @@protoc_insertion_point(field_mutable:atd.map.EyeQLaneCenter.leftlaneParam)
  return leftlaneparam_;
}
inline ::atd::meprocess::LineParam* EyeQLaneCenter::release_leftlaneparam() {
  // @@protoc_insertion_point(field_release:atd.map.EyeQLaneCenter.leftlaneParam)
  clear_has_leftlaneparam();
  ::atd::meprocess::LineParam* temp = leftlaneparam_;
  leftlaneparam_ = NULL;
  return temp;
}
inline void EyeQLaneCenter::set_allocated_leftlaneparam(::atd::meprocess::LineParam* leftlaneparam) {
  delete leftlaneparam_;
  leftlaneparam_ = leftlaneparam;
  if (leftlaneparam) {
    set_has_leftlaneparam();
  } else {
    clear_has_leftlaneparam();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.map.EyeQLaneCenter.leftlaneParam)
}

// optional .atd.meprocess.LineParam rightlaneParam = 3;
inline bool EyeQLaneCenter::has_rightlaneparam() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EyeQLaneCenter::set_has_rightlaneparam() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EyeQLaneCenter::clear_has_rightlaneparam() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EyeQLaneCenter::clear_rightlaneparam() {
  if (rightlaneparam_ != NULL) rightlaneparam_->::atd::meprocess::LineParam::Clear();
  clear_has_rightlaneparam();
}
inline const ::atd::meprocess::LineParam& EyeQLaneCenter::rightlaneparam() const {
  // @@protoc_insertion_point(field_get:atd.map.EyeQLaneCenter.rightlaneParam)
  return rightlaneparam_ != NULL ? *rightlaneparam_
                         : *::atd::meprocess::LineParam::internal_default_instance();
}
inline ::atd::meprocess::LineParam* EyeQLaneCenter::mutable_rightlaneparam() {
  set_has_rightlaneparam();
  if (rightlaneparam_ == NULL) {
    rightlaneparam_ = new ::atd::meprocess::LineParam;
  }
  // @@protoc_insertion_point(field_mutable:atd.map.EyeQLaneCenter.rightlaneParam)
  return rightlaneparam_;
}
inline ::atd::meprocess::LineParam* EyeQLaneCenter::release_rightlaneparam() {
  // @@protoc_insertion_point(field_release:atd.map.EyeQLaneCenter.rightlaneParam)
  clear_has_rightlaneparam();
  ::atd::meprocess::LineParam* temp = rightlaneparam_;
  rightlaneparam_ = NULL;
  return temp;
}
inline void EyeQLaneCenter::set_allocated_rightlaneparam(::atd::meprocess::LineParam* rightlaneparam) {
  delete rightlaneparam_;
  rightlaneparam_ = rightlaneparam;
  if (rightlaneparam) {
    set_has_rightlaneparam();
  } else {
    clear_has_rightlaneparam();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.map.EyeQLaneCenter.rightlaneParam)
}

// -------------------------------------------------------------------

// TargetArrow

// optional int32 level = 1;
inline bool TargetArrow::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TargetArrow::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TargetArrow::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TargetArrow::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 TargetArrow::level() const {
  // @@protoc_insertion_point(field_get:atd.map.TargetArrow.level)
  return level_;
}
inline void TargetArrow::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:atd.map.TargetArrow.level)
}

// optional int32 guide_info = 2;
inline bool TargetArrow::has_guide_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TargetArrow::set_has_guide_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TargetArrow::clear_has_guide_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TargetArrow::clear_guide_info() {
  guide_info_ = 0;
  clear_has_guide_info();
}
inline ::google::protobuf::int32 TargetArrow::guide_info() const {
  // @@protoc_insertion_point(field_get:atd.map.TargetArrow.guide_info)
  return guide_info_;
}
inline void TargetArrow::set_guide_info(::google::protobuf::int32 value) {
  set_has_guide_info();
  guide_info_ = value;
  // @@protoc_insertion_point(field_set:atd.map.TargetArrow.guide_info)
}

// optional .atd.common.Arrow2D targetarrow = 3;
inline bool TargetArrow::has_targetarrow() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TargetArrow::set_has_targetarrow() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TargetArrow::clear_has_targetarrow() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TargetArrow::clear_targetarrow() {
  if (targetarrow_ != NULL) targetarrow_->::atd::common::Arrow2D::Clear();
  clear_has_targetarrow();
}
inline const ::atd::common::Arrow2D& TargetArrow::targetarrow() const {
  // @@protoc_insertion_point(field_get:atd.map.TargetArrow.targetarrow)
  return targetarrow_ != NULL ? *targetarrow_
                         : *::atd::common::Arrow2D::internal_default_instance();
}
inline ::atd::common::Arrow2D* TargetArrow::mutable_targetarrow() {
  set_has_targetarrow();
  if (targetarrow_ == NULL) {
    targetarrow_ = new ::atd::common::Arrow2D;
  }
  // @@protoc_insertion_point(field_mutable:atd.map.TargetArrow.targetarrow)
  return targetarrow_;
}
inline ::atd::common::Arrow2D* TargetArrow::release_targetarrow() {
  // @@protoc_insertion_point(field_release:atd.map.TargetArrow.targetarrow)
  clear_has_targetarrow();
  ::atd::common::Arrow2D* temp = targetarrow_;
  targetarrow_ = NULL;
  return temp;
}
inline void TargetArrow::set_allocated_targetarrow(::atd::common::Arrow2D* targetarrow) {
  delete targetarrow_;
  targetarrow_ = targetarrow;
  if (targetarrow) {
    set_has_targetarrow();
  } else {
    clear_has_targetarrow();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.map.TargetArrow.targetarrow)
}

// optional double target_diff = 5;
inline bool TargetArrow::has_target_diff() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TargetArrow::set_has_target_diff() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TargetArrow::clear_has_target_diff() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TargetArrow::clear_target_diff() {
  target_diff_ = 0;
  clear_has_target_diff();
}
inline double TargetArrow::target_diff() const {
  // @@protoc_insertion_point(field_get:atd.map.TargetArrow.target_diff)
  return target_diff_;
}
inline void TargetArrow::set_target_diff(double value) {
  set_has_target_diff();
  target_diff_ = value;
  // @@protoc_insertion_point(field_set:atd.map.TargetArrow.target_diff)
}

// repeated .atd.common.Arrow2D centerlane = 6;
inline int TargetArrow::centerlane_size() const {
  return centerlane_.size();
}
inline void TargetArrow::clear_centerlane() {
  centerlane_.Clear();
}
inline const ::atd::common::Arrow2D& TargetArrow::centerlane(int index) const {
  // @@protoc_insertion_point(field_get:atd.map.TargetArrow.centerlane)
  return centerlane_.Get(index);
}
inline ::atd::common::Arrow2D* TargetArrow::mutable_centerlane(int index) {
  // @@protoc_insertion_point(field_mutable:atd.map.TargetArrow.centerlane)
  return centerlane_.Mutable(index);
}
inline ::atd::common::Arrow2D* TargetArrow::add_centerlane() {
  // @@protoc_insertion_point(field_add:atd.map.TargetArrow.centerlane)
  return centerlane_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::atd::common::Arrow2D >*
TargetArrow::mutable_centerlane() {
  // @@protoc_insertion_point(field_mutable_list:atd.map.TargetArrow.centerlane)
  return &centerlane_;
}
inline const ::google::protobuf::RepeatedPtrField< ::atd::common::Arrow2D >&
TargetArrow::centerlane() const {
  // @@protoc_insertion_point(field_list:atd.map.TargetArrow.centerlane)
  return centerlane_;
}

// repeated .atd.common.Point2D leftlane = 7;
inline int TargetArrow::leftlane_size() const {
  return leftlane_.size();
}
inline void TargetArrow::clear_leftlane() {
  leftlane_.Clear();
}
inline const ::atd::common::Point2D& TargetArrow::leftlane(int index) const {
  // @@protoc_insertion_point(field_get:atd.map.TargetArrow.leftlane)
  return leftlane_.Get(index);
}
inline ::atd::common::Point2D* TargetArrow::mutable_leftlane(int index) {
  // @@protoc_insertion_point(field_mutable:atd.map.TargetArrow.leftlane)
  return leftlane_.Mutable(index);
}
inline ::atd::common::Point2D* TargetArrow::add_leftlane() {
  // @@protoc_insertion_point(field_add:atd.map.TargetArrow.leftlane)
  return leftlane_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::atd::common::Point2D >*
TargetArrow::mutable_leftlane() {
  // @@protoc_insertion_point(field_mutable_list:atd.map.TargetArrow.leftlane)
  return &leftlane_;
}
inline const ::google::protobuf::RepeatedPtrField< ::atd::common::Point2D >&
TargetArrow::leftlane() const {
  // @@protoc_insertion_point(field_list:atd.map.TargetArrow.leftlane)
  return leftlane_;
}

// repeated .atd.common.Point2D rightlane = 8;
inline int TargetArrow::rightlane_size() const {
  return rightlane_.size();
}
inline void TargetArrow::clear_rightlane() {
  rightlane_.Clear();
}
inline const ::atd::common::Point2D& TargetArrow::rightlane(int index) const {
  // @@protoc_insertion_point(field_get:atd.map.TargetArrow.rightlane)
  return rightlane_.Get(index);
}
inline ::atd::common::Point2D* TargetArrow::mutable_rightlane(int index) {
  // @@protoc_insertion_point(field_mutable:atd.map.TargetArrow.rightlane)
  return rightlane_.Mutable(index);
}
inline ::atd::common::Point2D* TargetArrow::add_rightlane() {
  // @@protoc_insertion_point(field_add:atd.map.TargetArrow.rightlane)
  return rightlane_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::atd::common::Point2D >*
TargetArrow::mutable_rightlane() {
  // @@protoc_insertion_point(field_mutable_list:atd.map.TargetArrow.rightlane)
  return &rightlane_;
}
inline const ::google::protobuf::RepeatedPtrField< ::atd::common::Point2D >&
TargetArrow::rightlane() const {
  // @@protoc_insertion_point(field_list:atd.map.TargetArrow.rightlane)
  return rightlane_;
}

// -------------------------------------------------------------------

// EngineTargetLanes

// optional .atd.common.Header header = 1;
inline bool EngineTargetLanes::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EngineTargetLanes::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EngineTargetLanes::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EngineTargetLanes::clear_header() {
  if (header_ != NULL) header_->::atd::common::Header::Clear();
  clear_has_header();
}
inline const ::atd::common::Header& EngineTargetLanes::header() const {
  // @@protoc_insertion_point(field_get:atd.map.EngineTargetLanes.header)
  return header_ != NULL ? *header_
                         : *::atd::common::Header::internal_default_instance();
}
inline ::atd::common::Header* EngineTargetLanes::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::atd::common::Header;
  }
  // @@protoc_insertion_point(field_mutable:atd.map.EngineTargetLanes.header)
  return header_;
}
inline ::atd::common::Header* EngineTargetLanes::release_header() {
  // @@protoc_insertion_point(field_release:atd.map.EngineTargetLanes.header)
  clear_has_header();
  ::atd::common::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void EngineTargetLanes::set_allocated_header(::atd::common::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.map.EngineTargetLanes.header)
}

// optional .atd.common.Reserved reservedmsg = 2;
inline bool EngineTargetLanes::has_reservedmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EngineTargetLanes::set_has_reservedmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EngineTargetLanes::clear_has_reservedmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EngineTargetLanes::clear_reservedmsg() {
  if (reservedmsg_ != NULL) reservedmsg_->::atd::common::Reserved::Clear();
  clear_has_reservedmsg();
}
inline const ::atd::common::Reserved& EngineTargetLanes::reservedmsg() const {
  // @@protoc_insertion_point(field_get:atd.map.EngineTargetLanes.reservedmsg)
  return reservedmsg_ != NULL ? *reservedmsg_
                         : *::atd::common::Reserved::internal_default_instance();
}
inline ::atd::common::Reserved* EngineTargetLanes::mutable_reservedmsg() {
  set_has_reservedmsg();
  if (reservedmsg_ == NULL) {
    reservedmsg_ = new ::atd::common::Reserved;
  }
  // @@protoc_insertion_point(field_mutable:atd.map.EngineTargetLanes.reservedmsg)
  return reservedmsg_;
}
inline ::atd::common::Reserved* EngineTargetLanes::release_reservedmsg() {
  // @@protoc_insertion_point(field_release:atd.map.EngineTargetLanes.reservedmsg)
  clear_has_reservedmsg();
  ::atd::common::Reserved* temp = reservedmsg_;
  reservedmsg_ = NULL;
  return temp;
}
inline void EngineTargetLanes::set_allocated_reservedmsg(::atd::common::Reserved* reservedmsg) {
  delete reservedmsg_;
  reservedmsg_ = reservedmsg;
  if (reservedmsg) {
    set_has_reservedmsg();
  } else {
    clear_has_reservedmsg();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.map.EngineTargetLanes.reservedmsg)
}

// optional .atd.localization.Pose pose = 3;
inline bool EngineTargetLanes::has_pose() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EngineTargetLanes::set_has_pose() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EngineTargetLanes::clear_has_pose() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EngineTargetLanes::clear_pose() {
  if (pose_ != NULL) pose_->::atd::localization::Pose::Clear();
  clear_has_pose();
}
inline const ::atd::localization::Pose& EngineTargetLanes::pose() const {
  // @@protoc_insertion_point(field_get:atd.map.EngineTargetLanes.pose)
  return pose_ != NULL ? *pose_
                         : *::atd::localization::Pose::internal_default_instance();
}
inline ::atd::localization::Pose* EngineTargetLanes::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) {
    pose_ = new ::atd::localization::Pose;
  }
  // @@protoc_insertion_point(field_mutable:atd.map.EngineTargetLanes.pose)
  return pose_;
}
inline ::atd::localization::Pose* EngineTargetLanes::release_pose() {
  // @@protoc_insertion_point(field_release:atd.map.EngineTargetLanes.pose)
  clear_has_pose();
  ::atd::localization::Pose* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline void EngineTargetLanes::set_allocated_pose(::atd::localization::Pose* pose) {
  delete pose_;
  pose_ = pose;
  if (pose) {
    set_has_pose();
  } else {
    clear_has_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.map.EngineTargetLanes.pose)
}

// optional .atd.map.TargetLane leftleftlane = 4;
inline bool EngineTargetLanes::has_leftleftlane() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EngineTargetLanes::set_has_leftleftlane() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EngineTargetLanes::clear_has_leftleftlane() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EngineTargetLanes::clear_leftleftlane() {
  if (leftleftlane_ != NULL) leftleftlane_->::atd::map::TargetLane::Clear();
  clear_has_leftleftlane();
}
inline const ::atd::map::TargetLane& EngineTargetLanes::leftleftlane() const {
  // @@protoc_insertion_point(field_get:atd.map.EngineTargetLanes.leftleftlane)
  return leftleftlane_ != NULL ? *leftleftlane_
                         : *::atd::map::TargetLane::internal_default_instance();
}
inline ::atd::map::TargetLane* EngineTargetLanes::mutable_leftleftlane() {
  set_has_leftleftlane();
  if (leftleftlane_ == NULL) {
    leftleftlane_ = new ::atd::map::TargetLane;
  }
  // @@protoc_insertion_point(field_mutable:atd.map.EngineTargetLanes.leftleftlane)
  return leftleftlane_;
}
inline ::atd::map::TargetLane* EngineTargetLanes::release_leftleftlane() {
  // @@protoc_insertion_point(field_release:atd.map.EngineTargetLanes.leftleftlane)
  clear_has_leftleftlane();
  ::atd::map::TargetLane* temp = leftleftlane_;
  leftleftlane_ = NULL;
  return temp;
}
inline void EngineTargetLanes::set_allocated_leftleftlane(::atd::map::TargetLane* leftleftlane) {
  delete leftleftlane_;
  leftleftlane_ = leftleftlane;
  if (leftleftlane) {
    set_has_leftleftlane();
  } else {
    clear_has_leftleftlane();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.map.EngineTargetLanes.leftleftlane)
}

// optional .atd.map.TargetLane leftlane = 5;
inline bool EngineTargetLanes::has_leftlane() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EngineTargetLanes::set_has_leftlane() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EngineTargetLanes::clear_has_leftlane() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EngineTargetLanes::clear_leftlane() {
  if (leftlane_ != NULL) leftlane_->::atd::map::TargetLane::Clear();
  clear_has_leftlane();
}
inline const ::atd::map::TargetLane& EngineTargetLanes::leftlane() const {
  // @@protoc_insertion_point(field_get:atd.map.EngineTargetLanes.leftlane)
  return leftlane_ != NULL ? *leftlane_
                         : *::atd::map::TargetLane::internal_default_instance();
}
inline ::atd::map::TargetLane* EngineTargetLanes::mutable_leftlane() {
  set_has_leftlane();
  if (leftlane_ == NULL) {
    leftlane_ = new ::atd::map::TargetLane;
  }
  // @@protoc_insertion_point(field_mutable:atd.map.EngineTargetLanes.leftlane)
  return leftlane_;
}
inline ::atd::map::TargetLane* EngineTargetLanes::release_leftlane() {
  // @@protoc_insertion_point(field_release:atd.map.EngineTargetLanes.leftlane)
  clear_has_leftlane();
  ::atd::map::TargetLane* temp = leftlane_;
  leftlane_ = NULL;
  return temp;
}
inline void EngineTargetLanes::set_allocated_leftlane(::atd::map::TargetLane* leftlane) {
  delete leftlane_;
  leftlane_ = leftlane;
  if (leftlane) {
    set_has_leftlane();
  } else {
    clear_has_leftlane();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.map.EngineTargetLanes.leftlane)
}

// optional .atd.map.TargetLane rightlane = 6;
inline bool EngineTargetLanes::has_rightlane() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EngineTargetLanes::set_has_rightlane() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EngineTargetLanes::clear_has_rightlane() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EngineTargetLanes::clear_rightlane() {
  if (rightlane_ != NULL) rightlane_->::atd::map::TargetLane::Clear();
  clear_has_rightlane();
}
inline const ::atd::map::TargetLane& EngineTargetLanes::rightlane() const {
  // @@protoc_insertion_point(field_get:atd.map.EngineTargetLanes.rightlane)
  return rightlane_ != NULL ? *rightlane_
                         : *::atd::map::TargetLane::internal_default_instance();
}
inline ::atd::map::TargetLane* EngineTargetLanes::mutable_rightlane() {
  set_has_rightlane();
  if (rightlane_ == NULL) {
    rightlane_ = new ::atd::map::TargetLane;
  }
  // @@protoc_insertion_point(field_mutable:atd.map.EngineTargetLanes.rightlane)
  return rightlane_;
}
inline ::atd::map::TargetLane* EngineTargetLanes::release_rightlane() {
  // @@protoc_insertion_point(field_release:atd.map.EngineTargetLanes.rightlane)
  clear_has_rightlane();
  ::atd::map::TargetLane* temp = rightlane_;
  rightlane_ = NULL;
  return temp;
}
inline void EngineTargetLanes::set_allocated_rightlane(::atd::map::TargetLane* rightlane) {
  delete rightlane_;
  rightlane_ = rightlane;
  if (rightlane) {
    set_has_rightlane();
  } else {
    clear_has_rightlane();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.map.EngineTargetLanes.rightlane)
}

// optional .atd.map.TargetLane rightrightlane = 7;
inline bool EngineTargetLanes::has_rightrightlane() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EngineTargetLanes::set_has_rightrightlane() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EngineTargetLanes::clear_has_rightrightlane() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EngineTargetLanes::clear_rightrightlane() {
  if (rightrightlane_ != NULL) rightrightlane_->::atd::map::TargetLane::Clear();
  clear_has_rightrightlane();
}
inline const ::atd::map::TargetLane& EngineTargetLanes::rightrightlane() const {
  // @@protoc_insertion_point(field_get:atd.map.EngineTargetLanes.rightrightlane)
  return rightrightlane_ != NULL ? *rightrightlane_
                         : *::atd::map::TargetLane::internal_default_instance();
}
inline ::atd::map::TargetLane* EngineTargetLanes::mutable_rightrightlane() {
  set_has_rightrightlane();
  if (rightrightlane_ == NULL) {
    rightrightlane_ = new ::atd::map::TargetLane;
  }
  // @@protoc_insertion_point(field_mutable:atd.map.EngineTargetLanes.rightrightlane)
  return rightrightlane_;
}
inline ::atd::map::TargetLane* EngineTargetLanes::release_rightrightlane() {
  // @@protoc_insertion_point(field_release:atd.map.EngineTargetLanes.rightrightlane)
  clear_has_rightrightlane();
  ::atd::map::TargetLane* temp = rightrightlane_;
  rightrightlane_ = NULL;
  return temp;
}
inline void EngineTargetLanes::set_allocated_rightrightlane(::atd::map::TargetLane* rightrightlane) {
  delete rightrightlane_;
  rightrightlane_ = rightrightlane;
  if (rightrightlane) {
    set_has_rightrightlane();
  } else {
    clear_has_rightrightlane();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.map.EngineTargetLanes.rightrightlane)
}

// optional .atd.map.LaneChangeDecision lanechange = 8;
inline bool EngineTargetLanes::has_lanechange() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EngineTargetLanes::set_has_lanechange() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EngineTargetLanes::clear_has_lanechange() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EngineTargetLanes::clear_lanechange() {
  if (lanechange_ != NULL) lanechange_->::atd::map::LaneChangeDecision::Clear();
  clear_has_lanechange();
}
inline const ::atd::map::LaneChangeDecision& EngineTargetLanes::lanechange() const {
  // @@protoc_insertion_point(field_get:atd.map.EngineTargetLanes.lanechange)
  return lanechange_ != NULL ? *lanechange_
                         : *::atd::map::LaneChangeDecision::internal_default_instance();
}
inline ::atd::map::LaneChangeDecision* EngineTargetLanes::mutable_lanechange() {
  set_has_lanechange();
  if (lanechange_ == NULL) {
    lanechange_ = new ::atd::map::LaneChangeDecision;
  }
  // @@protoc_insertion_point(field_mutable:atd.map.EngineTargetLanes.lanechange)
  return lanechange_;
}
inline ::atd::map::LaneChangeDecision* EngineTargetLanes::release_lanechange() {
  // @@protoc_insertion_point(field_release:atd.map.EngineTargetLanes.lanechange)
  clear_has_lanechange();
  ::atd::map::LaneChangeDecision* temp = lanechange_;
  lanechange_ = NULL;
  return temp;
}
inline void EngineTargetLanes::set_allocated_lanechange(::atd::map::LaneChangeDecision* lanechange) {
  delete lanechange_;
  lanechange_ = lanechange;
  if (lanechange) {
    set_has_lanechange();
  } else {
    clear_has_lanechange();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.map.EngineTargetLanes.lanechange)
}

// repeated .atd.map.TargetArrow target = 9;
inline int EngineTargetLanes::target_size() const {
  return target_.size();
}
inline void EngineTargetLanes::clear_target() {
  target_.Clear();
}
inline const ::atd::map::TargetArrow& EngineTargetLanes::target(int index) const {
  // @@protoc_insertion_point(field_get:atd.map.EngineTargetLanes.target)
  return target_.Get(index);
}
inline ::atd::map::TargetArrow* EngineTargetLanes::mutable_target(int index) {
  // @@protoc_insertion_point(field_mutable:atd.map.EngineTargetLanes.target)
  return target_.Mutable(index);
}
inline ::atd::map::TargetArrow* EngineTargetLanes::add_target() {
  // @@protoc_insertion_point(field_add:atd.map.EngineTargetLanes.target)
  return target_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::atd::map::TargetArrow >*
EngineTargetLanes::mutable_target() {
  // @@protoc_insertion_point(field_mutable_list:atd.map.EngineTargetLanes.target)
  return &target_;
}
inline const ::google::protobuf::RepeatedPtrField< ::atd::map::TargetArrow >&
EngineTargetLanes::target() const {
  // @@protoc_insertion_point(field_list:atd.map.EngineTargetLanes.target)
  return target_;
}

// repeated .atd.map.SurElements elements = 10;
inline int EngineTargetLanes::elements_size() const {
  return elements_.size();
}
inline void EngineTargetLanes::clear_elements() {
  elements_.Clear();
}
inline const ::atd::map::SurElements& EngineTargetLanes::elements(int index) const {
  // @@protoc_insertion_point(field_get:atd.map.EngineTargetLanes.elements)
  return elements_.Get(index);
}
inline ::atd::map::SurElements* EngineTargetLanes::mutable_elements(int index) {
  // @@protoc_insertion_point(field_mutable:atd.map.EngineTargetLanes.elements)
  return elements_.Mutable(index);
}
inline ::atd::map::SurElements* EngineTargetLanes::add_elements() {
  // @@protoc_insertion_point(field_add:atd.map.EngineTargetLanes.elements)
  return elements_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::atd::map::SurElements >*
EngineTargetLanes::mutable_elements() {
  // @@protoc_insertion_point(field_mutable_list:atd.map.EngineTargetLanes.elements)
  return &elements_;
}
inline const ::google::protobuf::RepeatedPtrField< ::atd::map::SurElements >&
EngineTargetLanes::elements() const {
  // @@protoc_insertion_point(field_list:atd.map.EngineTargetLanes.elements)
  return elements_;
}

// optional .atd.map.EyeQLaneCenter eyeQLaneParam = 110;
inline bool EngineTargetLanes::has_eyeqlaneparam() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EngineTargetLanes::set_has_eyeqlaneparam() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EngineTargetLanes::clear_has_eyeqlaneparam() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EngineTargetLanes::clear_eyeqlaneparam() {
  if (eyeqlaneparam_ != NULL) eyeqlaneparam_->::atd::map::EyeQLaneCenter::Clear();
  clear_has_eyeqlaneparam();
}
inline const ::atd::map::EyeQLaneCenter& EngineTargetLanes::eyeqlaneparam() const {
  // @@protoc_insertion_point(field_get:atd.map.EngineTargetLanes.eyeQLaneParam)
  return eyeqlaneparam_ != NULL ? *eyeqlaneparam_
                         : *::atd::map::EyeQLaneCenter::internal_default_instance();
}
inline ::atd::map::EyeQLaneCenter* EngineTargetLanes::mutable_eyeqlaneparam() {
  set_has_eyeqlaneparam();
  if (eyeqlaneparam_ == NULL) {
    eyeqlaneparam_ = new ::atd::map::EyeQLaneCenter;
  }
  // @@protoc_insertion_point(field_mutable:atd.map.EngineTargetLanes.eyeQLaneParam)
  return eyeqlaneparam_;
}
inline ::atd::map::EyeQLaneCenter* EngineTargetLanes::release_eyeqlaneparam() {
  // @@protoc_insertion_point(field_release:atd.map.EngineTargetLanes.eyeQLaneParam)
  clear_has_eyeqlaneparam();
  ::atd::map::EyeQLaneCenter* temp = eyeqlaneparam_;
  eyeqlaneparam_ = NULL;
  return temp;
}
inline void EngineTargetLanes::set_allocated_eyeqlaneparam(::atd::map::EyeQLaneCenter* eyeqlaneparam) {
  delete eyeqlaneparam_;
  eyeqlaneparam_ = eyeqlaneparam;
  if (eyeqlaneparam) {
    set_has_eyeqlaneparam();
  } else {
    clear_has_eyeqlaneparam();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.map.EngineTargetLanes.eyeQLaneParam)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace map
}  // namespace atd

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_modules_2fipc_2fmessage_2fprotobuf_2fhdmap_2fenginetargetlanes_2eproto__INCLUDED
