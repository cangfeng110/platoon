// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/ipc/message/protobuf/hdmap/enginedestination.proto

#ifndef PROTOBUF_modules_2fipc_2fmessage_2fprotobuf_2fhdmap_2fenginedestination_2eproto__INCLUDED
#define PROTOBUF_modules_2fipc_2fmessage_2fprotobuf_2fhdmap_2fenginedestination_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "modules/ipc/message/protobuf/common/header.pb.h"
#include "modules/ipc/message/protobuf/common/reserved.pb.h"
// @@protoc_insertion_point(includes)
namespace atd {
namespace common {
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Reserved;
class ReservedDefaultTypeInternal;
extern ReservedDefaultTypeInternal _Reserved_default_instance_;
}  // namespace common
namespace map {
class DesParkingKey;
class DesParkingKeyDefaultTypeInternal;
extern DesParkingKeyDefaultTypeInternal _DesParkingKey_default_instance_;
class DesPoint;
class DesPointDefaultTypeInternal;
extern DesPointDefaultTypeInternal _DesPoint_default_instance_;
class DesPointList;
class DesPointListDefaultTypeInternal;
extern DesPointListDefaultTypeInternal _DesPointList_default_instance_;
class DesTaskID;
class DesTaskIDDefaultTypeInternal;
extern DesTaskIDDefaultTypeInternal _DesTaskID_default_instance_;
class EngineDestination;
class EngineDestinationDefaultTypeInternal;
extern EngineDestinationDefaultTypeInternal _EngineDestination_default_instance_;
}  // namespace map
}  // namespace atd

namespace atd {
namespace map {

namespace protobuf_modules_2fipc_2fmessage_2fprotobuf_2fhdmap_2fenginedestination_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_modules_2fipc_2fmessage_2fprotobuf_2fhdmap_2fenginedestination_2eproto

enum EngineDestination_NaviSource {
  EngineDestination_NaviSource_UNKNOWN = 1,
  EngineDestination_NaviSource_DEBUG = 2,
  EngineDestination_NaviSource_APP = 3,
  EngineDestination_NaviSource_FICM = 4,
  EngineDestination_NaviSource_DRIVERSYS = 5
};
bool EngineDestination_NaviSource_IsValid(int value);
const EngineDestination_NaviSource EngineDestination_NaviSource_NaviSource_MIN = EngineDestination_NaviSource_UNKNOWN;
const EngineDestination_NaviSource EngineDestination_NaviSource_NaviSource_MAX = EngineDestination_NaviSource_DRIVERSYS;
const int EngineDestination_NaviSource_NaviSource_ARRAYSIZE = EngineDestination_NaviSource_NaviSource_MAX + 1;

// ===================================================================

class DesParkingKey : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.map.DesParkingKey) */ {
 public:
  DesParkingKey();
  virtual ~DesParkingKey();

  DesParkingKey(const DesParkingKey& from);

  inline DesParkingKey& operator=(const DesParkingKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DesParkingKey& default_instance();

  static inline const DesParkingKey* internal_default_instance() {
    return reinterpret_cast<const DesParkingKey*>(
               &_DesParkingKey_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(DesParkingKey* other);

  // implements Message ----------------------------------------------

  inline DesParkingKey* New() const PROTOBUF_FINAL { return New(NULL); }

  DesParkingKey* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DesParkingKey& from);
  void MergeFrom(const DesParkingKey& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DesParkingKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string garagestr = 5;
  bool has_garagestr() const;
  void clear_garagestr();
  static const int kGaragestrFieldNumber = 5;
  const ::std::string& garagestr() const;
  void set_garagestr(const ::std::string& value);
  #if LANG_CXX11
  void set_garagestr(::std::string&& value);
  #endif
  void set_garagestr(const char* value);
  void set_garagestr(const char* value, size_t size);
  ::std::string* mutable_garagestr();
  ::std::string* release_garagestr();
  void set_allocated_garagestr(::std::string* garagestr);

  // optional string floorstr = 6;
  bool has_floorstr() const;
  void clear_floorstr();
  static const int kFloorstrFieldNumber = 6;
  const ::std::string& floorstr() const;
  void set_floorstr(const ::std::string& value);
  #if LANG_CXX11
  void set_floorstr(::std::string&& value);
  #endif
  void set_floorstr(const char* value);
  void set_floorstr(const char* value, size_t size);
  ::std::string* mutable_floorstr();
  ::std::string* release_floorstr();
  void set_allocated_floorstr(::std::string* floorstr);

  // optional string areastr = 7;
  bool has_areastr() const;
  void clear_areastr();
  static const int kAreastrFieldNumber = 7;
  const ::std::string& areastr() const;
  void set_areastr(const ::std::string& value);
  #if LANG_CXX11
  void set_areastr(::std::string&& value);
  #endif
  void set_areastr(const char* value);
  void set_areastr(const char* value, size_t size);
  ::std::string* mutable_areastr();
  ::std::string* release_areastr();
  void set_allocated_areastr(::std::string* areastr);

  // optional string lotstr = 8;
  bool has_lotstr() const;
  void clear_lotstr();
  static const int kLotstrFieldNumber = 8;
  const ::std::string& lotstr() const;
  void set_lotstr(const ::std::string& value);
  #if LANG_CXX11
  void set_lotstr(::std::string&& value);
  #endif
  void set_lotstr(const char* value);
  void set_lotstr(const char* value, size_t size);
  ::std::string* mutable_lotstr();
  ::std::string* release_lotstr();
  void set_allocated_lotstr(::std::string* lotstr);

  // optional int32 garagekey = 1;
  bool has_garagekey() const;
  void clear_garagekey();
  static const int kGaragekeyFieldNumber = 1;
  ::google::protobuf::int32 garagekey() const;
  void set_garagekey(::google::protobuf::int32 value);

  // optional int32 floorkey = 2;
  bool has_floorkey() const;
  void clear_floorkey();
  static const int kFloorkeyFieldNumber = 2;
  ::google::protobuf::int32 floorkey() const;
  void set_floorkey(::google::protobuf::int32 value);

  // optional int32 areakey = 3;
  bool has_areakey() const;
  void clear_areakey();
  static const int kAreakeyFieldNumber = 3;
  ::google::protobuf::int32 areakey() const;
  void set_areakey(::google::protobuf::int32 value);

  // optional int32 lotkey = 4;
  bool has_lotkey() const;
  void clear_lotkey();
  static const int kLotkeyFieldNumber = 4;
  ::google::protobuf::int32 lotkey() const;
  void set_lotkey(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:atd.map.DesParkingKey)
 private:
  void set_has_garagekey();
  void clear_has_garagekey();
  void set_has_floorkey();
  void clear_has_floorkey();
  void set_has_areakey();
  void clear_has_areakey();
  void set_has_lotkey();
  void clear_has_lotkey();
  void set_has_garagestr();
  void clear_has_garagestr();
  void set_has_floorstr();
  void clear_has_floorstr();
  void set_has_areastr();
  void clear_has_areastr();
  void set_has_lotstr();
  void clear_has_lotstr();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr garagestr_;
  ::google::protobuf::internal::ArenaStringPtr floorstr_;
  ::google::protobuf::internal::ArenaStringPtr areastr_;
  ::google::protobuf::internal::ArenaStringPtr lotstr_;
  ::google::protobuf::int32 garagekey_;
  ::google::protobuf::int32 floorkey_;
  ::google::protobuf::int32 areakey_;
  ::google::protobuf::int32 lotkey_;
  friend struct protobuf_modules_2fipc_2fmessage_2fprotobuf_2fhdmap_2fenginedestination_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DesPoint : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.map.DesPoint) */ {
 public:
  DesPoint();
  virtual ~DesPoint();

  DesPoint(const DesPoint& from);

  inline DesPoint& operator=(const DesPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DesPoint& default_instance();

  static inline const DesPoint* internal_default_instance() {
    return reinterpret_cast<const DesPoint*>(
               &_DesPoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(DesPoint* other);

  // implements Message ----------------------------------------------

  inline DesPoint* New() const PROTOBUF_FINAL { return New(NULL); }

  DesPoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DesPoint& from);
  void MergeFrom(const DesPoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DesPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 longi = 1;
  bool has_longi() const;
  void clear_longi();
  static const int kLongiFieldNumber = 1;
  ::google::protobuf::int32 longi() const;
  void set_longi(::google::protobuf::int32 value);

  // optional int32 lati = 2;
  bool has_lati() const;
  void clear_lati();
  static const int kLatiFieldNumber = 2;
  ::google::protobuf::int32 lati() const;
  void set_lati(::google::protobuf::int32 value);

  // optional int32 level = 3;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 3;
  ::google::protobuf::int32 level() const;
  void set_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:atd.map.DesPoint)
 private:
  void set_has_longi();
  void clear_has_longi();
  void set_has_lati();
  void clear_has_lati();
  void set_has_level();
  void clear_has_level();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 longi_;
  ::google::protobuf::int32 lati_;
  ::google::protobuf::int32 level_;
  friend struct protobuf_modules_2fipc_2fmessage_2fprotobuf_2fhdmap_2fenginedestination_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DesPointList : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.map.DesPointList) */ {
 public:
  DesPointList();
  virtual ~DesPointList();

  DesPointList(const DesPointList& from);

  inline DesPointList& operator=(const DesPointList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DesPointList& default_instance();

  static inline const DesPointList* internal_default_instance() {
    return reinterpret_cast<const DesPointList*>(
               &_DesPointList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(DesPointList* other);

  // implements Message ----------------------------------------------

  inline DesPointList* New() const PROTOBUF_FINAL { return New(NULL); }

  DesPointList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DesPointList& from);
  void MergeFrom(const DesPointList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DesPointList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .atd.map.DesPoint destpoint = 1;
  int destpoint_size() const;
  void clear_destpoint();
  static const int kDestpointFieldNumber = 1;
  const ::atd::map::DesPoint& destpoint(int index) const;
  ::atd::map::DesPoint* mutable_destpoint(int index);
  ::atd::map::DesPoint* add_destpoint();
  ::google::protobuf::RepeatedPtrField< ::atd::map::DesPoint >*
      mutable_destpoint();
  const ::google::protobuf::RepeatedPtrField< ::atd::map::DesPoint >&
      destpoint() const;

  // @@protoc_insertion_point(class_scope:atd.map.DesPointList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::atd::map::DesPoint > destpoint_;
  friend struct protobuf_modules_2fipc_2fmessage_2fprotobuf_2fhdmap_2fenginedestination_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DesTaskID : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.map.DesTaskID) */ {
 public:
  DesTaskID();
  virtual ~DesTaskID();

  DesTaskID(const DesTaskID& from);

  inline DesTaskID& operator=(const DesTaskID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DesTaskID& default_instance();

  static inline const DesTaskID* internal_default_instance() {
    return reinterpret_cast<const DesTaskID*>(
               &_DesTaskID_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(DesTaskID* other);

  // implements Message ----------------------------------------------

  inline DesTaskID* New() const PROTOBUF_FINAL { return New(NULL); }

  DesTaskID* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DesTaskID& from);
  void MergeFrom(const DesTaskID& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DesTaskID* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 command = 1;
  bool has_command() const;
  void clear_command();
  static const int kCommandFieldNumber = 1;
  ::google::protobuf::uint32 command() const;
  void set_command(::google::protobuf::uint32 value);

  // optional uint32 value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::google::protobuf::uint32 value() const;
  void set_value(::google::protobuf::uint32 value);

  // optional uint32 carrier_id = 3;
  bool has_carrier_id() const;
  void clear_carrier_id();
  static const int kCarrierIdFieldNumber = 3;
  ::google::protobuf::uint32 carrier_id() const;
  void set_carrier_id(::google::protobuf::uint32 value);

  // optional uint32 parkinglot_id = 4;
  bool has_parkinglot_id() const;
  void clear_parkinglot_id();
  static const int kParkinglotIdFieldNumber = 4;
  ::google::protobuf::uint32 parkinglot_id() const;
  void set_parkinglot_id(::google::protobuf::uint32 value);

  // optional uint32 area_id = 5;
  bool has_area_id() const;
  void clear_area_id();
  static const int kAreaIdFieldNumber = 5;
  ::google::protobuf::uint32 area_id() const;
  void set_area_id(::google::protobuf::uint32 value);

  // optional int32 layer_id = 6;
  bool has_layer_id() const;
  void clear_layer_id();
  static const int kLayerIdFieldNumber = 6;
  ::google::protobuf::int32 layer_id() const;
  void set_layer_id(::google::protobuf::int32 value);

  // optional uint32 parkingspace_id = 7;
  bool has_parkingspace_id() const;
  void clear_parkingspace_id();
  static const int kParkingspaceIdFieldNumber = 7;
  ::google::protobuf::uint32 parkingspace_id() const;
  void set_parkingspace_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:atd.map.DesTaskID)
 private:
  void set_has_command();
  void clear_has_command();
  void set_has_value();
  void clear_has_value();
  void set_has_carrier_id();
  void clear_has_carrier_id();
  void set_has_parkinglot_id();
  void clear_has_parkinglot_id();
  void set_has_area_id();
  void clear_has_area_id();
  void set_has_layer_id();
  void clear_has_layer_id();
  void set_has_parkingspace_id();
  void clear_has_parkingspace_id();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 command_;
  ::google::protobuf::uint32 value_;
  ::google::protobuf::uint32 carrier_id_;
  ::google::protobuf::uint32 parkinglot_id_;
  ::google::protobuf::uint32 area_id_;
  ::google::protobuf::int32 layer_id_;
  ::google::protobuf::uint32 parkingspace_id_;
  friend struct protobuf_modules_2fipc_2fmessage_2fprotobuf_2fhdmap_2fenginedestination_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EngineDestination : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.map.EngineDestination) */ {
 public:
  EngineDestination();
  virtual ~EngineDestination();

  EngineDestination(const EngineDestination& from);

  inline EngineDestination& operator=(const EngineDestination& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const EngineDestination& default_instance();

  static inline const EngineDestination* internal_default_instance() {
    return reinterpret_cast<const EngineDestination*>(
               &_EngineDestination_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(EngineDestination* other);

  // implements Message ----------------------------------------------

  inline EngineDestination* New() const PROTOBUF_FINAL { return New(NULL); }

  EngineDestination* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const EngineDestination& from);
  void MergeFrom(const EngineDestination& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EngineDestination* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef EngineDestination_NaviSource NaviSource;
  static const NaviSource UNKNOWN =
    EngineDestination_NaviSource_UNKNOWN;
  static const NaviSource DEBUG =
    EngineDestination_NaviSource_DEBUG;
  static const NaviSource APP =
    EngineDestination_NaviSource_APP;
  static const NaviSource FICM =
    EngineDestination_NaviSource_FICM;
  static const NaviSource DRIVERSYS =
    EngineDestination_NaviSource_DRIVERSYS;
  static inline bool NaviSource_IsValid(int value) {
    return EngineDestination_NaviSource_IsValid(value);
  }
  static const NaviSource NaviSource_MIN =
    EngineDestination_NaviSource_NaviSource_MIN;
  static const NaviSource NaviSource_MAX =
    EngineDestination_NaviSource_NaviSource_MAX;
  static const int NaviSource_ARRAYSIZE =
    EngineDestination_NaviSource_NaviSource_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .atd.common.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::atd::common::Header& header() const;
  ::atd::common::Header* mutable_header();
  ::atd::common::Header* release_header();
  void set_allocated_header(::atd::common::Header* header);

  // optional .atd.common.Reserved reservedmsg = 2;
  bool has_reservedmsg() const;
  void clear_reservedmsg();
  static const int kReservedmsgFieldNumber = 2;
  const ::atd::common::Reserved& reservedmsg() const;
  ::atd::common::Reserved* mutable_reservedmsg();
  ::atd::common::Reserved* release_reservedmsg();
  void set_allocated_reservedmsg(::atd::common::Reserved* reservedmsg);

  // optional .atd.map.DesParkingKey des_parkingkey = 4;
  bool has_des_parkingkey() const;
  void clear_des_parkingkey();
  static const int kDesParkingkeyFieldNumber = 4;
  const ::atd::map::DesParkingKey& des_parkingkey() const;
  ::atd::map::DesParkingKey* mutable_des_parkingkey();
  ::atd::map::DesParkingKey* release_des_parkingkey();
  void set_allocated_des_parkingkey(::atd::map::DesParkingKey* des_parkingkey);

  // optional .atd.map.DesPointList des_pointlist = 5;
  bool has_des_pointlist() const;
  void clear_des_pointlist();
  static const int kDesPointlistFieldNumber = 5;
  const ::atd::map::DesPointList& des_pointlist() const;
  ::atd::map::DesPointList* mutable_des_pointlist();
  ::atd::map::DesPointList* release_des_pointlist();
  void set_allocated_des_pointlist(::atd::map::DesPointList* des_pointlist);

  // optional .atd.map.DesTaskID des_taskid = 6;
  bool has_des_taskid() const;
  void clear_des_taskid();
  static const int kDesTaskidFieldNumber = 6;
  const ::atd::map::DesTaskID& des_taskid() const;
  ::atd::map::DesTaskID* mutable_des_taskid();
  ::atd::map::DesTaskID* release_des_taskid();
  void set_allocated_des_taskid(::atd::map::DesTaskID* des_taskid);

  // optional .atd.map.EngineDestination.NaviSource source = 3;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 3;
  ::atd::map::EngineDestination_NaviSource source() const;
  void set_source(::atd::map::EngineDestination_NaviSource value);

  // @@protoc_insertion_point(class_scope:atd.map.EngineDestination)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_reservedmsg();
  void clear_has_reservedmsg();
  void set_has_source();
  void clear_has_source();
  void set_has_des_parkingkey();
  void clear_has_des_parkingkey();
  void set_has_des_pointlist();
  void clear_has_des_pointlist();
  void set_has_des_taskid();
  void clear_has_des_taskid();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::atd::common::Header* header_;
  ::atd::common::Reserved* reservedmsg_;
  ::atd::map::DesParkingKey* des_parkingkey_;
  ::atd::map::DesPointList* des_pointlist_;
  ::atd::map::DesTaskID* des_taskid_;
  int source_;
  friend struct protobuf_modules_2fipc_2fmessage_2fprotobuf_2fhdmap_2fenginedestination_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// DesParkingKey

// optional int32 garagekey = 1;
inline bool DesParkingKey::has_garagekey() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DesParkingKey::set_has_garagekey() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DesParkingKey::clear_has_garagekey() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DesParkingKey::clear_garagekey() {
  garagekey_ = 0;
  clear_has_garagekey();
}
inline ::google::protobuf::int32 DesParkingKey::garagekey() const {
  // @@protoc_insertion_point(field_get:atd.map.DesParkingKey.garagekey)
  return garagekey_;
}
inline void DesParkingKey::set_garagekey(::google::protobuf::int32 value) {
  set_has_garagekey();
  garagekey_ = value;
  // @@protoc_insertion_point(field_set:atd.map.DesParkingKey.garagekey)
}

// optional int32 floorkey = 2;
inline bool DesParkingKey::has_floorkey() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DesParkingKey::set_has_floorkey() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DesParkingKey::clear_has_floorkey() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DesParkingKey::clear_floorkey() {
  floorkey_ = 0;
  clear_has_floorkey();
}
inline ::google::protobuf::int32 DesParkingKey::floorkey() const {
  // @@protoc_insertion_point(field_get:atd.map.DesParkingKey.floorkey)
  return floorkey_;
}
inline void DesParkingKey::set_floorkey(::google::protobuf::int32 value) {
  set_has_floorkey();
  floorkey_ = value;
  // @@protoc_insertion_point(field_set:atd.map.DesParkingKey.floorkey)
}

// optional int32 areakey = 3;
inline bool DesParkingKey::has_areakey() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DesParkingKey::set_has_areakey() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DesParkingKey::clear_has_areakey() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DesParkingKey::clear_areakey() {
  areakey_ = 0;
  clear_has_areakey();
}
inline ::google::protobuf::int32 DesParkingKey::areakey() const {
  // @@protoc_insertion_point(field_get:atd.map.DesParkingKey.areakey)
  return areakey_;
}
inline void DesParkingKey::set_areakey(::google::protobuf::int32 value) {
  set_has_areakey();
  areakey_ = value;
  // @@protoc_insertion_point(field_set:atd.map.DesParkingKey.areakey)
}

// optional int32 lotkey = 4;
inline bool DesParkingKey::has_lotkey() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DesParkingKey::set_has_lotkey() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DesParkingKey::clear_has_lotkey() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DesParkingKey::clear_lotkey() {
  lotkey_ = 0;
  clear_has_lotkey();
}
inline ::google::protobuf::int32 DesParkingKey::lotkey() const {
  // @@protoc_insertion_point(field_get:atd.map.DesParkingKey.lotkey)
  return lotkey_;
}
inline void DesParkingKey::set_lotkey(::google::protobuf::int32 value) {
  set_has_lotkey();
  lotkey_ = value;
  // @@protoc_insertion_point(field_set:atd.map.DesParkingKey.lotkey)
}

// optional string garagestr = 5;
inline bool DesParkingKey::has_garagestr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DesParkingKey::set_has_garagestr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DesParkingKey::clear_has_garagestr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DesParkingKey::clear_garagestr() {
  garagestr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_garagestr();
}
inline const ::std::string& DesParkingKey::garagestr() const {
  // @@protoc_insertion_point(field_get:atd.map.DesParkingKey.garagestr)
  return garagestr_.GetNoArena();
}
inline void DesParkingKey::set_garagestr(const ::std::string& value) {
  set_has_garagestr();
  garagestr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:atd.map.DesParkingKey.garagestr)
}
#if LANG_CXX11
inline void DesParkingKey::set_garagestr(::std::string&& value) {
  set_has_garagestr();
  garagestr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:atd.map.DesParkingKey.garagestr)
}
#endif
inline void DesParkingKey::set_garagestr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_garagestr();
  garagestr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:atd.map.DesParkingKey.garagestr)
}
inline void DesParkingKey::set_garagestr(const char* value, size_t size) {
  set_has_garagestr();
  garagestr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:atd.map.DesParkingKey.garagestr)
}
inline ::std::string* DesParkingKey::mutable_garagestr() {
  set_has_garagestr();
  // @@protoc_insertion_point(field_mutable:atd.map.DesParkingKey.garagestr)
  return garagestr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DesParkingKey::release_garagestr() {
  // @@protoc_insertion_point(field_release:atd.map.DesParkingKey.garagestr)
  clear_has_garagestr();
  return garagestr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DesParkingKey::set_allocated_garagestr(::std::string* garagestr) {
  if (garagestr != NULL) {
    set_has_garagestr();
  } else {
    clear_has_garagestr();
  }
  garagestr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), garagestr);
  // @@protoc_insertion_point(field_set_allocated:atd.map.DesParkingKey.garagestr)
}

// optional string floorstr = 6;
inline bool DesParkingKey::has_floorstr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DesParkingKey::set_has_floorstr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DesParkingKey::clear_has_floorstr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DesParkingKey::clear_floorstr() {
  floorstr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_floorstr();
}
inline const ::std::string& DesParkingKey::floorstr() const {
  // @@protoc_insertion_point(field_get:atd.map.DesParkingKey.floorstr)
  return floorstr_.GetNoArena();
}
inline void DesParkingKey::set_floorstr(const ::std::string& value) {
  set_has_floorstr();
  floorstr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:atd.map.DesParkingKey.floorstr)
}
#if LANG_CXX11
inline void DesParkingKey::set_floorstr(::std::string&& value) {
  set_has_floorstr();
  floorstr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:atd.map.DesParkingKey.floorstr)
}
#endif
inline void DesParkingKey::set_floorstr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_floorstr();
  floorstr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:atd.map.DesParkingKey.floorstr)
}
inline void DesParkingKey::set_floorstr(const char* value, size_t size) {
  set_has_floorstr();
  floorstr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:atd.map.DesParkingKey.floorstr)
}
inline ::std::string* DesParkingKey::mutable_floorstr() {
  set_has_floorstr();
  // @@protoc_insertion_point(field_mutable:atd.map.DesParkingKey.floorstr)
  return floorstr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DesParkingKey::release_floorstr() {
  // @@protoc_insertion_point(field_release:atd.map.DesParkingKey.floorstr)
  clear_has_floorstr();
  return floorstr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DesParkingKey::set_allocated_floorstr(::std::string* floorstr) {
  if (floorstr != NULL) {
    set_has_floorstr();
  } else {
    clear_has_floorstr();
  }
  floorstr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), floorstr);
  // @@protoc_insertion_point(field_set_allocated:atd.map.DesParkingKey.floorstr)
}

// optional string areastr = 7;
inline bool DesParkingKey::has_areastr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DesParkingKey::set_has_areastr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DesParkingKey::clear_has_areastr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DesParkingKey::clear_areastr() {
  areastr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_areastr();
}
inline const ::std::string& DesParkingKey::areastr() const {
  // @@protoc_insertion_point(field_get:atd.map.DesParkingKey.areastr)
  return areastr_.GetNoArena();
}
inline void DesParkingKey::set_areastr(const ::std::string& value) {
  set_has_areastr();
  areastr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:atd.map.DesParkingKey.areastr)
}
#if LANG_CXX11
inline void DesParkingKey::set_areastr(::std::string&& value) {
  set_has_areastr();
  areastr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:atd.map.DesParkingKey.areastr)
}
#endif
inline void DesParkingKey::set_areastr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_areastr();
  areastr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:atd.map.DesParkingKey.areastr)
}
inline void DesParkingKey::set_areastr(const char* value, size_t size) {
  set_has_areastr();
  areastr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:atd.map.DesParkingKey.areastr)
}
inline ::std::string* DesParkingKey::mutable_areastr() {
  set_has_areastr();
  // @@protoc_insertion_point(field_mutable:atd.map.DesParkingKey.areastr)
  return areastr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DesParkingKey::release_areastr() {
  // @@protoc_insertion_point(field_release:atd.map.DesParkingKey.areastr)
  clear_has_areastr();
  return areastr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DesParkingKey::set_allocated_areastr(::std::string* areastr) {
  if (areastr != NULL) {
    set_has_areastr();
  } else {
    clear_has_areastr();
  }
  areastr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), areastr);
  // @@protoc_insertion_point(field_set_allocated:atd.map.DesParkingKey.areastr)
}

// optional string lotstr = 8;
inline bool DesParkingKey::has_lotstr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DesParkingKey::set_has_lotstr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DesParkingKey::clear_has_lotstr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DesParkingKey::clear_lotstr() {
  lotstr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_lotstr();
}
inline const ::std::string& DesParkingKey::lotstr() const {
  // @@protoc_insertion_point(field_get:atd.map.DesParkingKey.lotstr)
  return lotstr_.GetNoArena();
}
inline void DesParkingKey::set_lotstr(const ::std::string& value) {
  set_has_lotstr();
  lotstr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:atd.map.DesParkingKey.lotstr)
}
#if LANG_CXX11
inline void DesParkingKey::set_lotstr(::std::string&& value) {
  set_has_lotstr();
  lotstr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:atd.map.DesParkingKey.lotstr)
}
#endif
inline void DesParkingKey::set_lotstr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_lotstr();
  lotstr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:atd.map.DesParkingKey.lotstr)
}
inline void DesParkingKey::set_lotstr(const char* value, size_t size) {
  set_has_lotstr();
  lotstr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:atd.map.DesParkingKey.lotstr)
}
inline ::std::string* DesParkingKey::mutable_lotstr() {
  set_has_lotstr();
  // @@protoc_insertion_point(field_mutable:atd.map.DesParkingKey.lotstr)
  return lotstr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DesParkingKey::release_lotstr() {
  // @@protoc_insertion_point(field_release:atd.map.DesParkingKey.lotstr)
  clear_has_lotstr();
  return lotstr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DesParkingKey::set_allocated_lotstr(::std::string* lotstr) {
  if (lotstr != NULL) {
    set_has_lotstr();
  } else {
    clear_has_lotstr();
  }
  lotstr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lotstr);
  // @@protoc_insertion_point(field_set_allocated:atd.map.DesParkingKey.lotstr)
}

// -------------------------------------------------------------------

// DesPoint

// optional int32 longi = 1;
inline bool DesPoint::has_longi() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DesPoint::set_has_longi() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DesPoint::clear_has_longi() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DesPoint::clear_longi() {
  longi_ = 0;
  clear_has_longi();
}
inline ::google::protobuf::int32 DesPoint::longi() const {
  // @@protoc_insertion_point(field_get:atd.map.DesPoint.longi)
  return longi_;
}
inline void DesPoint::set_longi(::google::protobuf::int32 value) {
  set_has_longi();
  longi_ = value;
  // @@protoc_insertion_point(field_set:atd.map.DesPoint.longi)
}

// optional int32 lati = 2;
inline bool DesPoint::has_lati() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DesPoint::set_has_lati() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DesPoint::clear_has_lati() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DesPoint::clear_lati() {
  lati_ = 0;
  clear_has_lati();
}
inline ::google::protobuf::int32 DesPoint::lati() const {
  // @@protoc_insertion_point(field_get:atd.map.DesPoint.lati)
  return lati_;
}
inline void DesPoint::set_lati(::google::protobuf::int32 value) {
  set_has_lati();
  lati_ = value;
  // @@protoc_insertion_point(field_set:atd.map.DesPoint.lati)
}

// optional int32 level = 3;
inline bool DesPoint::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DesPoint::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DesPoint::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DesPoint::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 DesPoint::level() const {
  // @@protoc_insertion_point(field_get:atd.map.DesPoint.level)
  return level_;
}
inline void DesPoint::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:atd.map.DesPoint.level)
}

// -------------------------------------------------------------------

// DesPointList

// repeated .atd.map.DesPoint destpoint = 1;
inline int DesPointList::destpoint_size() const {
  return destpoint_.size();
}
inline void DesPointList::clear_destpoint() {
  destpoint_.Clear();
}
inline const ::atd::map::DesPoint& DesPointList::destpoint(int index) const {
  // @@protoc_insertion_point(field_get:atd.map.DesPointList.destpoint)
  return destpoint_.Get(index);
}
inline ::atd::map::DesPoint* DesPointList::mutable_destpoint(int index) {
  // @@protoc_insertion_point(field_mutable:atd.map.DesPointList.destpoint)
  return destpoint_.Mutable(index);
}
inline ::atd::map::DesPoint* DesPointList::add_destpoint() {
  // @@protoc_insertion_point(field_add:atd.map.DesPointList.destpoint)
  return destpoint_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::atd::map::DesPoint >*
DesPointList::mutable_destpoint() {
  // @@protoc_insertion_point(field_mutable_list:atd.map.DesPointList.destpoint)
  return &destpoint_;
}
inline const ::google::protobuf::RepeatedPtrField< ::atd::map::DesPoint >&
DesPointList::destpoint() const {
  // @@protoc_insertion_point(field_list:atd.map.DesPointList.destpoint)
  return destpoint_;
}

// -------------------------------------------------------------------

// DesTaskID

// optional uint32 command = 1;
inline bool DesTaskID::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DesTaskID::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DesTaskID::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DesTaskID::clear_command() {
  command_ = 0u;
  clear_has_command();
}
inline ::google::protobuf::uint32 DesTaskID::command() const {
  // @@protoc_insertion_point(field_get:atd.map.DesTaskID.command)
  return command_;
}
inline void DesTaskID::set_command(::google::protobuf::uint32 value) {
  set_has_command();
  command_ = value;
  // @@protoc_insertion_point(field_set:atd.map.DesTaskID.command)
}

// optional uint32 value = 2;
inline bool DesTaskID::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DesTaskID::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DesTaskID::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DesTaskID::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 DesTaskID::value() const {
  // @@protoc_insertion_point(field_get:atd.map.DesTaskID.value)
  return value_;
}
inline void DesTaskID::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:atd.map.DesTaskID.value)
}

// optional uint32 carrier_id = 3;
inline bool DesTaskID::has_carrier_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DesTaskID::set_has_carrier_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DesTaskID::clear_has_carrier_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DesTaskID::clear_carrier_id() {
  carrier_id_ = 0u;
  clear_has_carrier_id();
}
inline ::google::protobuf::uint32 DesTaskID::carrier_id() const {
  // @@protoc_insertion_point(field_get:atd.map.DesTaskID.carrier_id)
  return carrier_id_;
}
inline void DesTaskID::set_carrier_id(::google::protobuf::uint32 value) {
  set_has_carrier_id();
  carrier_id_ = value;
  // @@protoc_insertion_point(field_set:atd.map.DesTaskID.carrier_id)
}

// optional uint32 parkinglot_id = 4;
inline bool DesTaskID::has_parkinglot_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DesTaskID::set_has_parkinglot_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DesTaskID::clear_has_parkinglot_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DesTaskID::clear_parkinglot_id() {
  parkinglot_id_ = 0u;
  clear_has_parkinglot_id();
}
inline ::google::protobuf::uint32 DesTaskID::parkinglot_id() const {
  // @@protoc_insertion_point(field_get:atd.map.DesTaskID.parkinglot_id)
  return parkinglot_id_;
}
inline void DesTaskID::set_parkinglot_id(::google::protobuf::uint32 value) {
  set_has_parkinglot_id();
  parkinglot_id_ = value;
  // @@protoc_insertion_point(field_set:atd.map.DesTaskID.parkinglot_id)
}

// optional uint32 area_id = 5;
inline bool DesTaskID::has_area_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DesTaskID::set_has_area_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DesTaskID::clear_has_area_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DesTaskID::clear_area_id() {
  area_id_ = 0u;
  clear_has_area_id();
}
inline ::google::protobuf::uint32 DesTaskID::area_id() const {
  // @@protoc_insertion_point(field_get:atd.map.DesTaskID.area_id)
  return area_id_;
}
inline void DesTaskID::set_area_id(::google::protobuf::uint32 value) {
  set_has_area_id();
  area_id_ = value;
  // @@protoc_insertion_point(field_set:atd.map.DesTaskID.area_id)
}

// optional int32 layer_id = 6;
inline bool DesTaskID::has_layer_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DesTaskID::set_has_layer_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DesTaskID::clear_has_layer_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DesTaskID::clear_layer_id() {
  layer_id_ = 0;
  clear_has_layer_id();
}
inline ::google::protobuf::int32 DesTaskID::layer_id() const {
  // @@protoc_insertion_point(field_get:atd.map.DesTaskID.layer_id)
  return layer_id_;
}
inline void DesTaskID::set_layer_id(::google::protobuf::int32 value) {
  set_has_layer_id();
  layer_id_ = value;
  // @@protoc_insertion_point(field_set:atd.map.DesTaskID.layer_id)
}

// optional uint32 parkingspace_id = 7;
inline bool DesTaskID::has_parkingspace_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DesTaskID::set_has_parkingspace_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DesTaskID::clear_has_parkingspace_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DesTaskID::clear_parkingspace_id() {
  parkingspace_id_ = 0u;
  clear_has_parkingspace_id();
}
inline ::google::protobuf::uint32 DesTaskID::parkingspace_id() const {
  // @@protoc_insertion_point(field_get:atd.map.DesTaskID.parkingspace_id)
  return parkingspace_id_;
}
inline void DesTaskID::set_parkingspace_id(::google::protobuf::uint32 value) {
  set_has_parkingspace_id();
  parkingspace_id_ = value;
  // @@protoc_insertion_point(field_set:atd.map.DesTaskID.parkingspace_id)
}

// -------------------------------------------------------------------

// EngineDestination

// optional .atd.common.Header header = 1;
inline bool EngineDestination::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EngineDestination::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EngineDestination::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EngineDestination::clear_header() {
  if (header_ != NULL) header_->::atd::common::Header::Clear();
  clear_has_header();
}
inline const ::atd::common::Header& EngineDestination::header() const {
  // @@protoc_insertion_point(field_get:atd.map.EngineDestination.header)
  return header_ != NULL ? *header_
                         : *::atd::common::Header::internal_default_instance();
}
inline ::atd::common::Header* EngineDestination::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::atd::common::Header;
  }
  // @@protoc_insertion_point(field_mutable:atd.map.EngineDestination.header)
  return header_;
}
inline ::atd::common::Header* EngineDestination::release_header() {
  // @@protoc_insertion_point(field_release:atd.map.EngineDestination.header)
  clear_has_header();
  ::atd::common::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void EngineDestination::set_allocated_header(::atd::common::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.map.EngineDestination.header)
}

// optional .atd.common.Reserved reservedmsg = 2;
inline bool EngineDestination::has_reservedmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EngineDestination::set_has_reservedmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EngineDestination::clear_has_reservedmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EngineDestination::clear_reservedmsg() {
  if (reservedmsg_ != NULL) reservedmsg_->::atd::common::Reserved::Clear();
  clear_has_reservedmsg();
}
inline const ::atd::common::Reserved& EngineDestination::reservedmsg() const {
  // @@protoc_insertion_point(field_get:atd.map.EngineDestination.reservedmsg)
  return reservedmsg_ != NULL ? *reservedmsg_
                         : *::atd::common::Reserved::internal_default_instance();
}
inline ::atd::common::Reserved* EngineDestination::mutable_reservedmsg() {
  set_has_reservedmsg();
  if (reservedmsg_ == NULL) {
    reservedmsg_ = new ::atd::common::Reserved;
  }
  // @@protoc_insertion_point(field_mutable:atd.map.EngineDestination.reservedmsg)
  return reservedmsg_;
}
inline ::atd::common::Reserved* EngineDestination::release_reservedmsg() {
  // @@protoc_insertion_point(field_release:atd.map.EngineDestination.reservedmsg)
  clear_has_reservedmsg();
  ::atd::common::Reserved* temp = reservedmsg_;
  reservedmsg_ = NULL;
  return temp;
}
inline void EngineDestination::set_allocated_reservedmsg(::atd::common::Reserved* reservedmsg) {
  delete reservedmsg_;
  reservedmsg_ = reservedmsg;
  if (reservedmsg) {
    set_has_reservedmsg();
  } else {
    clear_has_reservedmsg();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.map.EngineDestination.reservedmsg)
}

// optional .atd.map.EngineDestination.NaviSource source = 3;
inline bool EngineDestination::has_source() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EngineDestination::set_has_source() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EngineDestination::clear_has_source() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EngineDestination::clear_source() {
  source_ = 1;
  clear_has_source();
}
inline ::atd::map::EngineDestination_NaviSource EngineDestination::source() const {
  // @@protoc_insertion_point(field_get:atd.map.EngineDestination.source)
  return static_cast< ::atd::map::EngineDestination_NaviSource >(source_);
}
inline void EngineDestination::set_source(::atd::map::EngineDestination_NaviSource value) {
  assert(::atd::map::EngineDestination_NaviSource_IsValid(value));
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:atd.map.EngineDestination.source)
}

// optional .atd.map.DesParkingKey des_parkingkey = 4;
inline bool EngineDestination::has_des_parkingkey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EngineDestination::set_has_des_parkingkey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EngineDestination::clear_has_des_parkingkey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EngineDestination::clear_des_parkingkey() {
  if (des_parkingkey_ != NULL) des_parkingkey_->::atd::map::DesParkingKey::Clear();
  clear_has_des_parkingkey();
}
inline const ::atd::map::DesParkingKey& EngineDestination::des_parkingkey() const {
  // @@protoc_insertion_point(field_get:atd.map.EngineDestination.des_parkingkey)
  return des_parkingkey_ != NULL ? *des_parkingkey_
                         : *::atd::map::DesParkingKey::internal_default_instance();
}
inline ::atd::map::DesParkingKey* EngineDestination::mutable_des_parkingkey() {
  set_has_des_parkingkey();
  if (des_parkingkey_ == NULL) {
    des_parkingkey_ = new ::atd::map::DesParkingKey;
  }
  // @@protoc_insertion_point(field_mutable:atd.map.EngineDestination.des_parkingkey)
  return des_parkingkey_;
}
inline ::atd::map::DesParkingKey* EngineDestination::release_des_parkingkey() {
  // @@protoc_insertion_point(field_release:atd.map.EngineDestination.des_parkingkey)
  clear_has_des_parkingkey();
  ::atd::map::DesParkingKey* temp = des_parkingkey_;
  des_parkingkey_ = NULL;
  return temp;
}
inline void EngineDestination::set_allocated_des_parkingkey(::atd::map::DesParkingKey* des_parkingkey) {
  delete des_parkingkey_;
  des_parkingkey_ = des_parkingkey;
  if (des_parkingkey) {
    set_has_des_parkingkey();
  } else {
    clear_has_des_parkingkey();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.map.EngineDestination.des_parkingkey)
}

// optional .atd.map.DesPointList des_pointlist = 5;
inline bool EngineDestination::has_des_pointlist() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EngineDestination::set_has_des_pointlist() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EngineDestination::clear_has_des_pointlist() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EngineDestination::clear_des_pointlist() {
  if (des_pointlist_ != NULL) des_pointlist_->::atd::map::DesPointList::Clear();
  clear_has_des_pointlist();
}
inline const ::atd::map::DesPointList& EngineDestination::des_pointlist() const {
  // @@protoc_insertion_point(field_get:atd.map.EngineDestination.des_pointlist)
  return des_pointlist_ != NULL ? *des_pointlist_
                         : *::atd::map::DesPointList::internal_default_instance();
}
inline ::atd::map::DesPointList* EngineDestination::mutable_des_pointlist() {
  set_has_des_pointlist();
  if (des_pointlist_ == NULL) {
    des_pointlist_ = new ::atd::map::DesPointList;
  }
  // @@protoc_insertion_point(field_mutable:atd.map.EngineDestination.des_pointlist)
  return des_pointlist_;
}
inline ::atd::map::DesPointList* EngineDestination::release_des_pointlist() {
  // @@protoc_insertion_point(field_release:atd.map.EngineDestination.des_pointlist)
  clear_has_des_pointlist();
  ::atd::map::DesPointList* temp = des_pointlist_;
  des_pointlist_ = NULL;
  return temp;
}
inline void EngineDestination::set_allocated_des_pointlist(::atd::map::DesPointList* des_pointlist) {
  delete des_pointlist_;
  des_pointlist_ = des_pointlist;
  if (des_pointlist) {
    set_has_des_pointlist();
  } else {
    clear_has_des_pointlist();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.map.EngineDestination.des_pointlist)
}

// optional .atd.map.DesTaskID des_taskid = 6;
inline bool EngineDestination::has_des_taskid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EngineDestination::set_has_des_taskid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EngineDestination::clear_has_des_taskid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EngineDestination::clear_des_taskid() {
  if (des_taskid_ != NULL) des_taskid_->::atd::map::DesTaskID::Clear();
  clear_has_des_taskid();
}
inline const ::atd::map::DesTaskID& EngineDestination::des_taskid() const {
  // @@protoc_insertion_point(field_get:atd.map.EngineDestination.des_taskid)
  return des_taskid_ != NULL ? *des_taskid_
                         : *::atd::map::DesTaskID::internal_default_instance();
}
inline ::atd::map::DesTaskID* EngineDestination::mutable_des_taskid() {
  set_has_des_taskid();
  if (des_taskid_ == NULL) {
    des_taskid_ = new ::atd::map::DesTaskID;
  }
  // @@protoc_insertion_point(field_mutable:atd.map.EngineDestination.des_taskid)
  return des_taskid_;
}
inline ::atd::map::DesTaskID* EngineDestination::release_des_taskid() {
  // @@protoc_insertion_point(field_release:atd.map.EngineDestination.des_taskid)
  clear_has_des_taskid();
  ::atd::map::DesTaskID* temp = des_taskid_;
  des_taskid_ = NULL;
  return temp;
}
inline void EngineDestination::set_allocated_des_taskid(::atd::map::DesTaskID* des_taskid) {
  delete des_taskid_;
  des_taskid_ = des_taskid;
  if (des_taskid) {
    set_has_des_taskid();
  } else {
    clear_has_des_taskid();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.map.EngineDestination.des_taskid)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace map
}  // namespace atd

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::atd::map::EngineDestination_NaviSource> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_modules_2fipc_2fmessage_2fprotobuf_2fhdmap_2fenginedestination_2eproto__INCLUDED
