// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/ipc/message/protobuf/hdmap/engineremaindistance.proto

#ifndef PROTOBUF_modules_2fipc_2fmessage_2fprotobuf_2fhdmap_2fengineremaindistance_2eproto__INCLUDED
#define PROTOBUF_modules_2fipc_2fmessage_2fprotobuf_2fhdmap_2fengineremaindistance_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include "modules/ipc/message/protobuf/common/header.pb.h"
#include "modules/ipc/message/protobuf/common/reserved.pb.h"
#include "modules/ipc/message/protobuf/localization/pose.pb.h"
#include "modules/ipc/message/protobuf/common/geometry.pb.h"
// @@protoc_insertion_point(includes)
namespace atd {
namespace common {
class Arrow2D;
class Arrow2DDefaultTypeInternal;
extern Arrow2DDefaultTypeInternal _Arrow2D_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Point2D;
class Point2DDefaultTypeInternal;
extern Point2DDefaultTypeInternal _Point2D_default_instance_;
class Point3D;
class Point3DDefaultTypeInternal;
extern Point3DDefaultTypeInternal _Point3D_default_instance_;
class PointENU;
class PointENUDefaultTypeInternal;
extern PointENUDefaultTypeInternal _PointENU_default_instance_;
class PointLLH;
class PointLLHDefaultTypeInternal;
extern PointLLHDefaultTypeInternal _PointLLH_default_instance_;
class Quaternion;
class QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class Reserved;
class ReservedDefaultTypeInternal;
extern ReservedDefaultTypeInternal _Reserved_default_instance_;
}  // namespace common
namespace localization {
class Pose;
class PoseDefaultTypeInternal;
extern PoseDefaultTypeInternal _Pose_default_instance_;
}  // namespace localization
namespace map {
class EngineRemainDistance;
class EngineRemainDistanceDefaultTypeInternal;
extern EngineRemainDistanceDefaultTypeInternal _EngineRemainDistance_default_instance_;
class LANE_LINK_KEY;
class LANE_LINK_KEYDefaultTypeInternal;
extern LANE_LINK_KEYDefaultTypeInternal _LANE_LINK_KEY_default_instance_;
class ONE_PARKING_SITE;
class ONE_PARKING_SITEDefaultTypeInternal;
extern ONE_PARKING_SITEDefaultTypeInternal _ONE_PARKING_SITE_default_instance_;
class SPEED_LIMIT;
class SPEED_LIMITDefaultTypeInternal;
extern SPEED_LIMITDefaultTypeInternal _SPEED_LIMIT_default_instance_;
class TSR_DISTANCE;
class TSR_DISTANCEDefaultTypeInternal;
extern TSR_DISTANCEDefaultTypeInternal _TSR_DISTANCE_default_instance_;
}  // namespace map
}  // namespace atd

namespace atd {
namespace map {

namespace protobuf_modules_2fipc_2fmessage_2fprotobuf_2fhdmap_2fengineremaindistance_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_modules_2fipc_2fmessage_2fprotobuf_2fhdmap_2fengineremaindistance_2eproto

// ===================================================================

class LANE_LINK_KEY : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.map.LANE_LINK_KEY) */ {
 public:
  LANE_LINK_KEY();
  virtual ~LANE_LINK_KEY();

  LANE_LINK_KEY(const LANE_LINK_KEY& from);

  inline LANE_LINK_KEY& operator=(const LANE_LINK_KEY& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const LANE_LINK_KEY& default_instance();

  static inline const LANE_LINK_KEY* internal_default_instance() {
    return reinterpret_cast<const LANE_LINK_KEY*>(
               &_LANE_LINK_KEY_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(LANE_LINK_KEY* other);

  // implements Message ----------------------------------------------

  inline LANE_LINK_KEY* New() const PROTOBUF_FINAL { return New(NULL); }

  LANE_LINK_KEY* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const LANE_LINK_KEY& from);
  void MergeFrom(const LANE_LINK_KEY& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LANE_LINK_KEY* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 m_iRoadId = 1;
  bool has_m_iroadid() const;
  void clear_m_iroadid();
  static const int kMIRoadIdFieldNumber = 1;
  ::google::protobuf::int64 m_iroadid() const;
  void set_m_iroadid(::google::protobuf::int64 value);

  // optional int32 m_iSectionSeq = 2;
  bool has_m_isectionseq() const;
  void clear_m_isectionseq();
  static const int kMISectionSeqFieldNumber = 2;
  ::google::protobuf::int32 m_isectionseq() const;
  void set_m_isectionseq(::google::protobuf::int32 value);

  // optional int32 m_iLaneNum = 3;
  bool has_m_ilanenum() const;
  void clear_m_ilanenum();
  static const int kMILaneNumFieldNumber = 3;
  ::google::protobuf::int32 m_ilanenum() const;
  void set_m_ilanenum(::google::protobuf::int32 value);

  // optional int32 m_iBranch = 4;
  bool has_m_ibranch() const;
  void clear_m_ibranch();
  static const int kMIBranchFieldNumber = 4;
  ::google::protobuf::int32 m_ibranch() const;
  void set_m_ibranch(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:atd.map.LANE_LINK_KEY)
 private:
  void set_has_m_iroadid();
  void clear_has_m_iroadid();
  void set_has_m_isectionseq();
  void clear_has_m_isectionseq();
  void set_has_m_ilanenum();
  void clear_has_m_ilanenum();
  void set_has_m_ibranch();
  void clear_has_m_ibranch();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 m_iroadid_;
  ::google::protobuf::int32 m_isectionseq_;
  ::google::protobuf::int32 m_ilanenum_;
  ::google::protobuf::int32 m_ibranch_;
  friend struct protobuf_modules_2fipc_2fmessage_2fprotobuf_2fhdmap_2fengineremaindistance_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SPEED_LIMIT : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.map.SPEED_LIMIT) */ {
 public:
  SPEED_LIMIT();
  virtual ~SPEED_LIMIT();

  SPEED_LIMIT(const SPEED_LIMIT& from);

  inline SPEED_LIMIT& operator=(const SPEED_LIMIT& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SPEED_LIMIT& default_instance();

  static inline const SPEED_LIMIT* internal_default_instance() {
    return reinterpret_cast<const SPEED_LIMIT*>(
               &_SPEED_LIMIT_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(SPEED_LIMIT* other);

  // implements Message ----------------------------------------------

  inline SPEED_LIMIT* New() const PROTOBUF_FINAL { return New(NULL); }

  SPEED_LIMIT* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SPEED_LIMIT& from);
  void MergeFrom(const SPEED_LIMIT& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SPEED_LIMIT* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 m_iMaxSpeed = 1;
  bool has_m_imaxspeed() const;
  void clear_m_imaxspeed();
  static const int kMIMaxSpeedFieldNumber = 1;
  ::google::protobuf::int32 m_imaxspeed() const;
  void set_m_imaxspeed(::google::protobuf::int32 value);

  // optional int32 m_iMinSpeed = 2;
  bool has_m_iminspeed() const;
  void clear_m_iminspeed();
  static const int kMIMinSpeedFieldNumber = 2;
  ::google::protobuf::int32 m_iminspeed() const;
  void set_m_iminspeed(::google::protobuf::int32 value);

  // optional int32 m_iRecommentSpeed = 3;
  bool has_m_irecommentspeed() const;
  void clear_m_irecommentspeed();
  static const int kMIRecommentSpeedFieldNumber = 3;
  ::google::protobuf::int32 m_irecommentspeed() const;
  void set_m_irecommentspeed(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:atd.map.SPEED_LIMIT)
 private:
  void set_has_m_imaxspeed();
  void clear_has_m_imaxspeed();
  void set_has_m_iminspeed();
  void clear_has_m_iminspeed();
  void set_has_m_irecommentspeed();
  void clear_has_m_irecommentspeed();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 m_imaxspeed_;
  ::google::protobuf::int32 m_iminspeed_;
  ::google::protobuf::int32 m_irecommentspeed_;
  friend struct protobuf_modules_2fipc_2fmessage_2fprotobuf_2fhdmap_2fengineremaindistance_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TSR_DISTANCE : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.map.TSR_DISTANCE) */ {
 public:
  TSR_DISTANCE();
  virtual ~TSR_DISTANCE();

  TSR_DISTANCE(const TSR_DISTANCE& from);

  inline TSR_DISTANCE& operator=(const TSR_DISTANCE& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const TSR_DISTANCE& default_instance();

  static inline const TSR_DISTANCE* internal_default_instance() {
    return reinterpret_cast<const TSR_DISTANCE*>(
               &_TSR_DISTANCE_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(TSR_DISTANCE* other);

  // implements Message ----------------------------------------------

  inline TSR_DISTANCE* New() const PROTOBUF_FINAL { return New(NULL); }

  TSR_DISTANCE* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const TSR_DISTANCE& from);
  void MergeFrom(const TSR_DISTANCE& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TSR_DISTANCE* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .atd.map.SPEED_LIMIT stCurrentSpeedLimit = 2;
  bool has_stcurrentspeedlimit() const;
  void clear_stcurrentspeedlimit();
  static const int kStCurrentSpeedLimitFieldNumber = 2;
  const ::atd::map::SPEED_LIMIT& stcurrentspeedlimit() const;
  ::atd::map::SPEED_LIMIT* mutable_stcurrentspeedlimit();
  ::atd::map::SPEED_LIMIT* release_stcurrentspeedlimit();
  void set_allocated_stcurrentspeedlimit(::atd::map::SPEED_LIMIT* stcurrentspeedlimit);

  // optional .atd.map.SPEED_LIMIT stNextSpeedLimit = 3;
  bool has_stnextspeedlimit() const;
  void clear_stnextspeedlimit();
  static const int kStNextSpeedLimitFieldNumber = 3;
  const ::atd::map::SPEED_LIMIT& stnextspeedlimit() const;
  ::atd::map::SPEED_LIMIT* mutable_stnextspeedlimit();
  ::atd::map::SPEED_LIMIT* release_stnextspeedlimit();
  void set_allocated_stnextspeedlimit(::atd::map::SPEED_LIMIT* stnextspeedlimit);

  // optional .atd.map.LANE_LINK_KEY stCurrentLaneKey = 4;
  bool has_stcurrentlanekey() const;
  void clear_stcurrentlanekey();
  static const int kStCurrentLaneKeyFieldNumber = 4;
  const ::atd::map::LANE_LINK_KEY& stcurrentlanekey() const;
  ::atd::map::LANE_LINK_KEY* mutable_stcurrentlanekey();
  ::atd::map::LANE_LINK_KEY* release_stcurrentlanekey();
  void set_allocated_stcurrentlanekey(::atd::map::LANE_LINK_KEY* stcurrentlanekey);

  // optional int32 iCurrentLaneKeyID = 5;
  bool has_icurrentlanekeyid() const;
  void clear_icurrentlanekeyid();
  static const int kICurrentLaneKeyIDFieldNumber = 5;
  ::google::protobuf::int32 icurrentlanekeyid() const;
  void set_icurrentlanekeyid(::google::protobuf::int32 value);

  // optional int32 iTotleLaneKeyID = 6;
  bool has_itotlelanekeyid() const;
  void clear_itotlelanekeyid();
  static const int kITotleLaneKeyIDFieldNumber = 6;
  ::google::protobuf::int32 itotlelanekeyid() const;
  void set_itotlelanekeyid(::google::protobuf::int32 value);

  // optional int32 iTurnFlag = 7;
  bool has_iturnflag() const;
  void clear_iturnflag();
  static const int kITurnFlagFieldNumber = 7;
  ::google::protobuf::int32 iturnflag() const;
  void set_iturnflag(::google::protobuf::int32 value);

  // optional int32 iTurnStatus = 8;
  bool has_iturnstatus() const;
  void clear_iturnstatus();
  static const int kITurnStatusFieldNumber = 8;
  ::google::protobuf::int32 iturnstatus() const;
  void set_iturnstatus(::google::protobuf::int32 value);

  // optional int32 isCalculatedLane = 9;
  bool has_iscalculatedlane() const;
  void clear_iscalculatedlane();
  static const int kIsCalculatedLaneFieldNumber = 9;
  ::google::protobuf::int32 iscalculatedlane() const;
  void set_iscalculatedlane(::google::protobuf::int32 value);

  // optional int32 isDummyRoad = 10;
  bool has_isdummyroad() const;
  void clear_isdummyroad();
  static const int kIsDummyRoadFieldNumber = 10;
  ::google::protobuf::int32 isdummyroad() const;
  void set_isdummyroad(::google::protobuf::int32 value);

  // optional int32 iTotleStoplineNum = 11;
  bool has_itotlestoplinenum() const;
  void clear_itotlestoplinenum();
  static const int kITotleStoplineNumFieldNumber = 11;
  ::google::protobuf::int32 itotlestoplinenum() const;
  void set_itotlestoplinenum(::google::protobuf::int32 value);

  // optional int32 iRemainStoplineNum = 12;
  bool has_iremainstoplinenum() const;
  void clear_iremainstoplinenum();
  static const int kIRemainStoplineNumFieldNumber = 12;
  ::google::protobuf::int32 iremainstoplinenum() const;
  void set_iremainstoplinenum(::google::protobuf::int32 value);

  // optional int32 isLeftTurnZone = 13;
  bool has_isleftturnzone() const;
  void clear_isleftturnzone();
  static const int kIsLeftTurnZoneFieldNumber = 13;
  ::google::protobuf::int32 isleftturnzone() const;
  void set_isleftturnzone(::google::protobuf::int32 value);

  // optional int32 iParkingStatus = 14;
  bool has_iparkingstatus() const;
  void clear_iparkingstatus();
  static const int kIParkingStatusFieldNumber = 14;
  ::google::protobuf::int32 iparkingstatus() const;
  void set_iparkingstatus(::google::protobuf::int32 value);

  // optional double dDistance2Stopline = 15;
  bool has_ddistance2stopline() const;
  void clear_ddistance2stopline();
  static const int kDDistance2StoplineFieldNumber = 15;
  double ddistance2stopline() const;
  void set_ddistance2stopline(double value);

  // optional double dDistance2Destination = 16;
  bool has_ddistance2destination() const;
  void clear_ddistance2destination();
  static const int kDDistance2DestinationFieldNumber = 16;
  double ddistance2destination() const;
  void set_ddistance2destination(double value);

  // optional double dWholeRouteLength = 17;
  bool has_dwholeroutelength() const;
  void clear_dwholeroutelength();
  static const int kDWholeRouteLengthFieldNumber = 17;
  double dwholeroutelength() const;
  void set_dwholeroutelength(double value);

  // optional double dDistance2Parking = 18;
  bool has_ddistance2parking() const;
  void clear_ddistance2parking();
  static const int kDDistance2ParkingFieldNumber = 18;
  double ddistance2parking() const;
  void set_ddistance2parking(double value);

  // optional double dDistance2LaneEnd = 19;
  bool has_ddistance2laneend() const;
  void clear_ddistance2laneend();
  static const int kDDistance2LaneEndFieldNumber = 19;
  double ddistance2laneend() const;
  void set_ddistance2laneend(double value);

  // optional double dWholeParkingLength = 20;
  bool has_dwholeparkinglength() const;
  void clear_dwholeparkinglength();
  static const int kDWholeParkingLengthFieldNumber = 20;
  double dwholeparkinglength() const;
  void set_dwholeparkinglength(double value);

  // @@protoc_insertion_point(class_scope:atd.map.TSR_DISTANCE)
 private:
  void set_has_stcurrentspeedlimit();
  void clear_has_stcurrentspeedlimit();
  void set_has_stnextspeedlimit();
  void clear_has_stnextspeedlimit();
  void set_has_stcurrentlanekey();
  void clear_has_stcurrentlanekey();
  void set_has_icurrentlanekeyid();
  void clear_has_icurrentlanekeyid();
  void set_has_itotlelanekeyid();
  void clear_has_itotlelanekeyid();
  void set_has_iturnflag();
  void clear_has_iturnflag();
  void set_has_iturnstatus();
  void clear_has_iturnstatus();
  void set_has_iscalculatedlane();
  void clear_has_iscalculatedlane();
  void set_has_isdummyroad();
  void clear_has_isdummyroad();
  void set_has_itotlestoplinenum();
  void clear_has_itotlestoplinenum();
  void set_has_iremainstoplinenum();
  void clear_has_iremainstoplinenum();
  void set_has_isleftturnzone();
  void clear_has_isleftturnzone();
  void set_has_iparkingstatus();
  void clear_has_iparkingstatus();
  void set_has_ddistance2stopline();
  void clear_has_ddistance2stopline();
  void set_has_ddistance2destination();
  void clear_has_ddistance2destination();
  void set_has_dwholeroutelength();
  void clear_has_dwholeroutelength();
  void set_has_ddistance2parking();
  void clear_has_ddistance2parking();
  void set_has_ddistance2laneend();
  void clear_has_ddistance2laneend();
  void set_has_dwholeparkinglength();
  void clear_has_dwholeparkinglength();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::atd::map::SPEED_LIMIT* stcurrentspeedlimit_;
  ::atd::map::SPEED_LIMIT* stnextspeedlimit_;
  ::atd::map::LANE_LINK_KEY* stcurrentlanekey_;
  ::google::protobuf::int32 icurrentlanekeyid_;
  ::google::protobuf::int32 itotlelanekeyid_;
  ::google::protobuf::int32 iturnflag_;
  ::google::protobuf::int32 iturnstatus_;
  ::google::protobuf::int32 iscalculatedlane_;
  ::google::protobuf::int32 isdummyroad_;
  ::google::protobuf::int32 itotlestoplinenum_;
  ::google::protobuf::int32 iremainstoplinenum_;
  ::google::protobuf::int32 isleftturnzone_;
  ::google::protobuf::int32 iparkingstatus_;
  double ddistance2stopline_;
  double ddistance2destination_;
  double dwholeroutelength_;
  double ddistance2parking_;
  double ddistance2laneend_;
  double dwholeparkinglength_;
  friend struct protobuf_modules_2fipc_2fmessage_2fprotobuf_2fhdmap_2fengineremaindistance_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ONE_PARKING_SITE : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.map.ONE_PARKING_SITE) */ {
 public:
  ONE_PARKING_SITE();
  virtual ~ONE_PARKING_SITE();

  ONE_PARKING_SITE(const ONE_PARKING_SITE& from);

  inline ONE_PARKING_SITE& operator=(const ONE_PARKING_SITE& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ONE_PARKING_SITE& default_instance();

  static inline const ONE_PARKING_SITE* internal_default_instance() {
    return reinterpret_cast<const ONE_PARKING_SITE*>(
               &_ONE_PARKING_SITE_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(ONE_PARKING_SITE* other);

  // implements Message ----------------------------------------------

  inline ONE_PARKING_SITE* New() const PROTOBUF_FINAL { return New(NULL); }

  ONE_PARKING_SITE* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ONE_PARKING_SITE& from);
  void MergeFrom(const ONE_PARKING_SITE& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ONE_PARKING_SITE* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .atd.map.LANE_LINK_KEY stAttachedRoad = 2;
  int stattachedroad_size() const;
  void clear_stattachedroad();
  static const int kStAttachedRoadFieldNumber = 2;
  const ::atd::map::LANE_LINK_KEY& stattachedroad(int index) const;
  ::atd::map::LANE_LINK_KEY* mutable_stattachedroad(int index);
  ::atd::map::LANE_LINK_KEY* add_stattachedroad();
  ::google::protobuf::RepeatedPtrField< ::atd::map::LANE_LINK_KEY >*
      mutable_stattachedroad();
  const ::google::protobuf::RepeatedPtrField< ::atd::map::LANE_LINK_KEY >&
      stattachedroad() const;

  // repeated .atd.common.Point3D stShapePoint2VehicleCor = 4;
  int stshapepoint2vehiclecor_size() const;
  void clear_stshapepoint2vehiclecor();
  static const int kStShapePoint2VehicleCorFieldNumber = 4;
  const ::atd::common::Point3D& stshapepoint2vehiclecor(int index) const;
  ::atd::common::Point3D* mutable_stshapepoint2vehiclecor(int index);
  ::atd::common::Point3D* add_stshapepoint2vehiclecor();
  ::google::protobuf::RepeatedPtrField< ::atd::common::Point3D >*
      mutable_stshapepoint2vehiclecor();
  const ::google::protobuf::RepeatedPtrField< ::atd::common::Point3D >&
      stshapepoint2vehiclecor() const;

  // optional .atd.common.Point3D stPoint2VehicleCor = 3;
  bool has_stpoint2vehiclecor() const;
  void clear_stpoint2vehiclecor();
  static const int kStPoint2VehicleCorFieldNumber = 3;
  const ::atd::common::Point3D& stpoint2vehiclecor() const;
  ::atd::common::Point3D* mutable_stpoint2vehiclecor();
  ::atd::common::Point3D* release_stpoint2vehiclecor();
  void set_allocated_stpoint2vehiclecor(::atd::common::Point3D* stpoint2vehiclecor);

  // optional int32 iAttachedRoadCount = 5;
  bool has_iattachedroadcount() const;
  void clear_iattachedroadcount();
  static const int kIAttachedRoadCountFieldNumber = 5;
  ::google::protobuf::int32 iattachedroadcount() const;
  void set_iattachedroadcount(::google::protobuf::int32 value);

  // optional int32 iSID = 6;
  bool has_isid() const;
  void clear_isid();
  static const int kISIDFieldNumber = 6;
  ::google::protobuf::int32 isid() const;
  void set_isid(::google::protobuf::int32 value);

  // optional int32 iLength = 7;
  bool has_ilength() const;
  void clear_ilength();
  static const int kILengthFieldNumber = 7;
  ::google::protobuf::int32 ilength() const;
  void set_ilength(::google::protobuf::int32 value);

  // optional int32 iWidth = 8;
  bool has_iwidth() const;
  void clear_iwidth();
  static const int kIWidthFieldNumber = 8;
  ::google::protobuf::int32 iwidth() const;
  void set_iwidth(::google::protobuf::int32 value);

  // optional int32 iAttribute = 9;
  bool has_iattribute() const;
  void clear_iattribute();
  static const int kIAttributeFieldNumber = 9;
  ::google::protobuf::int32 iattribute() const;
  void set_iattribute(::google::protobuf::int32 value);

  // optional int32 iStyle = 10;
  bool has_istyle() const;
  void clear_istyle();
  static const int kIStyleFieldNumber = 10;
  ::google::protobuf::int32 istyle() const;
  void set_istyle(::google::protobuf::int32 value);

  // optional int32 iShapeType = 11;
  bool has_ishapetype() const;
  void clear_ishapetype();
  static const int kIShapeTypeFieldNumber = 11;
  ::google::protobuf::int32 ishapetype() const;
  void set_ishapetype(::google::protobuf::int32 value);

  // optional int32 iShapeNum = 12;
  bool has_ishapenum() const;
  void clear_ishapenum();
  static const int kIShapeNumFieldNumber = 12;
  ::google::protobuf::int32 ishapenum() const;
  void set_ishapenum(::google::protobuf::int32 value);

  // optional int32 iAppStatus = 13;
  bool has_iappstatus() const;
  void clear_iappstatus();
  static const int kIAppStatusFieldNumber = 13;
  ::google::protobuf::int32 iappstatus() const;
  void set_iappstatus(::google::protobuf::int32 value);

  // optional int32 iAdd = 14;
  bool has_iadd() const;
  void clear_iadd();
  static const int kIAddFieldNumber = 14;
  ::google::protobuf::int32 iadd() const;
  void set_iadd(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:atd.map.ONE_PARKING_SITE)
 private:
  void set_has_stpoint2vehiclecor();
  void clear_has_stpoint2vehiclecor();
  void set_has_iattachedroadcount();
  void clear_has_iattachedroadcount();
  void set_has_isid();
  void clear_has_isid();
  void set_has_ilength();
  void clear_has_ilength();
  void set_has_iwidth();
  void clear_has_iwidth();
  void set_has_iattribute();
  void clear_has_iattribute();
  void set_has_istyle();
  void clear_has_istyle();
  void set_has_ishapetype();
  void clear_has_ishapetype();
  void set_has_ishapenum();
  void clear_has_ishapenum();
  void set_has_iappstatus();
  void clear_has_iappstatus();
  void set_has_iadd();
  void clear_has_iadd();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::atd::map::LANE_LINK_KEY > stattachedroad_;
  ::google::protobuf::RepeatedPtrField< ::atd::common::Point3D > stshapepoint2vehiclecor_;
  ::atd::common::Point3D* stpoint2vehiclecor_;
  ::google::protobuf::int32 iattachedroadcount_;
  ::google::protobuf::int32 isid_;
  ::google::protobuf::int32 ilength_;
  ::google::protobuf::int32 iwidth_;
  ::google::protobuf::int32 iattribute_;
  ::google::protobuf::int32 istyle_;
  ::google::protobuf::int32 ishapetype_;
  ::google::protobuf::int32 ishapenum_;
  ::google::protobuf::int32 iappstatus_;
  ::google::protobuf::int32 iadd_;
  friend struct protobuf_modules_2fipc_2fmessage_2fprotobuf_2fhdmap_2fengineremaindistance_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EngineRemainDistance : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.map.EngineRemainDistance) */ {
 public:
  EngineRemainDistance();
  virtual ~EngineRemainDistance();

  EngineRemainDistance(const EngineRemainDistance& from);

  inline EngineRemainDistance& operator=(const EngineRemainDistance& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const EngineRemainDistance& default_instance();

  static inline const EngineRemainDistance* internal_default_instance() {
    return reinterpret_cast<const EngineRemainDistance*>(
               &_EngineRemainDistance_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(EngineRemainDistance* other);

  // implements Message ----------------------------------------------

  inline EngineRemainDistance* New() const PROTOBUF_FINAL { return New(NULL); }

  EngineRemainDistance* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const EngineRemainDistance& from);
  void MergeFrom(const EngineRemainDistance& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EngineRemainDistance* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string sTaskID = 6;
  bool has_staskid() const;
  void clear_staskid();
  static const int kSTaskIDFieldNumber = 6;
  const ::std::string& staskid() const;
  void set_staskid(const ::std::string& value);
  #if LANG_CXX11
  void set_staskid(::std::string&& value);
  #endif
  void set_staskid(const char* value);
  void set_staskid(const char* value, size_t size);
  ::std::string* mutable_staskid();
  ::std::string* release_staskid();
  void set_allocated_staskid(::std::string* staskid);

  // optional .atd.common.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::atd::common::Header& header() const;
  ::atd::common::Header* mutable_header();
  ::atd::common::Header* release_header();
  void set_allocated_header(::atd::common::Header* header);

  // optional .atd.common.Reserved reservedmsg = 2;
  bool has_reservedmsg() const;
  void clear_reservedmsg();
  static const int kReservedmsgFieldNumber = 2;
  const ::atd::common::Reserved& reservedmsg() const;
  ::atd::common::Reserved* mutable_reservedmsg();
  ::atd::common::Reserved* release_reservedmsg();
  void set_allocated_reservedmsg(::atd::common::Reserved* reservedmsg);

  // optional .atd.localization.Pose pose = 3;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 3;
  const ::atd::localization::Pose& pose() const;
  ::atd::localization::Pose* mutable_pose();
  ::atd::localization::Pose* release_pose();
  void set_allocated_pose(::atd::localization::Pose* pose);

  // optional .atd.map.TSR_DISTANCE tsrdistance = 4;
  bool has_tsrdistance() const;
  void clear_tsrdistance();
  static const int kTsrdistanceFieldNumber = 4;
  const ::atd::map::TSR_DISTANCE& tsrdistance() const;
  ::atd::map::TSR_DISTANCE* mutable_tsrdistance();
  ::atd::map::TSR_DISTANCE* release_tsrdistance();
  void set_allocated_tsrdistance(::atd::map::TSR_DISTANCE* tsrdistance);

  // optional .atd.map.ONE_PARKING_SITE oneparkingsite = 5;
  bool has_oneparkingsite() const;
  void clear_oneparkingsite();
  static const int kOneparkingsiteFieldNumber = 5;
  const ::atd::map::ONE_PARKING_SITE& oneparkingsite() const;
  ::atd::map::ONE_PARKING_SITE* mutable_oneparkingsite();
  ::atd::map::ONE_PARKING_SITE* release_oneparkingsite();
  void set_allocated_oneparkingsite(::atd::map::ONE_PARKING_SITE* oneparkingsite);

  // @@protoc_insertion_point(class_scope:atd.map.EngineRemainDistance)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_reservedmsg();
  void clear_has_reservedmsg();
  void set_has_pose();
  void clear_has_pose();
  void set_has_tsrdistance();
  void clear_has_tsrdistance();
  void set_has_oneparkingsite();
  void clear_has_oneparkingsite();
  void set_has_staskid();
  void clear_has_staskid();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr staskid_;
  ::atd::common::Header* header_;
  ::atd::common::Reserved* reservedmsg_;
  ::atd::localization::Pose* pose_;
  ::atd::map::TSR_DISTANCE* tsrdistance_;
  ::atd::map::ONE_PARKING_SITE* oneparkingsite_;
  friend struct protobuf_modules_2fipc_2fmessage_2fprotobuf_2fhdmap_2fengineremaindistance_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// LANE_LINK_KEY

// optional int64 m_iRoadId = 1;
inline bool LANE_LINK_KEY::has_m_iroadid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LANE_LINK_KEY::set_has_m_iroadid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LANE_LINK_KEY::clear_has_m_iroadid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LANE_LINK_KEY::clear_m_iroadid() {
  m_iroadid_ = GOOGLE_LONGLONG(0);
  clear_has_m_iroadid();
}
inline ::google::protobuf::int64 LANE_LINK_KEY::m_iroadid() const {
  // @@protoc_insertion_point(field_get:atd.map.LANE_LINK_KEY.m_iRoadId)
  return m_iroadid_;
}
inline void LANE_LINK_KEY::set_m_iroadid(::google::protobuf::int64 value) {
  set_has_m_iroadid();
  m_iroadid_ = value;
  // @@protoc_insertion_point(field_set:atd.map.LANE_LINK_KEY.m_iRoadId)
}

// optional int32 m_iSectionSeq = 2;
inline bool LANE_LINK_KEY::has_m_isectionseq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LANE_LINK_KEY::set_has_m_isectionseq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LANE_LINK_KEY::clear_has_m_isectionseq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LANE_LINK_KEY::clear_m_isectionseq() {
  m_isectionseq_ = 0;
  clear_has_m_isectionseq();
}
inline ::google::protobuf::int32 LANE_LINK_KEY::m_isectionseq() const {
  // @@protoc_insertion_point(field_get:atd.map.LANE_LINK_KEY.m_iSectionSeq)
  return m_isectionseq_;
}
inline void LANE_LINK_KEY::set_m_isectionseq(::google::protobuf::int32 value) {
  set_has_m_isectionseq();
  m_isectionseq_ = value;
  // @@protoc_insertion_point(field_set:atd.map.LANE_LINK_KEY.m_iSectionSeq)
}

// optional int32 m_iLaneNum = 3;
inline bool LANE_LINK_KEY::has_m_ilanenum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LANE_LINK_KEY::set_has_m_ilanenum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LANE_LINK_KEY::clear_has_m_ilanenum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LANE_LINK_KEY::clear_m_ilanenum() {
  m_ilanenum_ = 0;
  clear_has_m_ilanenum();
}
inline ::google::protobuf::int32 LANE_LINK_KEY::m_ilanenum() const {
  // @@protoc_insertion_point(field_get:atd.map.LANE_LINK_KEY.m_iLaneNum)
  return m_ilanenum_;
}
inline void LANE_LINK_KEY::set_m_ilanenum(::google::protobuf::int32 value) {
  set_has_m_ilanenum();
  m_ilanenum_ = value;
  // @@protoc_insertion_point(field_set:atd.map.LANE_LINK_KEY.m_iLaneNum)
}

// optional int32 m_iBranch = 4;
inline bool LANE_LINK_KEY::has_m_ibranch() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LANE_LINK_KEY::set_has_m_ibranch() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LANE_LINK_KEY::clear_has_m_ibranch() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LANE_LINK_KEY::clear_m_ibranch() {
  m_ibranch_ = 0;
  clear_has_m_ibranch();
}
inline ::google::protobuf::int32 LANE_LINK_KEY::m_ibranch() const {
  // @@protoc_insertion_point(field_get:atd.map.LANE_LINK_KEY.m_iBranch)
  return m_ibranch_;
}
inline void LANE_LINK_KEY::set_m_ibranch(::google::protobuf::int32 value) {
  set_has_m_ibranch();
  m_ibranch_ = value;
  // @@protoc_insertion_point(field_set:atd.map.LANE_LINK_KEY.m_iBranch)
}

// -------------------------------------------------------------------

// SPEED_LIMIT

// optional int32 m_iMaxSpeed = 1;
inline bool SPEED_LIMIT::has_m_imaxspeed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SPEED_LIMIT::set_has_m_imaxspeed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SPEED_LIMIT::clear_has_m_imaxspeed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SPEED_LIMIT::clear_m_imaxspeed() {
  m_imaxspeed_ = 0;
  clear_has_m_imaxspeed();
}
inline ::google::protobuf::int32 SPEED_LIMIT::m_imaxspeed() const {
  // @@protoc_insertion_point(field_get:atd.map.SPEED_LIMIT.m_iMaxSpeed)
  return m_imaxspeed_;
}
inline void SPEED_LIMIT::set_m_imaxspeed(::google::protobuf::int32 value) {
  set_has_m_imaxspeed();
  m_imaxspeed_ = value;
  // @@protoc_insertion_point(field_set:atd.map.SPEED_LIMIT.m_iMaxSpeed)
}

// optional int32 m_iMinSpeed = 2;
inline bool SPEED_LIMIT::has_m_iminspeed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SPEED_LIMIT::set_has_m_iminspeed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SPEED_LIMIT::clear_has_m_iminspeed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SPEED_LIMIT::clear_m_iminspeed() {
  m_iminspeed_ = 0;
  clear_has_m_iminspeed();
}
inline ::google::protobuf::int32 SPEED_LIMIT::m_iminspeed() const {
  // @@protoc_insertion_point(field_get:atd.map.SPEED_LIMIT.m_iMinSpeed)
  return m_iminspeed_;
}
inline void SPEED_LIMIT::set_m_iminspeed(::google::protobuf::int32 value) {
  set_has_m_iminspeed();
  m_iminspeed_ = value;
  // @@protoc_insertion_point(field_set:atd.map.SPEED_LIMIT.m_iMinSpeed)
}

// optional int32 m_iRecommentSpeed = 3;
inline bool SPEED_LIMIT::has_m_irecommentspeed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SPEED_LIMIT::set_has_m_irecommentspeed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SPEED_LIMIT::clear_has_m_irecommentspeed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SPEED_LIMIT::clear_m_irecommentspeed() {
  m_irecommentspeed_ = 0;
  clear_has_m_irecommentspeed();
}
inline ::google::protobuf::int32 SPEED_LIMIT::m_irecommentspeed() const {
  // @@protoc_insertion_point(field_get:atd.map.SPEED_LIMIT.m_iRecommentSpeed)
  return m_irecommentspeed_;
}
inline void SPEED_LIMIT::set_m_irecommentspeed(::google::protobuf::int32 value) {
  set_has_m_irecommentspeed();
  m_irecommentspeed_ = value;
  // @@protoc_insertion_point(field_set:atd.map.SPEED_LIMIT.m_iRecommentSpeed)
}

// -------------------------------------------------------------------

// TSR_DISTANCE

// optional .atd.map.SPEED_LIMIT stCurrentSpeedLimit = 2;
inline bool TSR_DISTANCE::has_stcurrentspeedlimit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TSR_DISTANCE::set_has_stcurrentspeedlimit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TSR_DISTANCE::clear_has_stcurrentspeedlimit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TSR_DISTANCE::clear_stcurrentspeedlimit() {
  if (stcurrentspeedlimit_ != NULL) stcurrentspeedlimit_->::atd::map::SPEED_LIMIT::Clear();
  clear_has_stcurrentspeedlimit();
}
inline const ::atd::map::SPEED_LIMIT& TSR_DISTANCE::stcurrentspeedlimit() const {
  // @@protoc_insertion_point(field_get:atd.map.TSR_DISTANCE.stCurrentSpeedLimit)
  return stcurrentspeedlimit_ != NULL ? *stcurrentspeedlimit_
                         : *::atd::map::SPEED_LIMIT::internal_default_instance();
}
inline ::atd::map::SPEED_LIMIT* TSR_DISTANCE::mutable_stcurrentspeedlimit() {
  set_has_stcurrentspeedlimit();
  if (stcurrentspeedlimit_ == NULL) {
    stcurrentspeedlimit_ = new ::atd::map::SPEED_LIMIT;
  }
  // @@protoc_insertion_point(field_mutable:atd.map.TSR_DISTANCE.stCurrentSpeedLimit)
  return stcurrentspeedlimit_;
}
inline ::atd::map::SPEED_LIMIT* TSR_DISTANCE::release_stcurrentspeedlimit() {
  // @@protoc_insertion_point(field_release:atd.map.TSR_DISTANCE.stCurrentSpeedLimit)
  clear_has_stcurrentspeedlimit();
  ::atd::map::SPEED_LIMIT* temp = stcurrentspeedlimit_;
  stcurrentspeedlimit_ = NULL;
  return temp;
}
inline void TSR_DISTANCE::set_allocated_stcurrentspeedlimit(::atd::map::SPEED_LIMIT* stcurrentspeedlimit) {
  delete stcurrentspeedlimit_;
  stcurrentspeedlimit_ = stcurrentspeedlimit;
  if (stcurrentspeedlimit) {
    set_has_stcurrentspeedlimit();
  } else {
    clear_has_stcurrentspeedlimit();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.map.TSR_DISTANCE.stCurrentSpeedLimit)
}

// optional .atd.map.SPEED_LIMIT stNextSpeedLimit = 3;
inline bool TSR_DISTANCE::has_stnextspeedlimit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TSR_DISTANCE::set_has_stnextspeedlimit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TSR_DISTANCE::clear_has_stnextspeedlimit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TSR_DISTANCE::clear_stnextspeedlimit() {
  if (stnextspeedlimit_ != NULL) stnextspeedlimit_->::atd::map::SPEED_LIMIT::Clear();
  clear_has_stnextspeedlimit();
}
inline const ::atd::map::SPEED_LIMIT& TSR_DISTANCE::stnextspeedlimit() const {
  // @@protoc_insertion_point(field_get:atd.map.TSR_DISTANCE.stNextSpeedLimit)
  return stnextspeedlimit_ != NULL ? *stnextspeedlimit_
                         : *::atd::map::SPEED_LIMIT::internal_default_instance();
}
inline ::atd::map::SPEED_LIMIT* TSR_DISTANCE::mutable_stnextspeedlimit() {
  set_has_stnextspeedlimit();
  if (stnextspeedlimit_ == NULL) {
    stnextspeedlimit_ = new ::atd::map::SPEED_LIMIT;
  }
  // @@protoc_insertion_point(field_mutable:atd.map.TSR_DISTANCE.stNextSpeedLimit)
  return stnextspeedlimit_;
}
inline ::atd::map::SPEED_LIMIT* TSR_DISTANCE::release_stnextspeedlimit() {
  // @@protoc_insertion_point(field_release:atd.map.TSR_DISTANCE.stNextSpeedLimit)
  clear_has_stnextspeedlimit();
  ::atd::map::SPEED_LIMIT* temp = stnextspeedlimit_;
  stnextspeedlimit_ = NULL;
  return temp;
}
inline void TSR_DISTANCE::set_allocated_stnextspeedlimit(::atd::map::SPEED_LIMIT* stnextspeedlimit) {
  delete stnextspeedlimit_;
  stnextspeedlimit_ = stnextspeedlimit;
  if (stnextspeedlimit) {
    set_has_stnextspeedlimit();
  } else {
    clear_has_stnextspeedlimit();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.map.TSR_DISTANCE.stNextSpeedLimit)
}

// optional .atd.map.LANE_LINK_KEY stCurrentLaneKey = 4;
inline bool TSR_DISTANCE::has_stcurrentlanekey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TSR_DISTANCE::set_has_stcurrentlanekey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TSR_DISTANCE::clear_has_stcurrentlanekey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TSR_DISTANCE::clear_stcurrentlanekey() {
  if (stcurrentlanekey_ != NULL) stcurrentlanekey_->::atd::map::LANE_LINK_KEY::Clear();
  clear_has_stcurrentlanekey();
}
inline const ::atd::map::LANE_LINK_KEY& TSR_DISTANCE::stcurrentlanekey() const {
  // @@protoc_insertion_point(field_get:atd.map.TSR_DISTANCE.stCurrentLaneKey)
  return stcurrentlanekey_ != NULL ? *stcurrentlanekey_
                         : *::atd::map::LANE_LINK_KEY::internal_default_instance();
}
inline ::atd::map::LANE_LINK_KEY* TSR_DISTANCE::mutable_stcurrentlanekey() {
  set_has_stcurrentlanekey();
  if (stcurrentlanekey_ == NULL) {
    stcurrentlanekey_ = new ::atd::map::LANE_LINK_KEY;
  }
  // @@protoc_insertion_point(field_mutable:atd.map.TSR_DISTANCE.stCurrentLaneKey)
  return stcurrentlanekey_;
}
inline ::atd::map::LANE_LINK_KEY* TSR_DISTANCE::release_stcurrentlanekey() {
  // @@protoc_insertion_point(field_release:atd.map.TSR_DISTANCE.stCurrentLaneKey)
  clear_has_stcurrentlanekey();
  ::atd::map::LANE_LINK_KEY* temp = stcurrentlanekey_;
  stcurrentlanekey_ = NULL;
  return temp;
}
inline void TSR_DISTANCE::set_allocated_stcurrentlanekey(::atd::map::LANE_LINK_KEY* stcurrentlanekey) {
  delete stcurrentlanekey_;
  stcurrentlanekey_ = stcurrentlanekey;
  if (stcurrentlanekey) {
    set_has_stcurrentlanekey();
  } else {
    clear_has_stcurrentlanekey();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.map.TSR_DISTANCE.stCurrentLaneKey)
}

// optional int32 iCurrentLaneKeyID = 5;
inline bool TSR_DISTANCE::has_icurrentlanekeyid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TSR_DISTANCE::set_has_icurrentlanekeyid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TSR_DISTANCE::clear_has_icurrentlanekeyid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TSR_DISTANCE::clear_icurrentlanekeyid() {
  icurrentlanekeyid_ = 0;
  clear_has_icurrentlanekeyid();
}
inline ::google::protobuf::int32 TSR_DISTANCE::icurrentlanekeyid() const {
  // @@protoc_insertion_point(field_get:atd.map.TSR_DISTANCE.iCurrentLaneKeyID)
  return icurrentlanekeyid_;
}
inline void TSR_DISTANCE::set_icurrentlanekeyid(::google::protobuf::int32 value) {
  set_has_icurrentlanekeyid();
  icurrentlanekeyid_ = value;
  // @@protoc_insertion_point(field_set:atd.map.TSR_DISTANCE.iCurrentLaneKeyID)
}

// optional int32 iTotleLaneKeyID = 6;
inline bool TSR_DISTANCE::has_itotlelanekeyid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TSR_DISTANCE::set_has_itotlelanekeyid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TSR_DISTANCE::clear_has_itotlelanekeyid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TSR_DISTANCE::clear_itotlelanekeyid() {
  itotlelanekeyid_ = 0;
  clear_has_itotlelanekeyid();
}
inline ::google::protobuf::int32 TSR_DISTANCE::itotlelanekeyid() const {
  // @@protoc_insertion_point(field_get:atd.map.TSR_DISTANCE.iTotleLaneKeyID)
  return itotlelanekeyid_;
}
inline void TSR_DISTANCE::set_itotlelanekeyid(::google::protobuf::int32 value) {
  set_has_itotlelanekeyid();
  itotlelanekeyid_ = value;
  // @@protoc_insertion_point(field_set:atd.map.TSR_DISTANCE.iTotleLaneKeyID)
}

// optional int32 iTurnFlag = 7;
inline bool TSR_DISTANCE::has_iturnflag() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TSR_DISTANCE::set_has_iturnflag() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TSR_DISTANCE::clear_has_iturnflag() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TSR_DISTANCE::clear_iturnflag() {
  iturnflag_ = 0;
  clear_has_iturnflag();
}
inline ::google::protobuf::int32 TSR_DISTANCE::iturnflag() const {
  // @@protoc_insertion_point(field_get:atd.map.TSR_DISTANCE.iTurnFlag)
  return iturnflag_;
}
inline void TSR_DISTANCE::set_iturnflag(::google::protobuf::int32 value) {
  set_has_iturnflag();
  iturnflag_ = value;
  // @@protoc_insertion_point(field_set:atd.map.TSR_DISTANCE.iTurnFlag)
}

// optional int32 iTurnStatus = 8;
inline bool TSR_DISTANCE::has_iturnstatus() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TSR_DISTANCE::set_has_iturnstatus() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TSR_DISTANCE::clear_has_iturnstatus() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TSR_DISTANCE::clear_iturnstatus() {
  iturnstatus_ = 0;
  clear_has_iturnstatus();
}
inline ::google::protobuf::int32 TSR_DISTANCE::iturnstatus() const {
  // @@protoc_insertion_point(field_get:atd.map.TSR_DISTANCE.iTurnStatus)
  return iturnstatus_;
}
inline void TSR_DISTANCE::set_iturnstatus(::google::protobuf::int32 value) {
  set_has_iturnstatus();
  iturnstatus_ = value;
  // @@protoc_insertion_point(field_set:atd.map.TSR_DISTANCE.iTurnStatus)
}

// optional int32 isCalculatedLane = 9;
inline bool TSR_DISTANCE::has_iscalculatedlane() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TSR_DISTANCE::set_has_iscalculatedlane() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TSR_DISTANCE::clear_has_iscalculatedlane() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TSR_DISTANCE::clear_iscalculatedlane() {
  iscalculatedlane_ = 0;
  clear_has_iscalculatedlane();
}
inline ::google::protobuf::int32 TSR_DISTANCE::iscalculatedlane() const {
  // @@protoc_insertion_point(field_get:atd.map.TSR_DISTANCE.isCalculatedLane)
  return iscalculatedlane_;
}
inline void TSR_DISTANCE::set_iscalculatedlane(::google::protobuf::int32 value) {
  set_has_iscalculatedlane();
  iscalculatedlane_ = value;
  // @@protoc_insertion_point(field_set:atd.map.TSR_DISTANCE.isCalculatedLane)
}

// optional int32 isDummyRoad = 10;
inline bool TSR_DISTANCE::has_isdummyroad() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TSR_DISTANCE::set_has_isdummyroad() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TSR_DISTANCE::clear_has_isdummyroad() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TSR_DISTANCE::clear_isdummyroad() {
  isdummyroad_ = 0;
  clear_has_isdummyroad();
}
inline ::google::protobuf::int32 TSR_DISTANCE::isdummyroad() const {
  // @@protoc_insertion_point(field_get:atd.map.TSR_DISTANCE.isDummyRoad)
  return isdummyroad_;
}
inline void TSR_DISTANCE::set_isdummyroad(::google::protobuf::int32 value) {
  set_has_isdummyroad();
  isdummyroad_ = value;
  // @@protoc_insertion_point(field_set:atd.map.TSR_DISTANCE.isDummyRoad)
}

// optional int32 iTotleStoplineNum = 11;
inline bool TSR_DISTANCE::has_itotlestoplinenum() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TSR_DISTANCE::set_has_itotlestoplinenum() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TSR_DISTANCE::clear_has_itotlestoplinenum() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TSR_DISTANCE::clear_itotlestoplinenum() {
  itotlestoplinenum_ = 0;
  clear_has_itotlestoplinenum();
}
inline ::google::protobuf::int32 TSR_DISTANCE::itotlestoplinenum() const {
  // @@protoc_insertion_point(field_get:atd.map.TSR_DISTANCE.iTotleStoplineNum)
  return itotlestoplinenum_;
}
inline void TSR_DISTANCE::set_itotlestoplinenum(::google::protobuf::int32 value) {
  set_has_itotlestoplinenum();
  itotlestoplinenum_ = value;
  // @@protoc_insertion_point(field_set:atd.map.TSR_DISTANCE.iTotleStoplineNum)
}

// optional int32 iRemainStoplineNum = 12;
inline bool TSR_DISTANCE::has_iremainstoplinenum() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TSR_DISTANCE::set_has_iremainstoplinenum() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TSR_DISTANCE::clear_has_iremainstoplinenum() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TSR_DISTANCE::clear_iremainstoplinenum() {
  iremainstoplinenum_ = 0;
  clear_has_iremainstoplinenum();
}
inline ::google::protobuf::int32 TSR_DISTANCE::iremainstoplinenum() const {
  // @@protoc_insertion_point(field_get:atd.map.TSR_DISTANCE.iRemainStoplineNum)
  return iremainstoplinenum_;
}
inline void TSR_DISTANCE::set_iremainstoplinenum(::google::protobuf::int32 value) {
  set_has_iremainstoplinenum();
  iremainstoplinenum_ = value;
  // @@protoc_insertion_point(field_set:atd.map.TSR_DISTANCE.iRemainStoplineNum)
}

// optional int32 isLeftTurnZone = 13;
inline bool TSR_DISTANCE::has_isleftturnzone() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TSR_DISTANCE::set_has_isleftturnzone() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TSR_DISTANCE::clear_has_isleftturnzone() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TSR_DISTANCE::clear_isleftturnzone() {
  isleftturnzone_ = 0;
  clear_has_isleftturnzone();
}
inline ::google::protobuf::int32 TSR_DISTANCE::isleftturnzone() const {
  // @@protoc_insertion_point(field_get:atd.map.TSR_DISTANCE.isLeftTurnZone)
  return isleftturnzone_;
}
inline void TSR_DISTANCE::set_isleftturnzone(::google::protobuf::int32 value) {
  set_has_isleftturnzone();
  isleftturnzone_ = value;
  // @@protoc_insertion_point(field_set:atd.map.TSR_DISTANCE.isLeftTurnZone)
}

// optional int32 iParkingStatus = 14;
inline bool TSR_DISTANCE::has_iparkingstatus() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TSR_DISTANCE::set_has_iparkingstatus() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TSR_DISTANCE::clear_has_iparkingstatus() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TSR_DISTANCE::clear_iparkingstatus() {
  iparkingstatus_ = 0;
  clear_has_iparkingstatus();
}
inline ::google::protobuf::int32 TSR_DISTANCE::iparkingstatus() const {
  // @@protoc_insertion_point(field_get:atd.map.TSR_DISTANCE.iParkingStatus)
  return iparkingstatus_;
}
inline void TSR_DISTANCE::set_iparkingstatus(::google::protobuf::int32 value) {
  set_has_iparkingstatus();
  iparkingstatus_ = value;
  // @@protoc_insertion_point(field_set:atd.map.TSR_DISTANCE.iParkingStatus)
}

// optional double dDistance2Stopline = 15;
inline bool TSR_DISTANCE::has_ddistance2stopline() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TSR_DISTANCE::set_has_ddistance2stopline() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TSR_DISTANCE::clear_has_ddistance2stopline() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TSR_DISTANCE::clear_ddistance2stopline() {
  ddistance2stopline_ = 0;
  clear_has_ddistance2stopline();
}
inline double TSR_DISTANCE::ddistance2stopline() const {
  // @@protoc_insertion_point(field_get:atd.map.TSR_DISTANCE.dDistance2Stopline)
  return ddistance2stopline_;
}
inline void TSR_DISTANCE::set_ddistance2stopline(double value) {
  set_has_ddistance2stopline();
  ddistance2stopline_ = value;
  // @@protoc_insertion_point(field_set:atd.map.TSR_DISTANCE.dDistance2Stopline)
}

// optional double dDistance2Destination = 16;
inline bool TSR_DISTANCE::has_ddistance2destination() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TSR_DISTANCE::set_has_ddistance2destination() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TSR_DISTANCE::clear_has_ddistance2destination() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TSR_DISTANCE::clear_ddistance2destination() {
  ddistance2destination_ = 0;
  clear_has_ddistance2destination();
}
inline double TSR_DISTANCE::ddistance2destination() const {
  // @@protoc_insertion_point(field_get:atd.map.TSR_DISTANCE.dDistance2Destination)
  return ddistance2destination_;
}
inline void TSR_DISTANCE::set_ddistance2destination(double value) {
  set_has_ddistance2destination();
  ddistance2destination_ = value;
  // @@protoc_insertion_point(field_set:atd.map.TSR_DISTANCE.dDistance2Destination)
}

// optional double dWholeRouteLength = 17;
inline bool TSR_DISTANCE::has_dwholeroutelength() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TSR_DISTANCE::set_has_dwholeroutelength() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TSR_DISTANCE::clear_has_dwholeroutelength() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TSR_DISTANCE::clear_dwholeroutelength() {
  dwholeroutelength_ = 0;
  clear_has_dwholeroutelength();
}
inline double TSR_DISTANCE::dwholeroutelength() const {
  // @@protoc_insertion_point(field_get:atd.map.TSR_DISTANCE.dWholeRouteLength)
  return dwholeroutelength_;
}
inline void TSR_DISTANCE::set_dwholeroutelength(double value) {
  set_has_dwholeroutelength();
  dwholeroutelength_ = value;
  // @@protoc_insertion_point(field_set:atd.map.TSR_DISTANCE.dWholeRouteLength)
}

// optional double dDistance2Parking = 18;
inline bool TSR_DISTANCE::has_ddistance2parking() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TSR_DISTANCE::set_has_ddistance2parking() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TSR_DISTANCE::clear_has_ddistance2parking() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TSR_DISTANCE::clear_ddistance2parking() {
  ddistance2parking_ = 0;
  clear_has_ddistance2parking();
}
inline double TSR_DISTANCE::ddistance2parking() const {
  // @@protoc_insertion_point(field_get:atd.map.TSR_DISTANCE.dDistance2Parking)
  return ddistance2parking_;
}
inline void TSR_DISTANCE::set_ddistance2parking(double value) {
  set_has_ddistance2parking();
  ddistance2parking_ = value;
  // @@protoc_insertion_point(field_set:atd.map.TSR_DISTANCE.dDistance2Parking)
}

// optional double dDistance2LaneEnd = 19;
inline bool TSR_DISTANCE::has_ddistance2laneend() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TSR_DISTANCE::set_has_ddistance2laneend() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TSR_DISTANCE::clear_has_ddistance2laneend() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TSR_DISTANCE::clear_ddistance2laneend() {
  ddistance2laneend_ = 0;
  clear_has_ddistance2laneend();
}
inline double TSR_DISTANCE::ddistance2laneend() const {
  // @@protoc_insertion_point(field_get:atd.map.TSR_DISTANCE.dDistance2LaneEnd)
  return ddistance2laneend_;
}
inline void TSR_DISTANCE::set_ddistance2laneend(double value) {
  set_has_ddistance2laneend();
  ddistance2laneend_ = value;
  // @@protoc_insertion_point(field_set:atd.map.TSR_DISTANCE.dDistance2LaneEnd)
}

// optional double dWholeParkingLength = 20;
inline bool TSR_DISTANCE::has_dwholeparkinglength() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TSR_DISTANCE::set_has_dwholeparkinglength() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TSR_DISTANCE::clear_has_dwholeparkinglength() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TSR_DISTANCE::clear_dwholeparkinglength() {
  dwholeparkinglength_ = 0;
  clear_has_dwholeparkinglength();
}
inline double TSR_DISTANCE::dwholeparkinglength() const {
  // @@protoc_insertion_point(field_get:atd.map.TSR_DISTANCE.dWholeParkingLength)
  return dwholeparkinglength_;
}
inline void TSR_DISTANCE::set_dwholeparkinglength(double value) {
  set_has_dwholeparkinglength();
  dwholeparkinglength_ = value;
  // @@protoc_insertion_point(field_set:atd.map.TSR_DISTANCE.dWholeParkingLength)
}

// -------------------------------------------------------------------

// ONE_PARKING_SITE

// repeated .atd.map.LANE_LINK_KEY stAttachedRoad = 2;
inline int ONE_PARKING_SITE::stattachedroad_size() const {
  return stattachedroad_.size();
}
inline void ONE_PARKING_SITE::clear_stattachedroad() {
  stattachedroad_.Clear();
}
inline const ::atd::map::LANE_LINK_KEY& ONE_PARKING_SITE::stattachedroad(int index) const {
  // @@protoc_insertion_point(field_get:atd.map.ONE_PARKING_SITE.stAttachedRoad)
  return stattachedroad_.Get(index);
}
inline ::atd::map::LANE_LINK_KEY* ONE_PARKING_SITE::mutable_stattachedroad(int index) {
  // @@protoc_insertion_point(field_mutable:atd.map.ONE_PARKING_SITE.stAttachedRoad)
  return stattachedroad_.Mutable(index);
}
inline ::atd::map::LANE_LINK_KEY* ONE_PARKING_SITE::add_stattachedroad() {
  // @@protoc_insertion_point(field_add:atd.map.ONE_PARKING_SITE.stAttachedRoad)
  return stattachedroad_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::atd::map::LANE_LINK_KEY >*
ONE_PARKING_SITE::mutable_stattachedroad() {
  // @@protoc_insertion_point(field_mutable_list:atd.map.ONE_PARKING_SITE.stAttachedRoad)
  return &stattachedroad_;
}
inline const ::google::protobuf::RepeatedPtrField< ::atd::map::LANE_LINK_KEY >&
ONE_PARKING_SITE::stattachedroad() const {
  // @@protoc_insertion_point(field_list:atd.map.ONE_PARKING_SITE.stAttachedRoad)
  return stattachedroad_;
}

// optional .atd.common.Point3D stPoint2VehicleCor = 3;
inline bool ONE_PARKING_SITE::has_stpoint2vehiclecor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ONE_PARKING_SITE::set_has_stpoint2vehiclecor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ONE_PARKING_SITE::clear_has_stpoint2vehiclecor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ONE_PARKING_SITE::clear_stpoint2vehiclecor() {
  if (stpoint2vehiclecor_ != NULL) stpoint2vehiclecor_->::atd::common::Point3D::Clear();
  clear_has_stpoint2vehiclecor();
}
inline const ::atd::common::Point3D& ONE_PARKING_SITE::stpoint2vehiclecor() const {
  // @@protoc_insertion_point(field_get:atd.map.ONE_PARKING_SITE.stPoint2VehicleCor)
  return stpoint2vehiclecor_ != NULL ? *stpoint2vehiclecor_
                         : *::atd::common::Point3D::internal_default_instance();
}
inline ::atd::common::Point3D* ONE_PARKING_SITE::mutable_stpoint2vehiclecor() {
  set_has_stpoint2vehiclecor();
  if (stpoint2vehiclecor_ == NULL) {
    stpoint2vehiclecor_ = new ::atd::common::Point3D;
  }
  // @@protoc_insertion_point(field_mutable:atd.map.ONE_PARKING_SITE.stPoint2VehicleCor)
  return stpoint2vehiclecor_;
}
inline ::atd::common::Point3D* ONE_PARKING_SITE::release_stpoint2vehiclecor() {
  // @@protoc_insertion_point(field_release:atd.map.ONE_PARKING_SITE.stPoint2VehicleCor)
  clear_has_stpoint2vehiclecor();
  ::atd::common::Point3D* temp = stpoint2vehiclecor_;
  stpoint2vehiclecor_ = NULL;
  return temp;
}
inline void ONE_PARKING_SITE::set_allocated_stpoint2vehiclecor(::atd::common::Point3D* stpoint2vehiclecor) {
  delete stpoint2vehiclecor_;
  stpoint2vehiclecor_ = stpoint2vehiclecor;
  if (stpoint2vehiclecor) {
    set_has_stpoint2vehiclecor();
  } else {
    clear_has_stpoint2vehiclecor();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.map.ONE_PARKING_SITE.stPoint2VehicleCor)
}

// repeated .atd.common.Point3D stShapePoint2VehicleCor = 4;
inline int ONE_PARKING_SITE::stshapepoint2vehiclecor_size() const {
  return stshapepoint2vehiclecor_.size();
}
inline void ONE_PARKING_SITE::clear_stshapepoint2vehiclecor() {
  stshapepoint2vehiclecor_.Clear();
}
inline const ::atd::common::Point3D& ONE_PARKING_SITE::stshapepoint2vehiclecor(int index) const {
  // @@protoc_insertion_point(field_get:atd.map.ONE_PARKING_SITE.stShapePoint2VehicleCor)
  return stshapepoint2vehiclecor_.Get(index);
}
inline ::atd::common::Point3D* ONE_PARKING_SITE::mutable_stshapepoint2vehiclecor(int index) {
  // @@protoc_insertion_point(field_mutable:atd.map.ONE_PARKING_SITE.stShapePoint2VehicleCor)
  return stshapepoint2vehiclecor_.Mutable(index);
}
inline ::atd::common::Point3D* ONE_PARKING_SITE::add_stshapepoint2vehiclecor() {
  // @@protoc_insertion_point(field_add:atd.map.ONE_PARKING_SITE.stShapePoint2VehicleCor)
  return stshapepoint2vehiclecor_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::atd::common::Point3D >*
ONE_PARKING_SITE::mutable_stshapepoint2vehiclecor() {
  // @@protoc_insertion_point(field_mutable_list:atd.map.ONE_PARKING_SITE.stShapePoint2VehicleCor)
  return &stshapepoint2vehiclecor_;
}
inline const ::google::protobuf::RepeatedPtrField< ::atd::common::Point3D >&
ONE_PARKING_SITE::stshapepoint2vehiclecor() const {
  // @@protoc_insertion_point(field_list:atd.map.ONE_PARKING_SITE.stShapePoint2VehicleCor)
  return stshapepoint2vehiclecor_;
}

// optional int32 iAttachedRoadCount = 5;
inline bool ONE_PARKING_SITE::has_iattachedroadcount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ONE_PARKING_SITE::set_has_iattachedroadcount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ONE_PARKING_SITE::clear_has_iattachedroadcount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ONE_PARKING_SITE::clear_iattachedroadcount() {
  iattachedroadcount_ = 0;
  clear_has_iattachedroadcount();
}
inline ::google::protobuf::int32 ONE_PARKING_SITE::iattachedroadcount() const {
  // @@protoc_insertion_point(field_get:atd.map.ONE_PARKING_SITE.iAttachedRoadCount)
  return iattachedroadcount_;
}
inline void ONE_PARKING_SITE::set_iattachedroadcount(::google::protobuf::int32 value) {
  set_has_iattachedroadcount();
  iattachedroadcount_ = value;
  // @@protoc_insertion_point(field_set:atd.map.ONE_PARKING_SITE.iAttachedRoadCount)
}

// optional int32 iSID = 6;
inline bool ONE_PARKING_SITE::has_isid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ONE_PARKING_SITE::set_has_isid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ONE_PARKING_SITE::clear_has_isid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ONE_PARKING_SITE::clear_isid() {
  isid_ = 0;
  clear_has_isid();
}
inline ::google::protobuf::int32 ONE_PARKING_SITE::isid() const {
  // @@protoc_insertion_point(field_get:atd.map.ONE_PARKING_SITE.iSID)
  return isid_;
}
inline void ONE_PARKING_SITE::set_isid(::google::protobuf::int32 value) {
  set_has_isid();
  isid_ = value;
  // @@protoc_insertion_point(field_set:atd.map.ONE_PARKING_SITE.iSID)
}

// optional int32 iLength = 7;
inline bool ONE_PARKING_SITE::has_ilength() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ONE_PARKING_SITE::set_has_ilength() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ONE_PARKING_SITE::clear_has_ilength() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ONE_PARKING_SITE::clear_ilength() {
  ilength_ = 0;
  clear_has_ilength();
}
inline ::google::protobuf::int32 ONE_PARKING_SITE::ilength() const {
  // @@protoc_insertion_point(field_get:atd.map.ONE_PARKING_SITE.iLength)
  return ilength_;
}
inline void ONE_PARKING_SITE::set_ilength(::google::protobuf::int32 value) {
  set_has_ilength();
  ilength_ = value;
  // @@protoc_insertion_point(field_set:atd.map.ONE_PARKING_SITE.iLength)
}

// optional int32 iWidth = 8;
inline bool ONE_PARKING_SITE::has_iwidth() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ONE_PARKING_SITE::set_has_iwidth() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ONE_PARKING_SITE::clear_has_iwidth() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ONE_PARKING_SITE::clear_iwidth() {
  iwidth_ = 0;
  clear_has_iwidth();
}
inline ::google::protobuf::int32 ONE_PARKING_SITE::iwidth() const {
  // @@protoc_insertion_point(field_get:atd.map.ONE_PARKING_SITE.iWidth)
  return iwidth_;
}
inline void ONE_PARKING_SITE::set_iwidth(::google::protobuf::int32 value) {
  set_has_iwidth();
  iwidth_ = value;
  // @@protoc_insertion_point(field_set:atd.map.ONE_PARKING_SITE.iWidth)
}

// optional int32 iAttribute = 9;
inline bool ONE_PARKING_SITE::has_iattribute() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ONE_PARKING_SITE::set_has_iattribute() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ONE_PARKING_SITE::clear_has_iattribute() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ONE_PARKING_SITE::clear_iattribute() {
  iattribute_ = 0;
  clear_has_iattribute();
}
inline ::google::protobuf::int32 ONE_PARKING_SITE::iattribute() const {
  // @@protoc_insertion_point(field_get:atd.map.ONE_PARKING_SITE.iAttribute)
  return iattribute_;
}
inline void ONE_PARKING_SITE::set_iattribute(::google::protobuf::int32 value) {
  set_has_iattribute();
  iattribute_ = value;
  // @@protoc_insertion_point(field_set:atd.map.ONE_PARKING_SITE.iAttribute)
}

// optional int32 iStyle = 10;
inline bool ONE_PARKING_SITE::has_istyle() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ONE_PARKING_SITE::set_has_istyle() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ONE_PARKING_SITE::clear_has_istyle() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ONE_PARKING_SITE::clear_istyle() {
  istyle_ = 0;
  clear_has_istyle();
}
inline ::google::protobuf::int32 ONE_PARKING_SITE::istyle() const {
  // @@protoc_insertion_point(field_get:atd.map.ONE_PARKING_SITE.iStyle)
  return istyle_;
}
inline void ONE_PARKING_SITE::set_istyle(::google::protobuf::int32 value) {
  set_has_istyle();
  istyle_ = value;
  // @@protoc_insertion_point(field_set:atd.map.ONE_PARKING_SITE.iStyle)
}

// optional int32 iShapeType = 11;
inline bool ONE_PARKING_SITE::has_ishapetype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ONE_PARKING_SITE::set_has_ishapetype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ONE_PARKING_SITE::clear_has_ishapetype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ONE_PARKING_SITE::clear_ishapetype() {
  ishapetype_ = 0;
  clear_has_ishapetype();
}
inline ::google::protobuf::int32 ONE_PARKING_SITE::ishapetype() const {
  // @@protoc_insertion_point(field_get:atd.map.ONE_PARKING_SITE.iShapeType)
  return ishapetype_;
}
inline void ONE_PARKING_SITE::set_ishapetype(::google::protobuf::int32 value) {
  set_has_ishapetype();
  ishapetype_ = value;
  // @@protoc_insertion_point(field_set:atd.map.ONE_PARKING_SITE.iShapeType)
}

// optional int32 iShapeNum = 12;
inline bool ONE_PARKING_SITE::has_ishapenum() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ONE_PARKING_SITE::set_has_ishapenum() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ONE_PARKING_SITE::clear_has_ishapenum() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ONE_PARKING_SITE::clear_ishapenum() {
  ishapenum_ = 0;
  clear_has_ishapenum();
}
inline ::google::protobuf::int32 ONE_PARKING_SITE::ishapenum() const {
  // @@protoc_insertion_point(field_get:atd.map.ONE_PARKING_SITE.iShapeNum)
  return ishapenum_;
}
inline void ONE_PARKING_SITE::set_ishapenum(::google::protobuf::int32 value) {
  set_has_ishapenum();
  ishapenum_ = value;
  // @@protoc_insertion_point(field_set:atd.map.ONE_PARKING_SITE.iShapeNum)
}

// optional int32 iAppStatus = 13;
inline bool ONE_PARKING_SITE::has_iappstatus() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ONE_PARKING_SITE::set_has_iappstatus() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ONE_PARKING_SITE::clear_has_iappstatus() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ONE_PARKING_SITE::clear_iappstatus() {
  iappstatus_ = 0;
  clear_has_iappstatus();
}
inline ::google::protobuf::int32 ONE_PARKING_SITE::iappstatus() const {
  // @@protoc_insertion_point(field_get:atd.map.ONE_PARKING_SITE.iAppStatus)
  return iappstatus_;
}
inline void ONE_PARKING_SITE::set_iappstatus(::google::protobuf::int32 value) {
  set_has_iappstatus();
  iappstatus_ = value;
  // @@protoc_insertion_point(field_set:atd.map.ONE_PARKING_SITE.iAppStatus)
}

// optional int32 iAdd = 14;
inline bool ONE_PARKING_SITE::has_iadd() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ONE_PARKING_SITE::set_has_iadd() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ONE_PARKING_SITE::clear_has_iadd() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ONE_PARKING_SITE::clear_iadd() {
  iadd_ = 0;
  clear_has_iadd();
}
inline ::google::protobuf::int32 ONE_PARKING_SITE::iadd() const {
  // @@protoc_insertion_point(field_get:atd.map.ONE_PARKING_SITE.iAdd)
  return iadd_;
}
inline void ONE_PARKING_SITE::set_iadd(::google::protobuf::int32 value) {
  set_has_iadd();
  iadd_ = value;
  // @@protoc_insertion_point(field_set:atd.map.ONE_PARKING_SITE.iAdd)
}

// -------------------------------------------------------------------

// EngineRemainDistance

// optional .atd.common.Header header = 1;
inline bool EngineRemainDistance::has_header() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EngineRemainDistance::set_has_header() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EngineRemainDistance::clear_has_header() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EngineRemainDistance::clear_header() {
  if (header_ != NULL) header_->::atd::common::Header::Clear();
  clear_has_header();
}
inline const ::atd::common::Header& EngineRemainDistance::header() const {
  // @@protoc_insertion_point(field_get:atd.map.EngineRemainDistance.header)
  return header_ != NULL ? *header_
                         : *::atd::common::Header::internal_default_instance();
}
inline ::atd::common::Header* EngineRemainDistance::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::atd::common::Header;
  }
  // @@protoc_insertion_point(field_mutable:atd.map.EngineRemainDistance.header)
  return header_;
}
inline ::atd::common::Header* EngineRemainDistance::release_header() {
  // @@protoc_insertion_point(field_release:atd.map.EngineRemainDistance.header)
  clear_has_header();
  ::atd::common::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void EngineRemainDistance::set_allocated_header(::atd::common::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.map.EngineRemainDistance.header)
}

// optional .atd.common.Reserved reservedmsg = 2;
inline bool EngineRemainDistance::has_reservedmsg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EngineRemainDistance::set_has_reservedmsg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EngineRemainDistance::clear_has_reservedmsg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EngineRemainDistance::clear_reservedmsg() {
  if (reservedmsg_ != NULL) reservedmsg_->::atd::common::Reserved::Clear();
  clear_has_reservedmsg();
}
inline const ::atd::common::Reserved& EngineRemainDistance::reservedmsg() const {
  // @@protoc_insertion_point(field_get:atd.map.EngineRemainDistance.reservedmsg)
  return reservedmsg_ != NULL ? *reservedmsg_
                         : *::atd::common::Reserved::internal_default_instance();
}
inline ::atd::common::Reserved* EngineRemainDistance::mutable_reservedmsg() {
  set_has_reservedmsg();
  if (reservedmsg_ == NULL) {
    reservedmsg_ = new ::atd::common::Reserved;
  }
  // @@protoc_insertion_point(field_mutable:atd.map.EngineRemainDistance.reservedmsg)
  return reservedmsg_;
}
inline ::atd::common::Reserved* EngineRemainDistance::release_reservedmsg() {
  // @@protoc_insertion_point(field_release:atd.map.EngineRemainDistance.reservedmsg)
  clear_has_reservedmsg();
  ::atd::common::Reserved* temp = reservedmsg_;
  reservedmsg_ = NULL;
  return temp;
}
inline void EngineRemainDistance::set_allocated_reservedmsg(::atd::common::Reserved* reservedmsg) {
  delete reservedmsg_;
  reservedmsg_ = reservedmsg;
  if (reservedmsg) {
    set_has_reservedmsg();
  } else {
    clear_has_reservedmsg();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.map.EngineRemainDistance.reservedmsg)
}

// optional .atd.localization.Pose pose = 3;
inline bool EngineRemainDistance::has_pose() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EngineRemainDistance::set_has_pose() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EngineRemainDistance::clear_has_pose() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EngineRemainDistance::clear_pose() {
  if (pose_ != NULL) pose_->::atd::localization::Pose::Clear();
  clear_has_pose();
}
inline const ::atd::localization::Pose& EngineRemainDistance::pose() const {
  // @@protoc_insertion_point(field_get:atd.map.EngineRemainDistance.pose)
  return pose_ != NULL ? *pose_
                         : *::atd::localization::Pose::internal_default_instance();
}
inline ::atd::localization::Pose* EngineRemainDistance::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) {
    pose_ = new ::atd::localization::Pose;
  }
  // @@protoc_insertion_point(field_mutable:atd.map.EngineRemainDistance.pose)
  return pose_;
}
inline ::atd::localization::Pose* EngineRemainDistance::release_pose() {
  // @@protoc_insertion_point(field_release:atd.map.EngineRemainDistance.pose)
  clear_has_pose();
  ::atd::localization::Pose* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline void EngineRemainDistance::set_allocated_pose(::atd::localization::Pose* pose) {
  delete pose_;
  pose_ = pose;
  if (pose) {
    set_has_pose();
  } else {
    clear_has_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.map.EngineRemainDistance.pose)
}

// optional .atd.map.TSR_DISTANCE tsrdistance = 4;
inline bool EngineRemainDistance::has_tsrdistance() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EngineRemainDistance::set_has_tsrdistance() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EngineRemainDistance::clear_has_tsrdistance() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EngineRemainDistance::clear_tsrdistance() {
  if (tsrdistance_ != NULL) tsrdistance_->::atd::map::TSR_DISTANCE::Clear();
  clear_has_tsrdistance();
}
inline const ::atd::map::TSR_DISTANCE& EngineRemainDistance::tsrdistance() const {
  // @@protoc_insertion_point(field_get:atd.map.EngineRemainDistance.tsrdistance)
  return tsrdistance_ != NULL ? *tsrdistance_
                         : *::atd::map::TSR_DISTANCE::internal_default_instance();
}
inline ::atd::map::TSR_DISTANCE* EngineRemainDistance::mutable_tsrdistance() {
  set_has_tsrdistance();
  if (tsrdistance_ == NULL) {
    tsrdistance_ = new ::atd::map::TSR_DISTANCE;
  }
  // @@protoc_insertion_point(field_mutable:atd.map.EngineRemainDistance.tsrdistance)
  return tsrdistance_;
}
inline ::atd::map::TSR_DISTANCE* EngineRemainDistance::release_tsrdistance() {
  // @@protoc_insertion_point(field_release:atd.map.EngineRemainDistance.tsrdistance)
  clear_has_tsrdistance();
  ::atd::map::TSR_DISTANCE* temp = tsrdistance_;
  tsrdistance_ = NULL;
  return temp;
}
inline void EngineRemainDistance::set_allocated_tsrdistance(::atd::map::TSR_DISTANCE* tsrdistance) {
  delete tsrdistance_;
  tsrdistance_ = tsrdistance;
  if (tsrdistance) {
    set_has_tsrdistance();
  } else {
    clear_has_tsrdistance();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.map.EngineRemainDistance.tsrdistance)
}

// optional .atd.map.ONE_PARKING_SITE oneparkingsite = 5;
inline bool EngineRemainDistance::has_oneparkingsite() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EngineRemainDistance::set_has_oneparkingsite() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EngineRemainDistance::clear_has_oneparkingsite() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EngineRemainDistance::clear_oneparkingsite() {
  if (oneparkingsite_ != NULL) oneparkingsite_->::atd::map::ONE_PARKING_SITE::Clear();
  clear_has_oneparkingsite();
}
inline const ::atd::map::ONE_PARKING_SITE& EngineRemainDistance::oneparkingsite() const {
  // @@protoc_insertion_point(field_get:atd.map.EngineRemainDistance.oneparkingsite)
  return oneparkingsite_ != NULL ? *oneparkingsite_
                         : *::atd::map::ONE_PARKING_SITE::internal_default_instance();
}
inline ::atd::map::ONE_PARKING_SITE* EngineRemainDistance::mutable_oneparkingsite() {
  set_has_oneparkingsite();
  if (oneparkingsite_ == NULL) {
    oneparkingsite_ = new ::atd::map::ONE_PARKING_SITE;
  }
  // @@protoc_insertion_point(field_mutable:atd.map.EngineRemainDistance.oneparkingsite)
  return oneparkingsite_;
}
inline ::atd::map::ONE_PARKING_SITE* EngineRemainDistance::release_oneparkingsite() {
  // @@protoc_insertion_point(field_release:atd.map.EngineRemainDistance.oneparkingsite)
  clear_has_oneparkingsite();
  ::atd::map::ONE_PARKING_SITE* temp = oneparkingsite_;
  oneparkingsite_ = NULL;
  return temp;
}
inline void EngineRemainDistance::set_allocated_oneparkingsite(::atd::map::ONE_PARKING_SITE* oneparkingsite) {
  delete oneparkingsite_;
  oneparkingsite_ = oneparkingsite;
  if (oneparkingsite) {
    set_has_oneparkingsite();
  } else {
    clear_has_oneparkingsite();
  }
  // @@protoc_insertion_point(field_set_allocated:atd.map.EngineRemainDistance.oneparkingsite)
}

// optional string sTaskID = 6;
inline bool EngineRemainDistance::has_staskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EngineRemainDistance::set_has_staskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EngineRemainDistance::clear_has_staskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EngineRemainDistance::clear_staskid() {
  staskid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_staskid();
}
inline const ::std::string& EngineRemainDistance::staskid() const {
  // @@protoc_insertion_point(field_get:atd.map.EngineRemainDistance.sTaskID)
  return staskid_.GetNoArena();
}
inline void EngineRemainDistance::set_staskid(const ::std::string& value) {
  set_has_staskid();
  staskid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:atd.map.EngineRemainDistance.sTaskID)
}
#if LANG_CXX11
inline void EngineRemainDistance::set_staskid(::std::string&& value) {
  set_has_staskid();
  staskid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:atd.map.EngineRemainDistance.sTaskID)
}
#endif
inline void EngineRemainDistance::set_staskid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_staskid();
  staskid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:atd.map.EngineRemainDistance.sTaskID)
}
inline void EngineRemainDistance::set_staskid(const char* value, size_t size) {
  set_has_staskid();
  staskid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:atd.map.EngineRemainDistance.sTaskID)
}
inline ::std::string* EngineRemainDistance::mutable_staskid() {
  set_has_staskid();
  // @@protoc_insertion_point(field_mutable:atd.map.EngineRemainDistance.sTaskID)
  return staskid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EngineRemainDistance::release_staskid() {
  // @@protoc_insertion_point(field_release:atd.map.EngineRemainDistance.sTaskID)
  clear_has_staskid();
  return staskid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EngineRemainDistance::set_allocated_staskid(::std::string* staskid) {
  if (staskid != NULL) {
    set_has_staskid();
  } else {
    clear_has_staskid();
  }
  staskid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), staskid);
  // @@protoc_insertion_point(field_set_allocated:atd.map.EngineRemainDistance.sTaskID)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace map
}  // namespace atd

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_modules_2fipc_2fmessage_2fprotobuf_2fhdmap_2fengineremaindistance_2eproto__INCLUDED
